%%% Bibliography, roughly sorted by year of publication
% (See TODO at the end for more)

@preamble{
}

%% 1843

% Scientific Memoirs, Selected from the Transactions of Foreign Academies of Science and Learned Societies, and from Foreign Journals, R. and J. E. Taylor , Vol III, 1843
% https://x.com/Ngnghm/status/1940199868037046726
% From https://www.netlib.org/bibnet/authors/l/lovelace-ada-augusta.html
@InCollection{Lovelace1843,
  author={Augusta Ada Lovelace},
  booktitle={Richard Taylor's Scientific Memoirs},
  title={Notes [on translation of Luigi Federico Menebrae's paper on Babbage's Analytical Engine]},
  pages={666--731},
  month=August,
  year=1843,
  url={https://www.google.com/books/edition/Scientific_Memoirs_Selected_from_the_Tra/qsY-AAAAYAAJ?gbpv=1&pg=PA666},
  note={.
    This paper is the verily the foundation of all Computer Science,
    which should rightfully be called by the name Lovelace baptized it:
    “the science of operations”.
    Ada Augusta King, Countess of Lovelace, translates to English
    an article (in French) about the Babbage Analytical Engine,
    by Luigi Menebrae, who would later become Prime Minister of newly-unified Italy;
    and her translator’s notes are fantastic.
    Only her initials appear (A.A.L, at one point mistyped A.L.L.),
    because a woman, especially a noble one, shall not write, especially not on such lowly topics.
    But my, her understanding of “operations”, the general notion of pure computation,
    is better than that of most computer scientists of today.
    “First the symbols of _operation_ are frequently _also_ the symbols of the _results_ of operations.
    We say that symbols are apt to have both a _retrospective_ and a _prospective_ signification. […]”
    She groks both that there is a conflation of multiple meanings, and that it is good,
    yet can lead to confusion if not made explicit:
    past vs future, passive vs active, values vs continuations.
    She also anticipates symbolic computing:
    “symbolical” vs “numerical” “results” or “data” (outputs or inputs);
    and the equivalence of code and data:
    “the symbols of _numerical magnitude_, are frequently _also_ the symbols of _operations_”.
    She understands that programmability (she lacks the word)
    makes the Analytical engine vastly superior to the finite-configuration Difference Engine,
    indeed makes it “the executive right hand of abstract algebra”.
    She also confronts the problem that a variable may be bound to multiple values during an execution,
    and proposes an elegant solution, using a superscript to the left of a variable
    to number each successive binding, turning them into actual mathematical variables again.
    Way more advanced than most computer scientists even today.
    Prescient.
  }
}

%% 1844

@book{dumas1844,
  author={Alexandre Dumas},
  title={Les Trois Mousquetaires},
  year={1844},
  url={https://fr.wikisource.org/wiki/Les_Trois_Mousquetaires},
  note={.
        This novel, despite being named “The Three Musketeers”,
        famously has four musketeers as protagonists.
        Admittedly, the main protagonist isn’t one yet
        when he meets (and duels!) the other three.}
}

%% 1947
@book{levi1947,
  author={Primo Levi},
  title={Se questo è un uomo},
  publisher={De Silva},
  year={1947},
  note={
    This book impressed me when I read it as a young man (in a French translation),
    and the words “Hier ist kein ‘Warum’!” (Here there is no ‘Why’!) still haunt me.
    A 1959 translation to English by Stuart Woolf was published as “If this is a man”,
    or in later editions “Survival in Auschwitz”.
  }
}

%% 1961

@article{lonergan1961,
  author = {Lonergan, William M. and King, Paul A.},
  title = {Design of the B5000 System},
  journal = {Datamation},
  volume = {7},
  number = {5},
  pages = {28--32},
  year = {1961},
  url={https://people.eecs.berkeley.edu/~kubitron/courses/cs252-S12/handouts/papers/b5000.pdf},
  note={.
    The paper presents the Burroughs B5000 computer architecture,
    one of the sources of inspiration cited by Alan Kay.
    It features: a push-down stack (with “right-hand” Polish notation that prefigures FORTH!);
    “independence of addressing” (memory position-independence for both code and data)
    through a “program reference table” (relocatable table for indirect addressing,
    prefigures not just global linker tables, but also an object’s virtual dispatch table).}
}

@inproceedings{barton1961,
  author = {Barton, R. S.},
  title = {A New Approach to the Functional Design of a Digital Computer},
  year = {1961},
  isbn = {9781450378727},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1460690.1460736},
  doi = {10.1145/1460690.1460736},
  abstract = {The present methods of determining the functional design of computers are critically reviewed and a new approach proposed. This is illustrated by explaining, in abstracted form, part of the control organization of a new and different machine based, in part, on the ALGOL 60 language. The concepts of expression and procedure lead directly to use of a Polish string program. A new arrangement of control registers results, which provides for automatic allocation of temporary storage within expressions and procedures, and a generalized subroutine linkage. The simplicity and power of these notions suggests that there is much room for improvement in present machines and that more attention should be given to control functions in new designs.},
  booktitle = {Papers Presented at the May 9-11, 1961, Western Joint IRE-AIEE-ACM Computer Conference},
  pages = {393–396},
  numpages = {4},
  location = {Los Angeles, California},
  series = {IRE-AIEE-ACM '61 (Western)},
  note={.
    This paper shows how the author architected the Burroughs B5000
    to support the execution of high-level languages (notably ALGOL 60).
    It is hard to read because it is dated; what was obvious then isn’t now,
    while many ideas that were new then seem obvious now.
    Still, Alan Kay cites the B5000 as a breakthrough, and I believe him.
  }
}

%% 1963

@inproceedings{sketchpad1963,
  author = {Ivan E. Sutherland},
  title = {Sketchpad: A Man-Machine Graphical Communication System},
  year = {1963},
  isbn = {9781450378802},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1461551.1461591},
  doi = {10.1145/1461551.1461591},
  abstract = {The Sketchpad system makes it possible for a man and a computer to converse rapidly through the medium of line drawings. Heretofore, most interaction between man and computers has been slowed down by the need to reduce all communication to written statements that can be typed; in the past, we have been writing letters to rather than conferring with our computers. For many types of communication, such as describing the shape of a mechanical part or the connections of an electrical circuit, typed statements can prove cumbersome. The Sketchpad system, by eliminating typed statements (except for legends) in favor of line drawings, opens up a new area of man-machine communication.},
  booktitle = {Proceedings of the May 21-23, 1963, Spring Joint Computer Conference},
  pages = {329–346},
  numpages = {18},
  location = {Detroit, Michigan},
  series = {AFIPS '63 (Spring)},
}

%% 1965

@article{hoare1965record,
  title={Record handling},
  author={Hoare, C.A.R.},
  journal={Algol Bulletin},
  volume={21},
  pages={39--69},
  year={1965},
  url={http://archive.computerhistory.org/resources/text/Knuth_Don_X4100/PDF_index/k-9-pdf/k-9-u2293-Record-Handling-Hoare.pdf},
  note={.
        This seminal paper introduces classes and subclasses,
        and many other notions now familiar and ubiquitous,
        including his infamous "million dollar mistake", null.
        Hoare calls "objects" and "attributes" high-level entities being modeled, "classes" their types,
        "records" and "fields" the low-level representations of the previous as
        "consecutive words of computer store", and "record classes" their types.
        "References" are typed pointers, and "null" is a special reference
        for when a correspondence is partial rather than total.
        "Discrimination" is a form of type-safe pattern-matching between subclasses.
        Hoare considers recursive data structures, yet does not anticipate that
        for them, subclassing will differ from subtyping.}
}
% How original are the boxes-and-arrows drawings for pointers? The heap allocation?
% compacting garbage collection - Aha, he cites LISP. And SIMULA.

%% 1966

% Warren Teitelman MIT PhD dissertation "Pilot: A Step Toward Man-Computer Symbiosis" 1966
% Gabriel2012 claims it introduces mixins as "advice".
@PhDThesis{teitelman1966,
  author={Warren Teitelman},
  title={PILOT: a step toward man-computer symbiosis},
  year={1966},
  school={MIT},
  url={https://dspace.mit.edu/bitstream/handle/1721.1/6905/AITR-221.pdf},
  note={.
    This thesis is very rich in ideas, but the one that matters most for OO
    is Teitelman’s introduction of ADVISE, a facility a function with new behavior:
    advices to be run before or after the function, or somehow wrapping it,
    that you add or remove dynamically.
    This would later inspire Cannon 1979’s method combinations.
  }
}

% Simula I back in 1966 has processes and more, but DOES NOT have OO
@article{Simula1966,
  author = {Dahl, Ole-Johan and Nygaard, Kristen},
  title = {SIMULA: An ALGOL-Based Simulation Language},
  year = {1966},
  issue_date = {Sept. 1966},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {9},
  number = {9},
  issn = {0001-0782},
  url = {https://doi.org/10.1145/365813.365819},
  doi = {10.1145/365813.365819},
  abstract = {This paper is an introduction to SIMULA, a programming language designed to provide a systems analyst with unified concepts which facilitate the concise description of discrete event systems. A system description also serves as a source language simulation program. SIMULA is an extension of ALGOL 60 in which the most important new concept is that of quasi-parallel processing.},
  journal = {Commun. ACM},
  month = {sep},
  pages = {671--678},
  numpages = {8}
}

%% 1967

% https://www.ub.uio.no/english/subjects/naturalscience-technology/informatics/themes/dns/index.html
% Making it a booklet, but maybe it's a techreport?
% Re-printed as chapter in 2002 "Software Pioneers: Contributions to Software Engineering"
@Booklet{Simula1967,
  author = {Dahl, Ole-Johan and Nygaard, Kristen},
  title = {Class and subclass declarations},
  year = {1967},
  url = {https://www.ub.uio.no/fag/naturvitenskap-teknologi/informatikk/faglig/dns/dokumenter/classandsubclass1967.pdf},
  note={.
    THE breakthrough paper that leads to OO,
    though we can debate whether it is itself OO as such;
    not in the modern form made popular by Smalltalk, at least.
    Dahl and Nygaard implement classes for the first time.
    They do not have the word “inheritance”, but the concept is there somehow.
    A class may have a “prefix class” and “subclasses” of which it is the prefix class.
    Its ancestry is its “prefix sequence”, weirdly kept in most- to least- specific order.
    The keyword “this” is introduced that C++ will popularize.
    Because a prefix class may also include suffix code,
    the “body” for subclasses can be “split” with the keyword “inner”
    that pinpoints where to put the body of subclasses (by default, at the end).
    The successor BETA will also follow this approach.
    As in Hoare 1965, “objects” have “attributes”.
  }
}

% Introduces the notion of "Ad hoc polymorphism"
@Misc{Strachey67,
  Author = {Christopher Strachey},
  Title = {Fundamental Concepts in Programming Languages},
  Year = {1967},
  url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.332.3161},
}

%% 1968

% More condensed than the above, with more language context
@Misc{Simula1968,
  Author = {Ole-Johan Dahl and Bjørn Myhrhaug and Kristen Nygaard},
  Title = {SIMULA 67 Common Base Language},
  Year = {1968},
  url = {https://web.archive.org/web/20131225084408/http://www.edelweb.fr/Simula/scb-1.pdf}
}

%% 1972

@InCollection{dahl1972chapter,
  title={Chapter III: Hierarchical program structures},
  author={Dahl, Ole-Johan and Hoare, Charles Antony Richard},
  booktitle={Structured programming},
  pages={175--220},
  year={1972},
  notes={.
    The paper identifies a class with a procedure that computes an algorithm,
    constructs a record, and yields current values multiple times
    to other activities with "detach" (call again for next).
    Section 6 has "concatenation" for single inheritance.
  }
}

@Article{Parnas1972,
  author = {Parnas, D. L.},
  title = {On the Criteria to Be Used in Decomposing Systems into Modules},
  year = {1972},
  issue_date = {Dec. 1972},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {15},
  number = {12},
  issn = {0001-0782},
  url = {https://doi.org/10.1145/361598.361623},
  doi = {10.1145/361598.361623},
  abstract = {This paper discusses modularization as a mechanism for improving the flexibility and comprehensibility of a system while allowing the shortening of its development time. The effectiveness of a “modularization” is dependent upon the criteria used in dividing the system into modules. A system design problem is presented and both a conventional and unconventional decomposition are described. It is shown that the unconventional decompositions have distinct advantages for the goals outlined. The criteria used in arriving at the decompositions are discussed. The unconventional decomposition, if implemented with the conventional assumption that a module consists of one or more subroutines, will be less efficient in most cases. An alternative approach to implementation which does not have this effect is sketched.},
  journal = {Commun. ACM},
  month = {dec},
  pages = {1053--1058},
  numpages = {6},
  keywords = {modules, software, KWIC index, modularity, software engineering, software design}
}

%% 1973

% XXX TODO
% Hewitt, Bishop, Greif, Smith, Matson, Steiger
% Actor Induction and Meta-evaluation
% POPL
% 1973

%% 1974

@TechReport{minsky1974framework,
  title={A Framework for Representing Knowledge},
  author={Minsky, Marvin},
  year={1974},
  institution={MIT},
  number={AIM-306},
  url={https://dspace.mit.edu/handle/1721.1/6089},
  note={.
    Minsky uses the words “prototype” and “inherit”, but incidentally,
    NOT AT ALL to refer to the concepts at stake.
  }
}

%% 1975

% TODO 1975 Hewitt Stereotypes -- uses the word "inherit" a lot, especially with frames.
% p.101 “The "frame" problem of McCarthy for assertional frames corresponds closely to
% the problems of "inheritance of attributes" and "default values" for object frames.
% For example the fable quoted by Minsky about the wolf and the lamb is very close to
% the frame problems of McCarthy.”
% Bibliography includes by McCarthy "Programs with Common Sense" (1958),
% and "Some philosophical problems from the standpoint of Artificial Intelligence" (1969),
% neither of which has it, and by Minksy "A Framework for Representing Knowledge",
% that discusses “"default" assignments” and discusses how the wolf is lying in accusing the lamb
% and the issues with representing knowledge for that.


% https://web.archive.org/web/20200511083536/https://hci.stanford.edu/winograd/papers/FrameRep.pdf
@InCollection{Winograd1975,
  author = {Terry Winograd},
  title = {Frame Representations and the Declarative/Procedural Controversy},
  editor = {Daniel G. Bobrow and Allan Collins},
  booktitle = {Representation and Understanding},
  publisher = {Morgan Kaufmann},
  address = {San Diego},
  pages = {185-210},
  year = {1975},
  isbn = {978-0-12-108550-6},
  doi = {10.1016/B978-0-12-108550-6.50012-4},
  url = {https://www.sciencedirect.com/science/article/pii/B9780121085506500124},
  abstract = {Publisher Summary
This chapter presents some criteria for evaluating ideas for representation. It also presents a rough sketch of a particular version of a frame representation, and discusses the ways in which it can deal with the issues raised. The proceduralists assert that human knowledge is primarily a knowing how. The human information processor is a stored program device, with its knowledge of the world embedded in the programs. The declarativists do not believe that knowledge of a subject is intimately bound with the procedures for its use. They see intelligence as resting on two bases: a quite general set of procedures for manipulating facts of all sorts, and a set of specific facts describing particular knowledge domains. In thinking, the general procedures are applied to the domain-specific data to make deductions. Often this process has been based on the model of axiomatic mathematics. The facts are axioms and the thought process involves proof procedures for drawing conclusions from them.},
  note={.
    This paper has so far as I can tell
    the earliest use of “inheritance” in a context that directly applicable to OO.
    Winograd also inspired Kahn and Borning for their Prototype OO systems,
    and worked with Bobrow whose team was next to Kay’s, etc.
    The word “inherit” does appears in other papers from MIT AI researchers at the time (e.g. Hewitt),
    but it is unclear who talks about it first and gets it from where.
    Winograd talks about “inheritance of properties”, p. 197.,
    to compute properties of a frame based on its hierarchy.
    Frame hierarchies are a form of multiple inheritance, though that word isn’t coined.
    The exact resolution algorithm is not explained.
    Frames are not quite data, not quite code,
    but something in between, “knowledge representation”;
    Lisp, being a system more than a programming language, blurs the lines.
    The use of the word “inheritance” is not fully formal, though.
    Indeed, I can see at least four kinds of ways of naming things
    (beware though I’m making up this nomenclature on the spot):
    (1) evocation: neither name nor concept owns the other, yet an allusion is made;
    (2) distinction: the name distinguishes the concept from others, but isn't owned by it;
    (3) identification: name and concept own each other, though the limits of the concept
    may not be clear;
    (4) definition: the essence of the concept being named is finally well understood.
    For “inheritance”, evocation may have happened in Minsky 1974, distinction in Winograd 1975,
    and identification around 1976 quite possibly by Bobrow or Kay
    (and Kay later says Larry Tesler insisted on implementing “slot inheritance”
    the way he had done in previous desktop publishing projects).
    Informal practical definition would happen in the early 1980s, and
    more formal theoretical definitions around 1990 with e.g. Cook & Bracha,
    refining their immediate predecessors like Kamin, Reddy, Cook.
}}

% https://link.springer.com/chapter/10.1007/3-540-07168-7_77
% We take the following statements to be the objectives of modular programming:
% 1. One must be able to convince himself of the correctness of a program module,
% independently of the context of its use in building larger units of software.
% 2. One must be able to conveniently put together program modules written under
% different authorities without knowledge of their inner workings.
% InBook
@Misc{Dennis1975,
  author="Dennis, Jack B.",
  editor="Bauer, F. L.
  and Dennis, J. B.
  and Waite, W. M.
  and Gotlieb, C. C.
  and Graham, R. M.
  and Griffiths, M.
  and Helms, H. J.
  and Morton, B.
  and Poole, P. C.
  and Tsichritzis, D.",
  title="Modularity",
  bookTitle="Software Engineering: An Advanced Course",
  year="1975",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="128--182",
  isbn="978-3-540-37502-9",
  doi="10.1007/3-540-07168-7_77",
  url="https://doi.org/10.1007/3-540-07168-7_77"
}

% AITR-346.ps
% Uses the word prototypes and objects in a suggestive but informal way.
% The knowledge representation is a decision tree in a 3kloc LISP program
% with over a thousand COND.
% There is some notion of hierarchy and overriding/extending descriptive features,
% but not obviously one of fixed-point or self-reference; at least not discussed.
@article{hollerbach1975hierarchical,
  title={Hierarchical shape description of objects by selection and modification of prototypes},
  author={Hollerbach, John M},
  year={1975},
  url={https://dspace.mit.edu/handle/1721.1/6897}
}

@InProceedings{DeRemerKron1975,
  author = {DeRemer, Frank and Kron, Hans},
  title = {Programming-in-the Large versus Programming-in-the-Small},
  year = {1975},
  isbn = {9781450373852},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/800027.808431},
  doi = {10.1145/800027.808431},
  abstract = {We distinguish the activity of writing large programs from that of writing small ones. By large programs we mean systems consisting of many small programs (modules), possibly written by different people.We need languages for programming-in-the-small, i.e. languages not unlike the common programming languages of today, for writing modules. We also need a “module interconnection language” for knitting those modules together into an integrated whole and for providing an overview that formally records the intent of the programmer(s) and that can be checked for consistency by a compiler.We explore the software reliability aspects of such an interconnection language. Emphasis is placed on facilities for information hiding and for defining layers of virtual machines.},
  booktitle = {Proceedings of the International Conference on Reliable Software},
  pages = {114–121},
  numpages = {8},
  keywords = {Module interconnection language, Accessibility, Visibility, Protection, Linking, Scope of definition, Virtual machine, Project management tool., Information hiding, External name, System hierarchy},
  location = {Los Angeles, California}
}

%% 1976

% Unnamed language inspired by Hewitt's actors (PLASMA) and Smalltalk-72.
% Prototype-based ("objects" reply to "messages", "prototype" not used),
% that have "parents" or "children" (single inheritance is described; "inheritance of properties" is used)
% There are "classes" that handle otherwise unhandled messages, but the relationship between
% classes and parents is not explained -- are they the same hierarchy? a separate one?
% Are the child/parent and class/instance relationships the same or different?
@InProceedings{Kahn1976,
  author = {Kahn, Kenneth Michael},
  title = {An Actor-Based Computer Animation Language},
  year = {1976},
  isbn = {9781450377898},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/1024273.1024278},
  abstract = {This paper describes a computer language based upon actor semantics designed especially for computer graphics and animation. The thesis that animation is best facilitated by considering each entity on the display screen as an independent process is discussed and demonstrated by examples. The system is built upon MacLisp and is compatible with Lisp-Logo. The language is designed to be used by both very sophisticated programmers and by school children.},
  booktitle = {Proceedings of the ACM/SIGGRAPH Workshop on User-Oriented Design of Interactive Graphics Systems},
  pages = {37–43},
  numpages = {7},
  location = {Pittsburgh, PA},
  series = {UODIGS '76},
  url = {https://dspace.mit.edu/handle/1721.1/41950}
}

% Also published in Cognitive Science, V. 1, No. 1, 1977.
@TechReport{Bobrow1976,
  author={Daniel G. Bobrow and Terry Winograd},
  title={An Overview of KRL, A Knowledge Representation Language},
  year={1976},
  institution={Stanford Artificial Intelligence Laboratory},
  number={AIM-293},
  url={https://exhibits.stanford.edu/stanford-pubs/catalog/pf235fy3176},
  note={.
    This paper has multiple inheritance (without using the word) as multiple “descriptors”
    each providing a “perspective” on a given “object” or “prototype”,
    and “inheritance of properties”,
    meant as a declarative system of data on which operations are then performed,
    rather than as code as such (though coding is possible).
  }
}

%% 1977

@TechReport{Stansfield1977COMEX,
  title={COMEX: A Support System for a Commodities Expert},
  author={Stansfield, James L},
  year={1977},
  institution={MIT},
  number={AIM-423},
  url={https://dspace.mit.edu/handle/1721.1/6281},
  note={.
    An early expert system for Commodities, written in Lisp,
    and organizing data in a knowledge base of frames.
    The paper is the earliest one to mention single and multiple inheritance, p.12 and p.13,
    about the frame representation of the COMEX data.
  }
}

% ThingLab https://github.com/cdglabs/thinglab
% Uses the word "prototypes", and has no classes. And multiple inheritance.
@InProceedings{Borning1977,
  author = {Alan Hamilton Borning},
  title = {{ThingLab} --- an Object-Oriented System for Building Simulations using Constraints},
  booktitle={5th International Conference on Artificial Intelligence},
  pages={497--498},
  month = {August},
  year = {1977},
  url = {https://www.ijcai.org/Proceedings/77-1/Papers/085.pdf}
}

%% 1978

% Starts with modularity principle
% Mentions multiple inheritance of traits, but does not explain too much
@inproceedings{Ingalls1978,
  author = {Ingalls, Daniel H. H.},
  title = {The Smalltalk-76 programming system design and implementation},
  year = {1978},
  isbn = {9781450373487},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/512760.512762},
  doi = {10.1145/512760.512762},
  abstract = {This paper describes a programming system based on the metaphor of communicating objects. Experience with a running system shows that this model provides flexibility, modularity and compactness. A compiled representation for the language is presented, along with an interpreter suitable for microcoding. The object-oriented model provides naturally efficient addressing; a corresponding virtual memory is described which offers dense utilization of resident space.},
  booktitle = {the 5th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
  pages = {9–16},
  numpages = {8},
  location = {Tucson, Arizona},
  series = {POPL '78}
}

%% 1979

@TechReport{Hewitt1979Security,
  title={Security and Modularity in Message Passing},
  author={Hewitt, Carl and Attardi, Giuseppe and Lieberman, Henry},
  year={1979},
  month=February,
  institution={MIT Artificial Intelligence Laboratory},
  number={AI-WP-180},
  url={https://dspace.mit.edu/handle/1721.1/41147},
  note={.
    16 years before Rees 1995, the authors use scoping as a security mechanism
    in their Actor system ACT1.
    They also implement both Prototype OO (“delegation”) and Class OO (“inheritance”).
    Prototypes “increas[e] the modularity of the system”;
    classes allow “sharing of descriptions common to many actors”.
    Actors have both When an actor delegates message handling to another,
    messages it does not handle itself result in a call to the other actor
    with a method “Buck_pass” that reifies the message and its context.
    Cites Simula, Smalltalk and Director (Kahn) “developed jointly with Kahn”.
  }
}

@PhDThesis{Borning1979,
  author = {Borning, Alan Hamilton},
  title = {{ThingLab} --- A Constraint-Oriented Simulation Laboratory},
  biburl = {https://www.bibsonomy.org/bibtex/263cae088243a5fd341d7d634d8176bb3/n770},
  publisher = {Palo Alto Research Center XEROX},
  url = {https://constraints.cs.washington.edu/ui/thinglab-tr.pdf},
  school = {Stanford University},
  year = 1979
}

@PhDThesis{Kahn1979Ani,
  title = {Creation of computer animation from story descriptions},
  author = {Kahn, Kenneth Michael},
  school = {MIT},
  year = {1979},
  url = {https://dspace.mit.edu/handle/1721.1/16012},
  note={.
    This paper is about the higher-level system Ani,
    that generates turtle graphics plans on top of
    the actor-based object system Director (see AIM-482b).
    While Ani is a constraint solver based on a knowledge representation of the film being directed:
    very crude 2d film with polygons as "performers" that move toward, away from,
    around or between each other, at various speeds appropriate for the action,
    as would humans on a stage.
    Kahn cites Bobrow & Winograd, as well as Kay, Hewitt, Lieberman,
    and many more (Licklider, Catmull!)
  }
}

@TechReport{Kahn1979Director,
  title = {Director Guide},
  author = {Kahn, Kenneth Michael},
  institution={MIT},
  number={AIM-482b},
  year = {1979},
  url = {https://dspace.mit.edu/handle/1721.1/6302},
  note={.
    This paper, revised from a previous 1978 edition,
    presents Director, the earliest Lisp OO system as such,
    where inheritance exists in the context of programming
    and not just knowledge representation from which it evolved (see Kahn 1976).
    Dirctor by then had been extracted from Kahn’s wider animation project built atop it.
    Director implements single inheritance by message passing on top of an Actor system.
    It has an early form of call-next-method called continue-asking (p.40).
    The Actor team would later adapt Kahn’s system, see Hewitt 1979.
    Kahn cites Smalltalk and Actors as an influence for Director,
    but not KRL (Kahn does cite KRL in other papers).
  }
}

% Borning1982 cites a 1980 version of the Flavors report, from MIT. Originally from 1979.
% p.9 Section "Flavors" - as distinguished from the previous class thing! - linearizes
@Misc{Cannon1979,
  title={Flavors: A Non-Hierarchical Approach to Object-Oriented Programming},
  author={Howard Cannon},
  publisher={Symbolics Inc.},
  year=1979,
  url={https://www.softwarepreservation.org/projects/LISP/MIT/nnnfla1-20040122.pdf},
  note={.
    Cannon’s groundbreaking work unexpectedly solved the problem of multiple inheritance,
    by harmoniously combining the methods in a way that generalizes Teitelman’s ADVISE facility.
    The paper is full of ideas and genius insights, even though it is obviously unpolished,
    and written by an inexperienced young man.
    Cannon’s software and his report were widely circulated at MIT and in the Lisp community,
    but unhappily the report was never officially published.
    The MIT Lisp Machine Manual from 1981 on (3rd edition and later) includes Flavors.
    The first academic publication on Flavors would be Moon 1986’s paper on New Flavors.
    An October 1980 CADR backup tape shows Flavors was implemented as a short 1428 line program.
    It has linearization by a two-pass depth-first search algorithm,
    where parents are called “components” that a flavor “depends-on”,
    but there are also other flavors it “includes” that go at the end to act as defaults,
    which by default includes at the end the system-defined vanilla-flavor.
    A mixin (or mix-in) is a flavor meant to be combined-in but not instantiated.
    The Flavors paper describes the Smalltalk  “hierarchical”; discusses the conflict view
    of multiple inheritance (from Borning, looking at his bibliography)
    as “a scheme called _multiple superclasses_”, and how it fails
    to support _modular_ interactions between orthogonal issues.
    and itself “non-hierarchical” by comparison, with flavors instead of superclasses, so
    “instead of a hierarchy, more of a lattice structure is formed”.
    While 20-year old Cannon’s underlying concepts and arguments show his genius,
    his incorrect wording shows his then lack of education:
    the DAG of ancestors (words he doesn’t use) is still a hierarchy
    (just a partial rather than total order), and not a lattice
    (which requires existence and unicity of least upper and least lower bounds).
    Finally, note that Flavors as such offers no call-next-method.
    The default method combination, :DAEMON, supports only one primary method,
    lots of wrappers (macros with :around powers),
    and side-effects from :before and :after methods to combine methods;
    but other method-combinations can combine things (:LIST :INVERSE-LIST :PROGN :AND :OR),
    and you could create your own method-combination that returns a function to compose.
  }
}

%% 1980

@inproceedings{Goldstein1980Extending,
  author = {Goldstein, Ira P. and Bobrow, Daniel G.},
  title = {Extending Object Oriented Programming in Smalltalk},
  year = {1980},
  isbn = {9781450373968},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/800087.802792},
  doi = {10.1145/800087.802792},
  abstract = {Smalltalk is an object oriented programming language with behavior invoked by passing messages between objects. Objects with similar behavior are grouped into classes. These classes form a hierarchy. When an object receives a message, the class or one of its superclasses provides the corresponding method to be executed. We have built an experimental Personal Information Environment (PIE) in Smalltalk that extends this paradigm in several ways. A PIE object, called a node, can have multiple perspectives, each of which provides independent specialized behaviors for the object as a whole, thus providing multiple inheritance for nodes. Nodes have metadescription to guide viewing of the objects during browsing, provide default values, constrain the values of attributes, and define procedures to be run when values are sought or set. All nodes have unique names which allow objects to migrate between users and machines. Finally attribute lookup for nodes is context sensitive, thereby allowing alternative descriptions to be created and manipulated.This paper first reviews Smalltalk, then discusses our implementation of each of the above capabilities within PIE, a Smalltalk system for representing and manipulating designs. We then describe our experience with PIE applied to software development and technical writing. Our conclusion is that the resulting hybrid is a viable offspring for exploring design problems.},
  booktitle = {Proceedings of the 1980 ACM Conference on LISP and Functional Programming},
  pages = {75–81},
  numpages = {7},
  location = {Stanford University, California, USA},
  series = {LFP '80}
}

%% 1981

% Chine Nual or chinual 3ed, 1981 has Flavors and defsystem. 1979 2ed doesn't.
% Stroustrup1989Multiple cites 3ed or 4ed (also 1981)
@manual{Weinreb1981Chinual3,
  author    = {Daniel Weinreb and David Moon},
  title     = {Lisp Machine Manual},
  edition   = {3rd},
  month     = {March},
  year      = {1981},
  publisher = {Massachusetts Institute of Technology},
  address   = {Cambridge, MA},
  url={http://bitsavers.org/pdf/mit/cadr/chinual_3rdEd_Mar81.pdf},
  note={.
     Also known as the “Chinual”, this legendary book explains the interface of the Lisp Machine,
     then commercialized under license by Symbolics, Inc., the first .com.
     Chapter 20 presents Flavors, its concepts and its API,
     but does not include all the rationale from the Flavors paper.
   }
}

% http://worrydream.com/refs/Borning%20-%20The%20Programming%20Language%20Aspects%20of%20ThingLab.pdf
% https://dl.acm.org/doi/abs/10.1145/357146.357147
@Article{Borning1981,
  author = {Borning, Alan Hamilton},
  title = {The Programming Language Aspects of ThingLab, a Constraint-Oriented Simulation Laboratory},
  year = {1981},
  issue_date = {Oct. 1981},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {3},
  number = {4},
  issn = {0164-0925},
  url = {https://doi.org/10.1145/357146.357147},
  doi = {10.1145/357146.357147},
  journal = {ACM Trans. Program. Lang. Syst.},
  month = oct,
  pages = {353--387},
  numpages = {35},
  note={.
    ThingLab is an extension to Smalltalk that supports Prototype OO,
    and integrates it with the Class OO of Smalltalk.
    On top of that, Borning builds a constraint-based graphic system
    that generalizes Sketchpad, and can be used to build simulations.
    ThingLab also implements multiple inheritance, although
    the flavorless conflict kind (ThingLab predates Flavors).
  }
}

%% 1982

% Yale T Scheme. Introduces functional syntax for object method invocation.
% Norman I. Adams, IV -- but the IV doesn't get processed correctly
% Can't find it on http://mumble.net/~jar/tproject/
% See also Olin Shivers' "A History of T" https://paulgraham.com/thist.html
@InProceedings{Rees1982T,
  author = {Jonathan A. Rees and Norman I. Adams},
  title = {T: a dialect of LISP or, Lambda: the ultimate software tool},
  booktitle = {Symposium on Lisp and Functional Programming, ACM},
  pages = {114--122},
  year = {1982},
  url = {https://www.researchgate.net/publication/221252249_T_a_dialect_of_Lisp_or_LAMBDA_The_ultimate_software_tool}
}

% Introduces "traits", for multiple inheritance in the Mesa programming language
% used to implement WS, the workstation software of the Xerox Star 8010,
% since late 1979 (Mesa started early 1978 with Single-Inheritance).
% p.6 conflict resolution is manual.
@article{Traits,
  author = {Curry, Gael and Baer, Larry and Lipkie, Daniel and Lee, Bruce},
  title = {Traits: An approach to multiple-inheritance subclassing},
  year = {1982},
  issue_date = {June 21-23, 1982},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {3},
  number = {1–2},
  issn = {0737-819X},
  url = {https://doi.org/10.1145/966873.806468},
  doi = {10.1145/966873.806468},
  abstract = {This paper describes a new technique for organizing software which has been used successfully by the Xerox Star 8010 workstation. The workstation (WS) software is written in an “object-oriented” style: it can be viewed as a system of inter-communicating objects of different object types. Most of the WS software considers object types to be constructed by assembling more primitive abstractions called traits. A trait is a characteristic of an object, and is expressed as a set of operations which may be applied to objects carrying that trait. The traits model of subclassing generalizes the SIMULA-67 model by permitting multiple inheritance paths. This paper describes the relationship of WS software to the traits model and then describes the model itself.},
  journal = {ACM SIGOA Newsletter},
  month = {jun},
  pages = {1--9},
  numpages = {9}
}

% Successor to a 1980 experiment by Borning. No method combination. Unclear linearization. Low on details.
% Uses the Link class from SIMULA, and ReadWriteStream as motivations for multiple inheritance.
% ThingLab 1981 has multiple inheritance (already in 1977),
% and so have PIE (Goldstein&Bobrow 1980), Flavors 1980, LOOPS 1982.
% Traits from Mesa since 1979 [Curry 1982]
% Conflict resolution is by erroring if inheriting more than one method without an explicit override
@InProceedings{Borning1982Multiple,
  title={Multiple inheritance in Smalltalk-80},
  author={Borning, Alan H and Ingalls, Daniel HH},
  booktitle={Proceedings at the National Conference on AI},
  volume={82},
  pages={234--237},
  year={1982},
  url={http://www.laputan.org/pub/papers/MI-Borning-Ingalls.PDF}
}

%% 1983


@article{Novak1983GLISP,
  author = {Novak, Gordon S.},
  title = {Data abstraction in GLISP},
  year = {1983},
  issue_date = {June 1983},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {18},
  number = {6},
  issn = {0362-1340},
  url = {https://doi.org/10.1145/872728.806863},
  doi = {10.1145/872728.806863},
  abstract = {GLISP is a high-level language that is based on Lisp and is compiled into Lisp. It provides a versatile abstract-data-type facility with hierarchical inheritance of properties and object-centered programming. The object code produced by GLISP is optimized, so that it is about as efficient as handwritten Lisp. An integrated programming environment is provided, including editors for programs and data-type descriptions, interpretive programming features, and a display-based inspector/editor for data. GLISP is fully implemented.},
  journal = {SIGPLAN Not.},
  month = jun,
  pages = {170–177},
  numpages = {8},
  note={.
    Earliest find of “single inheritance” by Google Scholar... when describing Smalltalk as having a
    “single inheritance hierarchy” (i.e. only one “inheritance hierarchy”).
    GLISP is an impressive Lisp dialect with a compiler to Lisp implemented in Lisp
    (ported to Interlisp, Maclisp, Franz Lisp, UCI Lisp, Elisp, Portable Standard Lisp),
    with type inference, and a message-passing object system with multiple inheritance;
    “responses” to messages can be function calls, but also inlined function calls,
    or outright macro-expansion. Objects can be virtual, expanded away at compile-time
    (e.g. for a view that changes coordinates in another object). An object editor
    that works both on graphical Xerox D machines and text terminals is implemented in GLISP.
  }
}

% Has metaclasses, multiple inheritance.
% Still ugly syntax, with INTERLISP-style very short uppercase identifiers.
@book{Bobrow1983Loops,
  title={The LOOPS manual},
  author={Bobrow, Daniel Gureasko and Stefik, Mark},
  volume={10},
  year={1983},
  publisher={Xerox Corporation Palo Alto, CA},
  note={.
    LOOPS has multiple inheritance. The authors cite the right Flavors passage on
    _modular_ interactions between orthogonal issues. But instead of linearization,
    they instead offer tools for methods to manually call methods from one or all
    parents, or from a named ancestor. On the other hand, LOOPS also includes
    a rich slot access protocol, a metaclass protocol, and a knowledge base with
    a rule-oriented programming engine.
    Interestingly, the paper has a mix of UPPERCASE primitives,
    CamelCase functions and objects and classes, camelCase variables.
  }
}

%% 1984

% After discussing multiple inheritance informally, omits it completely from the formal treatment,
% but does introduce a framework for subtyping of a lambda-calculus with records and fixed-points.
@InProceedings{Cardelli1984ASO,
  title={A Semantics of Multiple Inheritance},
  author={Luca Cardelli},
  booktitle={Information and Computation},
  year={1984},
  volume={76},
  number={2},
  pages={138-164},
  year={1988},
  issn={0890-5401},
  doi={10.1016/0890-5401(88)90007-7},
  url={http://lucacardelli.name/papers/inheritance.pdf}
}

%% 1986

% Wegner & Cardelli have plenty of good concepts,
% including universal and existential quantification...
% and then in section 6.1 they fall squarely into NNOOTT,
% explicitly confusing inheritance and subtyping.
% They also cite Smalltalk and Flavors in 6.3, just to immediately drop the ball.
% Beyond lame.
@book{cardelli1986understanding,
  title={On understanding types, data abstraction, and polymorphism},
  author={Cardelli, Luca and Wegner, Peter},
  year={1986},
  publisher={Brown University. Department of Computer Science},
  url={http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf}
}

% url={https://homepages.cwi.nl/~storm/teaching/reader/Lieberman86.pdf}
@InProceedings{Lieberman1986,
  title={Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems},
  author={Henry Lieberman},
  booktitle={OOPLSA},
  pages={214--223},
  year={1986},
  url={https://web.media.mit.edu/~lieber/Lieberary/OOP/Delegation/Delegation.html}
}

@InProceedings{Borning1986,
  title={Classes Versus Prototypes in Object-Oriented Languages},
  author={Alan Hamilton Borning},
  booktitle={1986 Fall Joint Computer Conference},
  pages={36--40},
  year={1986},
  doi={10.5555/324493.324538},
}

@article{Moon1986Flavors,
  author = {Moon, David A.},
  title = {Object-Oriented Programming with Flavors},
  year = {1986},
  issue_date = {Nov. 1986},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {21},
  number = {11},
  issn = {0362-1340},
  doi = {10.1145/960112.28698},
  abstract = {This paper describes Symbolics' newly redesigned object-oriented programming system, Flavors. Flavors encourages program modularity, eases the development of large, complex programs, and provides high efficiency at run time. Flavors is integrated into Lisp and the Symbolics program development environment. This paper describes the philosophy and some of the major characteristics of Symbolics' Flavors and shows how the above goals are addressed. Full details of Flavors are left to the programmers' manual, Reference Guide to Symbolics Common Lisp. (5)},
  journal = {SIGPLAN Not.},
  month = jun,
  pages = {1--8},
  numpages = {8},
  notes={.
    According to Gabriel 2012, this was the first academic publication about Flavors,
    outside of Cannon’s 1979 report (this paper cites a 1982 copy), that was not seen
    outside MIT and other Lisp circles (however, the Lisp Machine Manual from 1981 on
    includes a chapter on Flavors). This paper describes the New Flavors system from
    Symbolics, after it acquired the new “generic function” syntax, respect for
    local precedence order, and other niceties. Moon rightfully insists on the modularity
    advantage of Flavors (already mentions by Cannon). This is a fantastic explanation
    on how to do multiple inheritance right, only way too short.
  }
}

% Almost modern syntax, lower case long(ish) identifiers.
@InProceedings{Bobrow1986CommonLoops,
  title={CommonLoops: Merging Lisp and Object-Oriented Programming},
  author={Daniel G. Bobrow and Kenneth Kahn and Gregor Kiczales and Larry Masinter and Mark Stefik and Frank Zdybel},
  booktitle={OOPSLA},
  issue_date = {Nov. 1986},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {21},
  number = {11},
  issn = {0362-1340},
  doi = {10.1145/960112.28700},
  journal = {SIGPLAN Not.},
  month = jun,
  pages = {17–29},
  numpages = {13},
  year={1986},
  doi={10.1145/28697.28700},
  note={.
    Excellent paper.
    This reprint of a 1985 report presents CommonLoops, an evolution from LOOPS
    that integrates lessons from New Flavors, from which it takes linearization and generic functions,
    that it extends to support multimethods. As in LOOPS, there are metaclasses
    (that control single or multiple inheritance, slot accessors).
    It has a form of call-next-method named run-super.
    Method calls are compiled with various optimizations including local and global method caches.
    Introduces class variables, init-forms in slot descriptions
    instead of access-time default values as in LOOPS, slot properties,
    “active values” (kind of method combination for slot accessors?).
    More nice design discussions and comparisons.
    Symbols are all lowercase.
  }
}

% NB: Much updated 1987 version at https://archive.org/details/researchdirectio00shri/page/164/mode/2up
@InProceedings{Snyder1986Encapsulation,
  author = {Snyder, Alan},
  title = {Encapsulation and Inheritance in Object-Oriented Programming Languages},
  year = {1986},
  isbn = {0897912047},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/28697.28702},
  doi = {10.1145/28697.28702},
  abstract = {Object-oriented programming is a practical and useful programming methodology that encourages modular design and software reuse. Most object-oriented programming languages support data abstraction by preventing an object from being manipulated except via its defined external operations. In most languages, however, the introduction of inheritance severely compromises the benefits of this encapsulation. Furthermore, the use of inheritance itself is globally visible in most languages, so that changes to the inheritance hierarchy cannot be made safely. This paper examines the relationship between inheritance and encapsulation and develops requirements for full support of encapsulation with inheritance.},
  booktitle = {Conference Proceedings on Object-Oriented Programming Systems, Languages and Applications},
  pages = {38--45},
  numpages = {8},
  location = {Portland, Oregon, USA},
  series = {OOPSLA '86},
  notes={.
    This very well-informed, very interesting paper, and its extended version in
    Research Directions in Object-Oriented Programming (1987),
    gets a whole lot right about inheritance, yet enough crucially wrong.
    It brilliantly introduces parent, ancestor, child, descendant, instead of the
    awkward direct-superclass, superclass, direct-subclass, subclass.
    He identifies the importance of modularity, but instead of that word,
    somehow divides it in two separate properties “encapsulation” and “data abstraction”.
    He notes the need for reflection to defeat this encapsulation for debugging purposes.
    He has good discussions of inheritance, visibility, subtyping, etc.
    But multiple inheritance is a topic where he majorly fails, despite Snyder’s erudition.
    He calls “graph oriented solutions” the conflict view of multiple inheritance,
    and identifies many problems with it.
    He calls “linear solutions” the Flavors and CommonLOOPS view,
    and regrets lack of conflict where he expects one, then regrets lack of communication
    with “real” parents (but… that’s what defining more methods is for),
    for which he wishes for the “graph oriented solutions” ability
    to directly call another method (which is a terrible idea and as he saw didn’t work),
    and finally worries about name clashes (yes, but that’s not specific to “linear solutions”).
    Dissatisfied for wrong reasons, and not having any theory of what OO should and why,
    he invents his own “tree solutions” for his system CommonObjects,
    trying to wish his simple Tree to solve a problem
    that obviously requires a DAG, admitting his solution
    “radically changes the semantics of inheritance” and that
    “[f]urther experimentation is needed to determine the practicality of
    this alternative programming style”.
    In other words, he has no clue what he’s doing, try something random because
    it is simple and convenient to him, and hoping that “solution” will stick.
    But note that “solution” to stick would mean that his predecessors
    have completely misidentified the problem, yet for reasons he cannot explain,
    since he is lacking a theory. That's, well, not respectful of them and himself.
    Next time, don't kick down that Chesterton fence.
    Now what does it tell us that Stroustrup 1989 came up with sensibly
    the same solution for C++, just with less research behind it?
  }
}

%% 1987

% TODO: re-read it. Some overly formal bits.
% Starts by citing Lieberman 1986. Only single inheritance.
% focuses on storage for variables and methods
% 2.1 "Inheritance schemes involve two kinds of objects: classes and instances" - Yikes

@article{stein1987delegation,
  title={Delegation is Inheritance},
  author={Stein, Lynn Andrea},
  journal={ACM SIGPLAN Notices},
  volume={22},
  number={12},
  pages={138--146},
  year={1987},
  publisher={ACM New York, NY, USA}
}

% https://beta.cs.au.dk/ ?
@article{kristensen1987beta,
  title={The BETA programming language},
  author={Kristensen, Bent Bruun and Madsen, Ole Lehrmann and Møller-Pedersen, Birger and Nygaard, Kristen},
  journal={DAIMI Report Series},
  number={229},
  year={1987},
  url={https://www.semanticscholar.org/paper/The-BETA-Programming-Language-Kristensen-Madsen/3971897f708518e13809d3c0772105bd86526e50}
}


%% 1988

% Specification of function behavior, similar to later CLHS
% https://www.researchgate.net/publication/220178512_Common_Lisp_Object_System_Specification_X2JI3_Document_88-002R
@Article{Bobrow88CLOS,
  title={Common Lisp Object Specification X3J13},
  author={D. G. Bobrow and L. D. DeMichiel and R. P. Gabriel and S. E. Kleene and G. Kiczales and D. A. Moon},
  journal={SIGPLAN Notices 23 (Special Issue)},
  year={1988},
  doi={10.1007/bf01806962},
  url={https://link.springer.com/content/pdf/10.1007/bf01806962.pdf}
}

@InProceedings{Kamin1988,
  title={Inheritance in Smalltalk-80: A Denotational Definition},
  author={Samuel N. Kamin},
  %booktitle={POPL '88},
  booktitle={POPL},
  year={1988},
  doi={10.1145/73560.73567},
  %url={https://dl.acm.org/doi/10.1145/73560.73567}
}

% https://core.ac.uk/download/pdf/42828491.pdf
@InProceedings{ObjectsAsClosures,
  author = {Reddy, Uday},
  title = {Objects as Closures - Abstract Semantics of Object Oriented Languages},
  %booktitle = {ACM Symposium on LISP and Functional Programming},
  booktitle = {LFP},
  %month = {02},
  pages = {289–-297},
  doi = {10.1145/62678.62721},
  year = {1988},
}

% First entry (alphabetically by name?) in ltuo
@InProceedings{adams88oopscheme,
  Author = {Norman Adams and Jonathan Rees},
  Title = {Object-Oriented Programming in Scheme},
  url = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.954",
  booktitle = {Proceedings of the 1988 ACM Conference on LISP and Functional Programming},
  pages = {277--288},
  Year = {1988},
  note={.
    This paper expounds the object system of Yale T Scheme, actually implemented circa 1982,
    and notably used for its GUI:
    class-less, object-less (what they call “object” is any value),
    it is a sort of Prototype OO, but without conflation of targets (that they call instances)
    and specifications (that they call components).
    Their virtual machine merges instances and functions:
    an instance is a function with multiple entry points (one per method)
    including a default one, used when just calling it as a function.
    A function stricto sensu is an object with a single method.
    T instances as such implement single-inheritance, through
    a rudimentary protocol of delegation;
    however “components” provide mixin inheritance (before the name was invented).
    Impressive, but sadly largely unknown outside Lisp circles.},
  isbn = {089791273X},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/62678.62720},
  abstract = {We describe a small set of additions to Scheme to support object-oriented programming, including a form of multiple inheritance. The extensions proposed are in keeping with the spirit of the Scheme language and consequently differ from Lisp-based object systems such as Flavors and the Common Lisp Object System. Our extensions mesh neatly with the underlying Scheme system. We motivate our design with examples, and then describe implementation techniques that yields efficiency comparable to dynamic object-oriented language implementations considered to be high performance. The complete design has an almost-portable implementation, and the core of this design comprises the object system used in T, a dialect of Scheme. The applicative bias of our approach is unusual in object-oriented programming systems.},
  numpages = {12},
  location = {Snowbird, Utah, USA},
  series = {LFP '88}
}

@book{cct1988,
  author = {Rydeheard, David E. and Burstall, Rod M.},
  title = {Computational category theory},
  year = {1988},
  ISBN = {0131627368},
  doi={10.5555/49340},
  publisher = {Prentice Hall International (UK) Ltd.},
  url = {https://www.cs.man.ac.uk/~david/categories/book/book.pdf}
}

% Extended version of previous paper at POPL'85 https://dl.acm.org/doi/10.1145/318593.318606
@article{mitchell1988abstract,
  title={Abstract Types have Existential Type},
  author={Mitchell, John C and Plotkin, Gordon D},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={10},
  number={3},
  pages={470--502},
  year={1988},
  publisher={ACM New York, NY, USA},
  doi={10.1145/44501.45065}
}

% Introduces abstract classes and concrete classes, according to Grok
% https://www.cse.msu.edu/~cse870/Input/SS2002/MiniProject/Sources/DRC.pdf
@article{johnson1988designing,
  title={Designing reusable classes},
  author={Johnson, Ralph E and Foote, Brian},
  journal={Journal of object-oriented programming},
  volume={1},
  number={2},
  pages={22--35},
  year={1988},
  url={http://laputan.org/drc/drc.html}
}

%% 1989

% Unless a base class is "virtual", multiple copies are inherited.
% Conflict resolution is manual; you can explicitly call a superclass method,
% but there is no linearization mechanism to preserve method linearity
% in case of "ambiguities" (paper does not say "diamonds")
@article{Stroustrup1989Multiple,
  title={Multiple inheritance for C++},
  author={Stroustrup, Bjarne},
  journal={Computing Systems},
  volume={2},
  number={4},
  pages={367--395},
  year={1989},
  url={https://www.usenix.org/legacy/publications/compsystems/1989/fall_stroustrup.pdf}
}

% Authors of EuLisp don't like multiple inheritance, want mixin inheritance
@book{bretthauer1989multiple,
  title={Multiple Vs. Single Inheritance in Object-oriented Programming Languages: What Do We Really Want?},
  author={Bretthauer, Harry and Christaller, Thomas and Kopp, J{\"u}rgen},
  year={1989},
  publisher={Gesellschaft f{\"u}r Mathematik und Datenverarbeitung mbH}
}

% Cook2012 cites his own thesis in arguing that Inheritance is neither necessary nor specific to OO.
% Has wrappers already, but not mixin inheritance.
% 2.5 "Multiple inheritance" - the synthesized attribute view
% 2.5.1 "Strict M I" - "conflicting symbols are removed"
% 10. Flavors. Doesn't get it. at. all. (cites New Flavors Moon1986)
% - "linearization is potentially detrimental to the encapsulation of programs"
% 10.2 "tree" 10.3 "ancestor tree" - fails to see DAG
% 10.4 "very difficult to understand" - yup he fails
@PhDThesis{Cook1989,
    author = {William R. Cook},
    title = {A Denotational Semantics of Inheritance},
    school = {Brown University},
    year = {1989},
    url = {https://www.cs.utexas.edu/~wcook/papers/thesis/cook89.pdf}
}

% POPL, short reprise of what's in his thesis
% Also single-inheritance, records only
@Article{Cook1989Denotational,
  title={A Denotational Semantics of Inheritance and its Correctness},
  author={Cook, William and Palsberg, Jens},
  journal={ACM Sigplan Notices},
  volume={24},
  number={10},
  pages={433--443},
  year={1989},
  publisher={ACM New York, NY, USA},
  doi={10.1145/74877.74922},
  url={https://web.cs.ucla.edu/~palsberg/paper/ic94.pdf}
}

% The right fixed-point semantics, actually for prototypes as well as classes!
% 2.2 claims to avoid the "subsumption" rule for record subtyping in Cardelli (allows more rows)
% but in later sections seem to implicitly rely on it (or else on some dynamic or deferred typing?)
% 3 uses specs and targets without saying it
% 4.1 Has class as object constructor, reflexively accessible from object as "self class" method,
% and then uses double Y to resolve both class and self prototypes,
% instead of having an explicit Lieberman-like construction of class as prototype.
% 4.2 seems to implicitly have a type dependency (what are F and G ib (5)?)
% url={https://dl.acm.org/doi/abs/10.1145/96709.96721}
% Cites Mitch Wand 1987, 1989, 1989... gotta go deeper
@InProceedings{cook1989inheritance,
  title={Inheritance is not subtyping},
  author={Cook, William R and Hill, Walter and Canning, Peter S},
  %booktitle={Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  booktitle={POPL},
  pages={125--135},
  year={1989},
  doi={10.1145/96709.96721}
}

@InProceedings{chambers1989efficient,
  author = {Chambers, C. and Ungar, D. and Lee, E.},
  title = {An Efficient Implementation of SELF a Dynamically-Typed Object-Oriented Language Based on Prototypes},
  year = {1989},
  isbn = {0897913337},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/74877.74884},
  doi = {10.1145/74877.74884},
  abstract = {We have developed and implemented techniques that double the performance of dynamically-typed object-oriented languages. Our SELF implementation runs twice as fast as the fastest Smalltalk implementation, despite SELF's lack of classes and explicit variables.To compensate for the absence of classes, our system uses implementation-level maps to transparently group objects cloned from the same prototype, providing data type information and eliminating the apparent space overhead for prototype-based systems. To compensate for dynamic typing, user-defined control structures, and the lack of explicit variables, our system dynamically compiles multiple versions of a source method, each customized according to its receiver's map. Within each version the type of the receiver is fixed, and thus the compiler can statically bind and inline all messages sent to self. Message splitting and type prediction extract and preserve even more static type information, allowing the compiler to inline many other messages. Inlining dramatically improves performance and eliminates the need to hard-wire low-level methods such as +,==, and ifTrue:.Despite inlining and other optimizations, our system still supports interactive programming environments. The system traverses internal dependency lists to invalidate all compiled methods affected by a programming change. The debugger reconstructs inlined stack frames from compiler-generated debugging information, making inlining invisible to the SELF programmer.},
  booktitle = {OOPSLA},
  pages = {49–70},
  numpages = {22},
  location = {New Orleans, Louisiana, USA}
}

% Not obviously worth citing in this context?
@TechReport{Lawall89SelfInScheme,
  Author = {Julia L. Lawall and Daniel P. Friedman},
  Title = {Embedding the Self Language in Scheme},
  url = "https://legacy.cs.indiana.edu/ftp/techreports/TR276.pdf",
  Institution = {Computer Science Department, Indiana University},
  Year = {1989}
}

% Introduction of Typeclasses
% https://www.research.ed.ac.uk/en/publications/how-to-make-ad-hoc-polymorphism-less-ad-hoc
@InProceedings{typeclasses,
  title = "How to make ad-hoc polymorphism less ad hoc",
  abstract = "This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication, and generalise the {"}eqtype variables{"} of Standard ML. Type classes extend the Hindley/Milner polymorphic type system, and provide a new approach to issues that arise in object-oriented programming, bounded type quantification, and abstract data types. This paper provides an informal introduction to type classes, and defines them formally by means of type inference rules. ",
  author = "P. Wadler and S. Blott",
  year = "1989",
  doi = "10.1145/75277.75283",
  language = "English",
  isbn = "0-89791-294-2",
  pages = "60--76",
  %booktitle = "POPL '89 Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages",
  booktitle = "POPL",
  publisher = "ACM"
}

@TechReport{PCLSRing,
        Author={Alan Bawden},
	Title={{PCLSR}ing: {K}eeping {P}rocess {S}tate {M}odular},
	Institution={MIT},
	Year="1989",
	url={http://fare.tunes.org/tmp/emergent/pclsr.htm}
}

%% 1990

@book{cltl2,
  author = {Steele, Guy},
  title = {Common Lisp: The Language, 2nd edition},
  year = {1990},
  isbn = {0131515071},
  publisher = {Digital Press},
  address = {USA},
  doi = {10.5555/1098646},
  url = {http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/cltl2.html}
}

% https://www.semanticscholar.org/paper/Mixin-based-inheritance-Bracha-Cook/cbc4f2d93bb62d1c287f4fe458de6ac416379282
% url = {https://doi.org/10.1145/97945.97982},
@InProceedings{bracha1990mixin,
  author = {Gilad Bracha and William Cook},
  title = {Mixin-Based Inheritance},
  year = {1990},
  issue_date = {Oct. 1990},
  isbn = {0897914112},
  volume = {25},
  number = {10},
  issn = {0362-1340},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://bracha.org/oopsla90.pdf},
  doi = {10.1145/97945.97982},
  abstract = {The diverse inheritance mechanisms provided by Smalltalk, Beta, and CLOS are interpreted as different uses of a single underlying construct. Smalltalk and Beta differ primarily in the direction of class hierarchy growth. These inheritance mechanisms are subsumed in a new inheritance model based on composition of mixins, or abstract subclasses. This form of inheritance can also encode a CLOS multiple-inheritance hierarchy, although changes to the encoded hierarchy that would violate encapsulation are difficult. Practical application of mixin-based inheritance is illustrated in a sketch of an extension to Modula-3.},
  booktitle = {OOPLSA/ECOOP},
  pages = {303--311},
  numpages = {9},
  location = {Ottawa, Canada},
  journal = {SIGPLAN Not.},
  month = sep
}

%% 1991

@article{Moggi1991Monads,
  title={Notions of computation and monads},
  author={Moggi, Eugenio},
  journal={Information and computation},
  volume={93},
  number={1},
  pages={55--92},
  year={1991},
  publisher={Elsevier},
  doi={10.1016/0890-5401(91)90052-4}
}

% Studies λ-calculus with polymorphism, meets and joins, expresses naturals and others in it.
% Discusses the need for type annotations due to undecidable typechecking without.
% Does not discuss general fixpoints, though implicitly can deal with recursion for numbers.
% Fun, but not applicable to OO.
@article{pierce1991programming,
  title={Programming with intersection types, union types, and polymorphism},
  author={Pierce, Benjamin C},
  year={1991},
  publisher={Carnegie Mellon University}
}

% Introduces Recursion Schemes. Heavy on math notation.
% Kind of category theory
@inproceedings{bananas1991,
  author = {Meijer, Erik and Fokkinga, Maarten and Paterson, Ross},
  title = {Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire},
  year = {1991},
  isbn = {0387543961},
  publisher = {Springer-Verlag},
  address = {Berlin, Heidelberg},
  booktitle = {Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture},
  pages = {124–144},
  numpages = {21},
  location = {Cambridge, Massachusetts, USA},
  doi = {10.1007/3540543961_7},
  url = {https://research.utwente.nl/en/publications/functional-programming-with-bananas-lenses-envelopes-and-barbed-w/}
}

% Original DEFSYSTEM is a 1990 paper, but hard to find independently from the others.
@TechReport{kantrowitz1991,
  author =       {Mark Kantrowitz},
  title =        {Portable Utilities for {C}ommon {L}isp},
  institution =  {School of Computer Science, Carnegie-Mellon University},
  number =       {CMU-CS-91-143},
  year =         1991,
  month =        May,
  url =          {https://cl-pdx.com/static/CMU-CS-91-143.pdf}
}

@Article{gabriel1991clos,
  title={CLOS: Integrating Object-Oriented and Functional Programming},
  author={Gabriel, Richard P and White, Jon L and Bobrow, Daniel G},
  journal={Communications of the ACM},
  volume={34},
  number={9},
  pages={29--38},
  year={1991},
  publisher={ACM New York, NY, USA},
  url={https://www.researchgate.net/publication/220422719_CLOS_Integrating_Object-Oriented_and_Functional_Programming}
}

@Book{amop,
  Title={The {A}rt of the {M}eta-{O}bject {P}rotocol},
  Author={Kiczales, Gregor and Des Rivières, Jim and Bobrow, Daniel Gureasko},
  Year={1991},
  Publisher={MIT Press},
  url={https://direct.mit.edu/books/book/2607/The-Art-of-the-Metaobject-Protocol}
}

@InProceedings{Ungar91organizingprograms,
  Title = {Organizing Programs Without Classes},
  author = {David Ungar and Craig Chambers and Bay-Wei Chang and Urs Hölzle},
  journal = {Lisp and Symbolic Computation},
  year = {1991},
  pages = {223--242},
  publisher = {Kluwer Academic Publishers}
}

@TechReport{eppl91,
  Author={Matthias Felleisen},
  Title={On the Expressive Power of Programming Languages},
  Institution={Rice University},
  Year={1991},
  url={https://www.cs.rice.edu/CS/PLT/Publications/Scheme/}
}

% What a mess. https://x.com/xadh/status/1945251704011665663
% https://github.com/shriram/plai-public/issues/62
%
% "prioritized inheritance": superclasses are assigned priorities,
% and between "ordered" superclasses at different priorities, it's like linearization,
% but between "unordered" superclasses at same priority, it's ambiguousMessage error.
% Also, when invoking a method, remember not just the self but the invoking super,
% according to a "sender path tiebreaking rule" unique to SELF.
% so that further slot accesses follow the path (what about nested access, though?
% Reset at SELF? stack of previous super?)
% Also, dynamic inheritance: can dynamically add/remove slots and superclasses (at various priorities)
% call-next-method is called "resend" and can change method (unlike CLOS, to follow same path)
% and arguments but not self, and also specify the sending parent (one level of parent,
% must be superclass of current sending parent).
% No method combinations: cites CLOS, but wants "simplicity" for SELF.
% Mention rename in Eiffel as an alternative, static way to deal with unordered inheritance
% Notes that C++ linearizes superclasses for constructors and destructors, just not for regular methods
%
% Issues: SELF mixins must be parentless to avoid their general parents
% overriding the mixed class's specific slots. "Backtracking", i.e. lack of a stack of senders as above.
% "considering altering SELF's lookup rule to always search children before their ancestors"
% and be more like CLOS in this way.
% NB: In their "complexities" they note how their lack a clear story for resend with dynamic inheritance
% --- but then I'm not sure if CLOS specifies it, especially in presence of concurrency, so there.
% They also support cycles but say it's too complex to explain how in the paper.
%
@InProceedings{parentsSharedParts1991,
  title={Parents are Shared Parts of Objects: Inheritance and Encapsulation in SELF},
  author={Craig Chambers and David Ungar and Bay-Wei Chang and Urs Hölzle},
  booktitle={Lisp and Symbolic Computation},
  year={1991},
  url={https://bibliography.selflanguage.org/parents-shared-parts.html}
}

% HPL-91-50
% A possibly shortened version also published in *IEEE Software*, January 1993
% as "The Essence of Objects: Concepts and Terms"
@Misc{Snyder1991Essence,
  author = {Alan Snyder},
  title = {The Essence of Objects: Common Concepts and Terminology},
  year = {1991},
  abstract = {Core concepts in object-oriented technology are defined. The concepts are the basis for characterizing and contrasting various object-oriented technologies. The core concepts are: all objects embody an abstraction, objects provide services, clients issue requests, objects are encapsulated, requests identify operations, requests can identify objects, new objects can be created, operations can be generic, objects can be classified in terms of their services, objects can have a common implementation, and objects can share partial implementations. To address communication problems, a glossary of terms appropriate for the diverse set of domains in which object-oriented concepts are being applied is developed. The definitions are grouped into three sections in top-down order: terms related to abstraction, terms related to requesting services, and terms related to performing services.},
  month = june,
  numpages = {24},
  keywords = {abstraction, object-oriented programming, object-oriented technology, requests, services},
  url = {https://shiftleft.com/mirrors/www.hpl.hp.com/techreports/91/HPL-91-50.pdf},
  note={.
    Alan Snyder tries to introduce and name the common concepts in OO,
    in a way mindful of the variety of OO languages and systems,
    from C++ to CLOS to the Iris db and more.
    He insists on abstraction and encapsulation — features of what I would call "modularity",
    and only very quickly goes over inheritance, without details.
    Disappointing, but telling of how even pioneers only had a dim understanding of OO.
  }
}

@InProceedings{Cook1991PDAvsADT,
  author="Cook, William R.",
  editor="de Bakker, J. W.
  and de Roever, W. P.
  and Rozenberg, G.",
  title="Object-Oriented Programming versus Abstract Data Types",
  booktitle="Foundations of Object-Oriented Languages",
  year="1991",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="151--178",
  abstract="This tutorial collects and elaborates arguments for distinguishing between object-oriented programming and abstract data types. The basic distinction is that object-oriented programming achieves data abstraction by the use of procedural abstraction, while abstract data types depend upon type abstraction. Object-oriented programming and abstract data types can also be viewed as complimentary implementation techniques: objects are centered around the constructors of a data abstraction, while abstract data types are organized around the operations. These differences have consequences relating to extensibility, efficiency, typing, and verification; in many cases the strengths of one paradigm are the weaknesses of the other. Most object-oriented programming languages support aspects of both techniques, not a unification of them, so an understanding of their relative merits is useful in designing programs.",
  isbn="978-3-540-46450-1",
  doi="10.1007/BFb0019443",
  url={http://www.cs.utexas.edu/~wcook/papers/OOPvsADT/CookOOPvsADT90.pdf},
  note={.
    This article has a good historical overview of OO.
    Cook really understands modularity as a goal of OO but not extensibility;
    hence his not appreciating inheritance.
    He distinguishes Procedural Data Abstractions (PDA)
    organized around constructors (for classes, etc.) as in Smalltalk vs
    Abstract Data Types (ADT)
    organized around observations (pattern-matching for data types) as in CLU.
    In 5.1 he says Simula was precursor to both styles.
    Cook almost notices conflation:
    “a class definition is both a constructor of objects and a type”.
    And in 5.4 Cook is baffled by CLOS and its multimethods that break his model of PDA vs ADT.
  }
}

%% 1992

% According to Scholar.Google.com, this paper introduces "Open Recursion" in the context of CS,
% p.31,32, to describe how to extract a class and subclass from fixpoint of operator, after Cook89.
@book{cardelli1992extensible,
  title={Extensible records in a pure calculus of subtyping},
  author={Cardelli, Luca},
  year={1992},
  publisher={Digital. Systems Research Center},
  url="https://bitsavers.trailing-edge.com/pdf/dec/tech_reports/SRC-RR-81.pdf"
}

% Like Traits 1982, errors out in case of conflicting methods along the hierarchy
@InProceedings{CecilMultimethods,
  author="Chambers, Craig",
  editor="Madsen, Ole Lehrmann",
  title="Object-oriented multi-methods in Cecil",
  booktitle="ECOOP",
  year="1992",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="33--56",
  abstract="Multiple dispatching provides increased expressive power over single dispatching by guiding method lookup using the values of all arguments instead of only the receiver. However, existing languages with multiple dispatching do not encourage the data-abstraction-oriented programming style that is encouraged by traditional single-dispatching languages; instead existing multiple-dispatching languages tend to foster a function-oriented programming style organized around generic functions. We propose an alternative view of multiple dispatching that is intended to promote a data-abstraction-oriented programming style. Instead of viewing a multi-method as ``outside'' of all objects, we view a multi-method as ``inside'' the objects for which the multi-method applies (on which it dispatches). Because objects are closely connected to the multi-methods implementing their operations, the internals of an object can be encapsulated by being accessible only to the closely-connected multi-methods. We are exploring this object-oriented view of multi-methods in the context of a new programming language named Cecil.",
  isbn="978-3-540-47268-1",
  url="http://www.laputan.org/pub/papers/cecil-ecoop-92.pdf"
}

% Introduces the concept of “Abstraction Inversion”
@article{Baker1992CritiqueDKL,
  title={Critique of DIN Kernel Lisp definition version 1.2},
  author={Henry G. Baker},
  journal={LISP and Symbolic Computation},
  year={1992},
  volume={4},
  pages={371-398},
  doi={10.1007/BF01807180},
  url={https://junk.8325.org/hbaker/CritLisp.html}
}

% Dissects the mechanisms of modularity in programming languages,
% offers a zoo of solution, but not in a constructive way.
% The constructive part, mixin inheritance, is great, though.
% p. 24 Says "diamond problem", quoted Bertrand Meyer who says "repeated inheritance",
% Gilad says he didn't invent "diamond" but probably got it from C++ community newsgroups.
% His [65] is a 1987 updated reprint as a book chapter the [64] OOPSLA 1986
% p. 25 Cites CLOS but wrongly claims without argument that it shares the same diamond problem
% as Flavor-less multiple inheritance system. Not aware of how method combination changes the game.
@PhDThesis{bracha1992jigsaw,
  author = {Gilad Bracha},
  title = {The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance},
  school = {University of Utah},
  year = {1992},
  url = {http://www.bracha.org/jigsaw.pdf}
}

@Article{Dickey1992SWOB,
  title={Scheming with Objects},
  author={Dickey, Ken},
  url={http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/oop/yasos/swob.txt},
  journal={AI Expert},
  volume={7},
  number={10},
  pages={24--33},
  year={1992}
}

@InProceedings{chambers92objectoriented,
  author = {Craig Chambers},
  title = {Object-oriented multi-methods in Cecil},
  booktitle = {ECOOP},
  volume = "615",
  publisher = "Springer-Verlag",
  address = "Berlin, Heidelberg, New York, Tokyo",
  editor = "Ole Lehrmann Madsen",
  isbn = "3-540-55668-0",
  pages = "33--56",
  year = "1992",
  url = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.121.134"
}

@article{Goguen1992Sheaf,
  title={Sheaf Semantics for Concurrent Interacting Objects},
  author={Goguen, Joseph A},
  journal={Mathematical Structures in Computer Science},
  volume={2},
  number={2},
  year={1992},
  doi={10.1017/S0960129500001420},
  url={https://cseweb.ucsd.edu/~goguen/ps/sheaf.ps.gz}
}

% Defines the constraints used by C3, but uses a global rather than local tie break rule,
% and goes on rather than errors out if rules are incompatible
@article{Ducournau1992Monotonic,
  title={Monotonic conflict resolution mechanisms for inheritance},
  author={Ducournau, Roland and Habib, Michel and Huchard, Marianne and Mugnier, Marie-Laure},
  journal={ACM SIGPLAN Notices},
  volume={27},
  number={10},
  pages={16--24},
  year={1992},
  publisher={ACM New York, NY, USA},
  url={https://www.researchgate.net/publication/234827636_Monotonic_conflict_resolution_mechanisms_for_inheritance}
}

%% 1993

% http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3952
@InProceedings{ImplementingTypeClasses,
  title = "Implementing Type Classes",
  author = "John Peterson and Mark Jones",
  booktitle = "Proceedings of ACM SIGPLAN Symposium on Programming Language Design and Implementation",
  year = "1993",
  url = "http://web.cecs.pdx.edu/~mpj/pubs/pldi93.html",
  publisher = {Elsevier Science},
}

% Traces (A cut at the “make isn't generic” problem)
% https://link.springer.com/chapter/10.1007/3-540-57342-9_64
@InProceedings{Kiczales1993Traces,
  author="Kiczales, Gregor",
  editor="Nishio, Shojiro and Yonezawa, Akinori",
  title="Traces (A cut at the ``make isn't generic'' problem)",
  booktitle="Object Technologies for Advanced Software",
  year="1993",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="27--42",
  abstract="Object-oriented techniques are a powerful tool for making a system end-programmer specializable. But, in cases where the system not only accepts objects as input, but also creates objects internally, specialization has been more difficult. This has been referred to as the ``make isn't generic problem.'' We present a new object-oriented language concept, called traces, that we have used successfully to support specialization in cases that were previously cumbersome.",
  isbn="978-3-540-48075-4",
  doi={10.1007/3-540-57342-9_64}
}

% No mention of recursive types, or fixpoints, etc.: Looks like the NNOOTT to me.
% StrongTalk.org still runs on Windows 10.
@InProceedings{Bracha1993Strongtalk,
  title={Strongtalk: Typechecking Smalltalk in a production environment},
  author={Bracha, Gilad and Griswold, David},
  journal={ACM SIGPLAN Notices},
  volume={28},
  number={10},
  pages={215--230},
  numpages={16},
  year={1993},
  url={https://bracha.org/oopsla93.pdf},
  isbn={0897915879},
  publisher={Association for Computing Machinery},
  address={New York, NY, USA},
  doi={10.1145/165854.165893},
  booktitle = {the Eighth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications},
  location = {Washington, D.C., USA},
  series = {OOPSLA '93},
  note={.
    A good paper on a very influential system, about practical techniques
    that were widely adopted thereafter by the JVM.
    Yet, from a theoretical point of view... it looks like they are falling for the NNOOTT. Meh.
  },
}

% First version at POPL 1993,
% also U of Edinburgh ECS-LFCS-92-225 "Object-Oriented Programming Without Recursive Types"
% also published in JFP the following year
%  volume={4},
%  DOI={10.1017/S0956796800001040},
%  number={2},
%  journal={Journal of Functional Programming},
%  pages={207–247}
%
% Based on F^\omega_\leq
% Instead of hiding state via scoping, hide it via type abstraction.
% Handles modularity via existential types, pure objects:
% Object = Fun(M:*->*) Some(Rep) {| state: Rep, methods: M Rep |}
% also implements single inheritance on top, but really with mixin inheritance underneath.
% Examples include polymorphic collection.
%
@misc{PT1993STTFOOP,
  author={Pierce, Benjamin C. and Turner, David N.},
  title={Simple Type-Theoretic Foundations for Object-Oriented Programming},
  year={1993},
  url={https://www.cambridge.org/core/journals/journal-of-functional-programming/article/simple-typetheoretic-foundations-for-objectoriented-programming/5C18E2E055B028F7214FBB183701830E},
  notes={.
    This is a solid paper worth reading, though
    I will disagree with both “Simple” and “Foundations” in the title.
    Pierce and Turner do not provide solid foundations
    that pin-point the essence of all OO, based on which to build any OO system.
    Instead, they show how you can side-step
    some of the really hard problems in OO (recursive types!),
    yet achieve most of the value in practice,
    using existential types for modularity—by
    pushing the problematic fixpoint into a corner,
    and asking the user to tie the knot manually in a case
    where it’s relatively easy for the user to do,
    then the system can handle the rest and do the heavy lifting from there.
    Users can then achieve most of the benefits of OO
    despite the system being unable to tie the knot and solve the problem automatically.
    It is a “tell me what you need, I’ll show you how to do without!” kind of paper.
    And you shouldn’t take this description disparagingly:
    this is a great kind of paper, one that shows you how to do more with less.
    Brilliant and insightful.
    Yet, ultimately, a failure, as it dodges rather than solves the problem announced in its title.
  }
}

% 1996 variant has better PDF: doi={10.1145/234286.1057828},
% Read by Eric Normand https://ericnormand.me/podcast/the-early-history-of-smalltalk
@InCollection{Kay1993EHoS,
  title={The Early History of Smalltalk},
  author={Alan C. Kay},
  booktitle={History of programming languages---II},
  url={https://worrydream.com/EarlyHistoryOfSmalltalk/},
  pages={511--598},
  year={1993},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {28},
  number = {3},
  issn = {0362-1340},
  doi = {10.1145/155360.155364},
  abstract = {Most ideas come from previous ideas. The sixties, particularly in the ARPA community, gave rise to a host of notions about “human-computer symbiosis” through interactive time-shared computers, graphics screens and pointing devices. Advanced computer languages were invented to simulate complex systems such as oil refineries and semi-intelligent behavior. The soon to follow paradigm shift of modern personal computing, overlapping window interfaces, and object-oriented design came from seeing the work of the sixties as something more than a “better old thing”. That is, more than a better way: to do mainframe computing; for end-users to invoke functionality; to make data structures more abstract. Instead the promise of exponential growth in computing/$/volume demanded that the sixties be regarded as “almost a new thing” and to find out what the actual “new things” might be. For example, one would compute with a handheld “Dynabook” in a way that would not be possible on a shared mainframe; millions of potential users meant that the user interface would have to become a learning environment along the lines of Montessori and Bruner; and needs for large scope, reduction in complexity, and end-user literacy would require that data and control structures be done away with in favor of a more biological scheme of protected universal cells interacting only through messages that could mimic any desired behavior.Early Smalltalk was the first complete realization of these new points of view as parented by its many predecessors in hardware, language and user interface design. It became the exemplar of the new computing, in part, because we were actually trying for a qualitative shift in belief structures—a new Kuhnian paradigm in the same spirit as the invention of the printing press—and thus took highly extreme positions which almost forced these new styles to be invented.},
  journal = {SIGPLAN Not.},
  month = mar,
  pages = {69–95},
  numpages = {27},
  note={.
    Great read about Smalltalk.
    Inheritance is discussed in section 11.5.1:
    Simula-style inheritance was deliberately left out of Kay’s work on FLEX and early Smalltalk.
    Kay credits Larry Tesler (slot inheritance), Henry Lieberman (delegation),
    and Bobrow and Winograd's KRL (Frames), for the invention of Smalltalk inheritance.
  }
}

%% 1994

@inproceedings{Ducournau1994Monotonic,
author = {Ducournau, R. and Habib, M. and Huchard, M. and Mugnier, M. L.},
title = {Proposal for a monotonic multiple inheritance linearization},
year = {1994},
isbn = {0897916883},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191080.191110},
doi = {10.1145/191080.191110},
abstract = {Previous studies concerning multiple inheritance convinced us that a better analysis of conflict resolution mechanisms was necessary. In [DHHM92], we stated properties that a sound mechanism has to respect. Among them, a monotonicity principle plays a critical role, ensuring that the inheritance mechanism behaves “naturally” relative to the incremental design of the inheritance hierarchy. We focus here on linearizations and present an intrinsically monotonic linearization, whereas currently used linearizations are not. This paper describes the algorithm in detail, explains the design choices, and compares it to other linearizations, with LOOPS and CLOS taken as references. In particular, this new linearization extends CLOS and LOOPS linearizations, producing the same  results when these linearizations are sound.},
booktitle = {Proceedings of the Ninth Annual Conference on Object-Oriented Programming Systems, Language, and Applications},
pages = {164–175},
numpages = {12},
location = {Portland, Oregon, USA},
series = {OOPSLA '94}
}

% https://api.semanticscholar.org/CorpusID:16832709
% University of Illinois at Urbana-Champaign
% October 4, 1993
@InProceedings{Kamin1994TwoSM,
  title={Two semantic models of object-oriented languages},
  author={Samuel N. Kamin and Uday S. Reddy},
  year={1994},
  url={https://www.cs.bham.ac.uk/~udr/papers/oosem.pdf}
}

@Article{Cook1994,
  title={A Denotational Semantics of Inheritance and Its Correctness},
  author={W. Cook and J. Palsberg},
  journal={Information and Computation},
  year={1994},
  volume={114},
  pages={329--350},
  url = {https://www.cs.utexas.edu/~wcook/papers/ic94/ic94.pdf}
}

% PDF: https://github.com/ansbilalgit/Books/blob/master/Erich%20Gamma,%20Richard%20Helm,%20Ralph%20Johnson,%20John%20M.%20Vlissides-Design%20Patterns_%20Elements%20of%20Reusable%20Object-Oriented%20Software%20%20-Addison-Wesley%20Professional%20(1994).pdf
@book{GoF1994,
  title={Design patterns: elements of reusable object-oriented software},
  author={Erich Gamma and Richard Helm and Ralph Johnson and John Vlissides},
  year={1994},
  publisher={Addison-Wesley},
  isbn={9780201633610},
  url={https://hillside.net/elements-of-reusable-object-oriented-software-book},
  note={.
    The classic "Gang of Four" (GoF) book on Design Patterns. Much loved, much hated.
    To quote Rich Hickey, «Patterns mean “I have run out of language.”»
    I.e. patterns are using fourth class entities because you can’t (or otherwise fail to)
    afford automation and abstraction.
    Which is a bad thing to happen, but sometimes it does and then you’re glad you have patterns.
  }
}

% Extend a simply typed LC (terminating) with simple objects and a typesystem
% (can add or override messages; difference meaningful because of type system)
% Prove the typesystem sound.
@article{LambdaCalculusObjects1994,
  title={A Lambda-Calculus of Objects and Method Specialization},
  author={Kathleen Fisher and Furio Honsell and John C. Mitchell},
  year={1994},
  journal={Nordic Journal of Computing},
  volume={1},
  pages={3-37}
}

@article{sernadas1994,
  author={Costa, J. and Sernadas, Amilcar and Sernadas, Cristina},
  year={1994},
  month={06},
  pages={5-26},
  title={Object inheritance beyond subtyping},
  volume={31},
  journal={Acta Informatica},
  doi={10.1007/BF01178920},
  url={https://www.researchgate.net/publication/225917432_Object_inheritance_beyond_subtyping},
  note={.
    This is yet another paper that claims to model OO using Category Theory,
    but actually models the NNOOTT instead.
    The authors seem clueless about what they do, and provide no warning.
    They also try to redefine "inheritance" as refinement,
    except that when it's "non-monotonic", you only have a partial map,
    and anything goes (you said nothing). Shameful.
  }
}

@InProceedings{harper1994modules,
  title={A type-theoretic approach to higher-order modules with sharing},
  author={Harper, Robert and Lillibridge, Mark},
  booktitle={the 21st ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  pages={123--137},
  year={1994},
  doi={10.1145/174675.176927},
  note={.
    This paper brilliantly introduces what will become Modules and Functors for SML.
    One problem is that subtyping is not decidable.
  }
}

@inproceedings{remy1994mlart,
  title={Programming objects with ML-ART an extension to ML with abstract and record types},
  author={Didier Rémy},
  booktitle={International Symposium on Theoretical Aspects of Computer Software},
  pages={321--346},
  year={1994},
  organization={Springer},
  url={https://scispace.com/pdf/programming-objects-with-ml-art-an-extension-to-ml-with-3s0xd52vz4.pdf},
  doi={10.1145/263699.263707},
  note={.
    The author uses extensible records and a form of existential,
    plus "projective types" (to palliate lack for higher order kind *->*),
    to emulate what Pierce and Turner do with F^\omega_\leq.
    He implements flavorless multiple inheritance, with or without mutation.
    This is solid work as a formal system, but not very usable as an object system,
    and the limited support for subtyping doesn’t help.
    The basis for what will be the O in OCaml.
    (Though I often jest that that O actually stands for how much the authors of OCaml
    actually care about Objects.)
  }
}

% introduces the "Liskov substitution principle"
% Liskov & Wing
% A behavioral notion of subtyping

%% 1995

% https://pl.cs.jhu.edu/projects/type-constraints/papers/type-inference-for-recursively-constrained-types-and-its-application-to-oop-longer-version.pdf
@article{isoop1995,
  title={Type inference for recursively constrained types and its application to OOP},
  author={Eifrig, Jonathan and Smith, Scott and Trifonov, Valery},
  journal={Electronic Notes in Theoretical Computer Science},
  volume={1},
  pages={132--153},
  year={1995},
  publisher={Elsevier},
  url={https://pl.cs.jhu.edu/projects/type-constraints/papers/type-inference-for-recursively-constrained-types-and-its-application-to-oop.pdf},
  note={.
    This paper presents I-SOOP, a simple language with polymorphic recursively constrained types,
    for which they present a type inference algorithm,
    and that is the Right Thing™ on top of which to type OO.
  }
}

% https://dl.acm.org/doi/pdf/10.1145/217838.217858
@inproceedings{iloop1995,
  title={Sound Polymorphic Type Inference for Objects},
  author={Eifrig, Jonathan and Smith, Scott and Trifonov, Valery},
  booktitle={Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications},
  pages={169--184},
  year={1995},
  doi={10.1145/217838.217858},
  note={.
    This paper presents I-LOOP, a language with classes, macro-reduced to I-SOOP, with type inference.
    AFAICT, the authors are the first to use polymorphic recursively constrained types,
    which is the Right Thing™ to type OO, what more with type inference.
  }
}

% AAI0576129 ???
@PhDThesis{Rees1995W7,
  author = {Rees, Jonathan Allen},
  title = {A Security Kernel Based on the Lambda Calculus},
  year = {1995},
  publisher = {Massachusetts Institute of Technology},
  school = {Massachusetts Institute of Technology},
  address = {USA},
  url = {http://mumble.net/~jar/pubs/secureos/},
  abstract = {Cooperation between independent agents depends upon establishing a degree of security. Each of the cooperating agents needs assurance that the cooperation will not endanger resources of value to that agent. In a computer system, a computational mechanism can assure safe cooperation among the system's users by mediating resource access according to desired security policy. Such a mechanism, which is called a security kernel, lies at the heart of many operating systems and programming environments. The dissertation describes Scheme 48, a programming environment whose design is guided by established principles of operating system security. Scheme 48's security kernel is small, consisting of the call-by-value $lambda$-calculus with a few simple extensions to support abstract data types, object mutation, and access to hardware resources. Each agent (user or subsystem) has a separate evaluation environment that holds objects representing privileges granted to that agent. Because environments ultimately determine availability of object references, protection and sharing can be controlled largely by the way in which environments are constructed.I will describe experience with Scheme 48 that shows how it serves as a robust and flexible experimental platform. Two successful applications of Scheme 48 are the programming environment for the Cornell mobile robots, where Scheme 48 runs with no (other) operating system support; and a secure multi-user environment that runs on workstations. (Copies available exclusively from MIT Libraries, Rm. 14-0551, Cambridge, MA 02139-4307. Ph. 617-253-5668; Fax 617-253-1690.)},
  doi={10.5555/921818},
  note={.
    Fantastic classic paper, Rees’s thesis introduces his “W7” security kernel,
    leveraging scoping as a natural mechanism for object capabilities based security.
  }
}

% https://x.com/Ngnghm/status/1985873697949761682
@InProceedings{Jacobs1995ObjectsAC,
  title={Objects and Classes, Co-Algebraically},
  author={Bart Jacobs},
  booktitle={Object Orientation with Parallelism and Persistence},
  pages={83--103},
  year={1995},
  doi={10.5555/261075.261479},
  url={https://static.aminer.org/pdf/PDF/000/137/588/objects_and_classes_co_algebraically.pdf},
  note={.
    Cook positively mentioned Jacobs in private email, and cites him in Cook 2012,
    as justification why OO doesn’t need inheritance.
    But this paper is actually not OO at all, but relational modeling with Category Theory.
    In the last paragraph of section 2, Jacobs says that “Ai, Bi, Ci are (constant) sets.”
    All the negation of actual OO is concentrated in a single word, what more in parentheses,
    lost in the middle of the article, that restricts classes
    to the non-recursive subset where the NNOOTT applies. Wow.
    But that doesn’t require malice, only ignorance. Jacobs cites Goguen,
    who was also using Category Theory; but Goguen was using it to do rewrite logic
    and software specification with the trappings of OO.
    Jacobs does just relational data modeling.
  }
}

%% 1996

@Misc{Eich1996JavaScript,
  title={JavaScript Language Specification},
  author={Brendan Eich},
  year={1996},
  url={https://archives.ecma-international.org/1996/TC39/96-002.pdf},
  note={
    The ECMA/TC39/96/2 is the very first Draft version of the JavaScript Language Specification.
    There was documentation on webpages in 1995, but no official specification yet.
    This document mentions neither “inheritance” nor “delegation” about its objects.
    Notably, the introduction says
    “JavaScript borrows most of its syntax from Java, but also inherits from Awk and Perl, with some
    indirect influence from Self in its object system.”
  }
}

% https://sci-hub.ru/https://link.springer.com/chapter/10.1007/BFb0053063
@InProceedings{Jacobs1996InheritanceAC,
  title={Inheritance and Cofree Constructions},
  author={Bart Jacobs},
  booktitle={European Conference on Object-Oriented Programming},
  year={1996},
  doi={10.1007/BFb0053063},
  note={.
    Jacbos claims to formalize inheritance, but actually goes full NNOOTT.
    At least, he understands what he is doing,
    for in the second paragraph of section 2, he explicitly disallows open recursion
    through the module context:
    «where A and B are constant sets, not depending on the “unknown” type X (of self)».
    But he doesn’t understand why that’s a wrong thing to do when you claim you’re doing OO.
  }
}

@InProceedings{Barrett1996C3,
  author = {Kim Barrett and Bob Cassels and Paul Haahr and David A. Moon and Keith Playford and P. Tucker Withington},
  title = {A Monotonic Superclass Linearization for Dylan},
  journal={OOPSLA},
  month = {oct},
  pages = {69–82},
  numpages = {14},
  year = {1996},
  booktitle = {OOPSLA},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/236337.236343},
  url = {https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.3910},
  note={.
    This paper introduces the C3 superclass linearization algorithm,
    providing a simple practical solution to the problem first solved by Ducournau 1994:
    a multiple inheritance Linearization algorithm that satisfies the Monotonicity property
    as well as the Local Precedence Order (and, without saying it, Shape Determinism).
    The best way to do Multiple Inheritance.
  }
}

@Article{inheritance1996,
  author = {Antero Taivalsaari},
  title = {On the Notion of Inheritance},
  year = {1996},
  issue_date = {Sept. 1996},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {28},
  number = {3},
  issn = {0360-0300},
  url = {https://doi.org/10.1145/243439.243441},
  doi = {10.1145/243439.243441},
  abstract = {One of the most intriguing—and at the same time most problematic—notions in object-oriented programing is inheritance. Inheritance is commonly regarded as the feature that distinguishes object-oriented programming from other modern programming paradigms, but researchers rarely agree on its meaning and usage. Yet inheritance of often hailed as a solution to many problems hampering software development, and many of the alleged benefits of object-oriented programming, such as improved conceptual modeling and reusability, are largely credited to it. This article aims at a comprehensive understanding of inheritance, examining its usage, surveying its varieties, and presenting a simple taxonomy of mechanisms that can be seen as underlying different inheritance models.},
  journal = {ACM Comput. Surv.},
  month = {sep},
  pages = {438--479},
  numpages = {42},
  keywords = {object-oriented programming, language constructs, delegation, inheritance, incremental modification, programming languages}
}

@PhDThesis{Fisher1996thesis,
  title={Type Systems for object-oriented programming languages},
  author={Fisher, Kathleen Shanahan},
  year={1996},
  publisher={Stanford University},
  url={https://www.researchgate.net/publication/2828333_Type_Systems_For_Object-Oriented_Programming_Languages}
}

% https://kbb04747.sites.pomona.edu/README.html#Match
@article{Bruce1996Typing,
  title={Typing in Object-Oriented Languages: Achieving Expressiveness and Safety},
  author={Bruce, Kim B},
  journal={Unpublished, June},
  year={1996},
  url={https://www.academia.edu/2617908/Typing_in_object_oriented_languages_Achieving_expressibility_and_safety},
  note={.
    This paper includes a good explanation of the problems with the NNOOTT.
    It also is somewhat aware of the issue of conflation:
    “The notions of type and class are often confounded
    in object-oriented programming languages” p. 5.
    But it still chooses an approach with an ad hoc class primitive,
    in which the open recursion type is accessible via the special type variable MyType,
    and subtyping before the fixpoint is called “matching”
    (though this (correct) technique is not explained in those terms).
  }
}

% https://www.stroustrup.com/hopl2.pdf
@inbook{stroustrup1996hopl,
  author = {Stroustrup, Bjarne},
  title = {A history of C++: 1979--1991},
  year = {1996},
  isbn = {0201895021},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/234286.1057836},
  abstract = {This paper outlines the history of the C++ programming language. The emphasis is on the ideas, constraints, and people that shaped the language, rather than the minutiae of language features. Key design decisions relating to language features are discussed, but the focus is one the overall design goals and practical constraints. The evolution of C++ is traced from C with Classes to the current ANSI and ISO standards work and the explosion of use, interest, commercial activity, compilers, tools, environments, and libraries.},
  booktitle = {History of Programming Languages---II},
  pages = {699–769},
  numpages = {71}
}

@Book{AbadiCardelli1996ToO,
  author = {Martín Abadi and Luca Cardelli},
  title = {A Theory of Objects},
  year = {1996},
  doi = {10.1007/978-1-4419-8598-9},
  note={.
    Abadi and Cardelli (A&C) are well known and well respected authors,
    and this classic book of theirs was long presented as the gold standard
    of what it means to formalize OO. A student at the time the book was published,
    I was dreaming one day I’d be able to understand it
    and write papers half as good as I was told A&C’s were.
    But their book (and papers) left me stumped, and so I thought the problem was with me.
    Re-reading it now that I do understand OO, I realize the problem was with A&C all along.
    A&C hold false beliefs about OO, then deploy their vast intelligence
    using fancy logical semantics in doomed attempts to find
    models that satisfy their inconsistent beliefs.
    Each time, they can explain why it doesn't quite work—then go find a more sophisticated
    model that of course will also fail—instead of questioning their premises.
    A sad waste of brilliant minds—for both authors and readers who
    after those lengthy constructions believe they understand OO better rather than worse.
  }
}

@article{Abadi1996Primitive,
  title = {A Theory of Primitive Objects: Untyped and First-Order Systems},
  journal = {Information and Computation},
  volume = {125},
  number = {2},
  pages = {78-102},
  year = {1996},
  issn = {0890-5401},
  doi = {10.1006/inco.1996.0024},
  url = {https://www.sciencedirect.com/science/article/pii/S0890540196900243},
  author = {Martín Abadi and Luca Cardelli},
  abstract = {We introduce simple object calculi that support method override and object subsumption. We give an untyped calculus, typing rules, and equational rules. We illustrate the expressiveness of our calculi and the pitfalls that we avoid.},
  note={.
    A&C fall into all the common traps of OO:
    they confuse specification and target, therefore firmly believe in the NNOOTT;
    they try to use modular definitions and fail to understand modular extensions,
    therefore can’t apprehend mixin and multiple inheritance.
    They deploy all their brilliance to seek ever more sophisticated models that
    will push back the point at which they confront the contradictions in their beliefs;
    they won’t abandon their beliefs so they abandon the models.
    Their “Self-Application Semantics” turns a lambda into a primitive “sigma”
    that inverts basic logic so they can avoid obvious contradiction.
    Their “Recursive Record Semantics” is perfectly correct for targets,
    but of course doesn’t apply to specifications, and A&C can’t imagine
    that the two need to be solved separately before they can be joined.
    Their “Generator Semantics” is on the right track, and A&C can almost articulate
    the distinction of target (“record”) and specification (“generator”),
    but once again find the solution problematic (they are missing our “recursive conflation”).
    Then they go in and out of some Pierce “split-self” semantics (see Pierce and Turner 1993)
    and note that it works well for Class OO but move on rather than dig into
    the interesting fine reasons why.
    Finally their “solution” is to implement objects on top of the same
    syntactic rewrite logic paradigm as the λ-calculus is usually presented in.
    A low-level implementation,
    just for a mathematical “virtual machine” foreign to anyone but logicians.
    “Cool. So what?”
    Low-level object implementations in Lisp, BCPL or C existed for 2 decades already.
    Their calculus won’t help OO practitioners understand semantics,
    and won't help logicians appreciate OO.
    We already knew such feat was possible, since rewrite logic is a universal subtratum.
    Instead, the important semantic details worth discussing and arguing
    get lost in the details of a tedious construction.
    So nobody learns anything.}
}

@Book{SICP2,
  Author={Harold Abelson and Gerald Sussman},
  Title={Structure and Interpretation of Computer Program},
  Edition={2nd},
  Publisher={MIT Press},
  Year={1996},
  doi={10.5555/547755},
  isbn={978-0-262-01153-2},
  url={https://web.mit.edu/6.001/6.037/sicp.pdf},
  note={.
    This classic book, first published in 1984, inspired generations of computer scientists.
    It is somewhat outdated in its style or its treatment of some topics,
    but many of its insights are timeless.
    Even its footnotes alone are gold.
    The author do build some notion of “objects” as message-handling functions,
    but this only deals with the “encapsulation” of state (modularity) aspect of OO,
    and the authors explicitly avoid the topic inheritance.
  }
}

% https://github.com/appleby/Lisp-In-Small-Pieces?tab=readme-ov-file
% https://christian.queinnec.org/WWW/LiSP.html
% Les Langages Lisp 1994
@book{Queinnec1996LiSP,
  title={Lisp in Small Pieces},
  author={Queinnec, Christian},
  translator={Callaway, Kathleen},
  publisher={Cambridge University Press},
  url={https://christian.queinnec.org/WWW/LiSP.html},
  doi={10.1017/CBO9781139172974},
  year={1996},
  note={.
    This classic book will demystify the implementation of languages in the Lisp or Scheme family.
    Great for theory and practice alike.
  }
}

%% 1997

@inproceedings{Foote1997BBoM,
  title={Big Ball of Mud},
  author={Brian Foote and Joseph W. Yoder},
  booktitle={PLoP},
  year={1997},
  url={http://www.laputan.org/mud/}
}

% ECMAScript language specification, 1st edition. Says "inheritance" and not "delegation". Yay.
% Before that, there was Netscape documentation that says "prototype" but neither "inheritance" nor "delegation", e.g. at
% https://web.archive.org/web/20060318153542/http://wp.netscape.com/eng/mozilla/3.0/handbook/javascript/index.html
% Note that the book "Programming JavaScript for Netscape 2.0" (1996) by Tim Ritchey also talks of inherit / inheritance, not delegate / delegation https://archive.org/details/programmingjavas00ritc/mode/2up?q=inherit
@Misc{ecmascript1997,
  title={ECMAScript: A general purpose cross-platform programming language},
  author={ECMA-262},
  year={1997},
  month=June,
  url={https://ecma-international.org/publications-and-standards/standards/ecma-262/}
}

% InProceedings
@Misc{SubtypingMatch1997,
  doi={10.1007/BFb0053376},
  author="Bruce, Kim B.
and Petersen, Leaf
and Fiech, Adrian",
  editor="Ak{\c{s}}it, Mehmet
and Matsuoka, Satoshi",
  title="Subtyping is not a good ``match'' for object-oriented languages",
  booktitle="ECOOP'97 --- Object-Oriented Programming",
  year="1997",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="104--127",
  abstract="We present the design and rationale of a new statically-typed object-oriented language, LOOM. LOOM, retains most of the features of the earlier language PolyTOIL. However the subtyping relation is dropped from LOOM in favor of the matching relation. ``Hash types'', which are denned in terms of matching, are introduced to provide some of the benefits of subtyping. These types can be used to provide support for heterogeneous data stuctures in LOOM. LOOM. is considerably simpler than PolyTOIL, yet is just as expressive. The type system for the language is decidable and provably type safe. The addition of modules to the language provides better control over information hiding and allows the provision of access like that of C++'s friends.",
  ISBN="978-3-540-69127-3"
}

@InProceedings{aop97,
  author = {Kiczales, G. and Lamping, J. and Mendhekar, A. and Maeda, C. and Lopes, C. and Loingtier, J. M. and Irwin, J.},
  title = {Aspect-oriented programming},
  booktitle = {ECOOP},
  pages = {220--242},
  year = {1997}
}

%% 1998

% Defines a dialect of Java with mixins, MixedJava, to illustrate the approach taken in MzScheme,
% later better described in their 2006 paper.
% https://www.semanticscholar.org/paper/Classes-and-mixins-Flatt-Krishnamurthi/c20e5f2a424b96209e6b400b23d319558932afa3
@Misc{Mixins1998,
  author = {Flatt, Matthew and Krishnamurthi, Shriram and Felleisen, Matthias},
  title = {Classes and mixins},
  year = {1998},
  isbn = {0897919793},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/268946.268961},
  doi = {10.1145/268946.268961},
  abstract = {While class-based object-oriented programming languages provide a flexible mechanism for re-using and managing related pieces of code, they typically lack linguistic facilities for specifying a uniform extension of many classes with one set of fields and methods. As a result, programmers are unable to express certain abstractions over classes.In this paper we develop a model of class-to-class functions that we refer to as mixins. A mixin function maps a class to an extended class by adding or overriding fields and methods. Programming with mixins is similar to programming with single inheritance classes, but mixins more directly encourage programming to interfaces.The paper develops these ideas within the context of Java. The results are 1. an intuitive model of an essential Java subset; 2. an extension that explains and models mixins; and 3. type soundness theorems for these languages.},
  booktitle = {Proceedings of the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages = {171–183},
  numpages = {13},
  location = {San Diego, California, USA},
  series = {POPL '98}
}

%% 1999

@inproceedings{10.1145/301618.301638,
author = {Fisher, Kathleen and Reppy, John},
title = {The design of a class mechanism for Moby},
year = {1999},
isbn = {1581130945},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/301618.301638},
doi = {10.1145/301618.301638},
abstract = {Typical class-based languages, such as C++ and JAVA, provide complex class mechanisms but only weak module systems. In fact, classes in these languages incorporate many of the features found in richer module mechanisms. In this paper, we describe an alternative approach to designing a language that has both classes and modules. In our design, we rely on a rich ML-style module system to provide features such as visibility control and parameterization, while providing a minimal class mechanism that includes only those features needed to support inheritance. Programmers can then use the combination of modules and classes to implement the full range of class-based features and idioms. Our approach has the advantage that it provides a full-featured module system (useful in its own right), while keeping the class mechanism quite simple.We have incorporated this design in MOBY, which is an ML-style language that supports class-based object-oriented programming. In this paper, we describe our design via a series of simple examples, show how various class-based features and idioms are realized in MOBY, compare our design with others, and sketch its formal semantics.},
booktitle = {Proceedings of the ACM SIGPLAN 1999 Conference on Programming Language Design and Implementation},
pages = {37–49},
numpages = {13},
location = {Atlanta, Georgia, USA},
series = {PLDI '99}
}

@article{10.1145/301631.301638,
  author = {Kathleen Fisher and John Reppy},
  title = {The Design of a Class Mechanism for Moby},
  year = {1999},
  issue_date = {May 1999},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {34},
  number = {5},
  issn = {0362-1340},
  url = {https://doi.org/10.1145/301631.301638},
  doi = {10.1145/301631.301638},
  abstract = {Typical class-based languages, such as C++ and JAVA, provide complex class mechanisms but only weak module systems. In fact, classes in these languages incorporate many of the features found in richer module mechanisms. In this paper, we describe an alternative approach to designing a language that has both classes and modules. In our design, we rely on a rich ML-style module system to provide features such as visibility control and parameterization, while providing a minimal class mechanism that includes only those features needed to support inheritance. Programmers can then use the combination of modules and classes to implement the full range of class-based features and idioms. Our approach has the advantage that it provides a full-featured module system (useful in its own right), while keeping the class mechanism quite simple.We have incorporated this design in MOBY, which is an ML-style language that supports class-based object-oriented programming. In this paper, we describe our design via a series of simple examples, show how various class-based features and idioms are realized in MOBY, compare our design with others, and sketch its formal semantics.},
  journal = {SIGPLAN Not.},
  month = may,
  pages = {37–49},
  numpages = {13}
}

% CBPV
@InProceedings{Levy1999CBPV,
  title = {Call-by-Push-Value: A Subsuming Paradigm},
  year = {1999},
  author = {Blain Levy, Paul},
  publisher = {Springer},
  booktitle = {Typed Lambda Calculi and Applications, 4th International Conference, TLCA'99, L'Aquila, Italy, April 7-9, 1999, Proceedings},
  pages = {228--243},
  doi = {10.1007/3-540-48959-2_17}
}

%% 2000

% Introduces explicit implemented-by relationship to avoid confusion between metalevels
% when extending (e.g. adding shadow slots for history, implementing persistence, etc.)
% https://www.researchgate.net/publication/2436142_Avoiding_Confusion_in_Metacircularity_The_Meta-Helix
@article{Chiba2000MetaHelix,
  author = {Chiba, Shigeru and Kiczales, Gregor and Lamping, John},
  year = {2000},
  month = {11},
  title = {Avoiding Confusion in Metacircularity: The Meta-Helix},
  isbn = {978-3-540-60954-4},
  journal = {Lecture Notes in Computer Science},
  doi = {10.1007/3-540-60954-7_49}
}

% Implements proper multiple inheritance on top of C++, but
% you have to manually linearize and pass the Super in a template.
% InProceedings
@Misc{Smaragdakis2000Mixin,
  title={Mixin-based programming in C++},
  author={Yannis Smaragdakis and Don Batory},
  booktitle={International Symposium on Generative and Component-Based Software Engineering},
  pages={164--178},
  year={2000},
  organization={Springer},
  url={https://www.researchgate.net/publication/2617570_Mixin-Based_Programming_in_C}
}

% https://www.math.nagoya-u.ac.jp/~garrigue/papers/variant-reuse.pdf
% Open Recursion, etc., is not just for extensible products, but also extensible variants.
% The requirement for the subclass's type to be a subtype is imbecillic at best,
% even at the specification level, what more at the target level.
@inproceedings{garrigue2000code,
  title={Code reuse through polymorphic variants},
  author={Garrigue, Jacques},
  booktitle={Workshop on Foundations of Software Engineering},
  volume={13},
  year={2000},
  url={https://www.math.nagoya-u.ac.jp/~garrigue/papers/fose2000.html}
}

%% 2001

@InProceedings{DSU2001,
  author = {Hicks, Michael and Moore, Jonathan T. and Nettles, Scott},
  title = {Dynamic Software Updating},
  year = {2001},
  isbn = {1581134142},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/378795.378798},
  doi = {10.1145/378795.378798},
  abstract = {Many important applications must run continuously and without interruption, yet must be changed to fix bugs or upgrade functionality. No prior general-purpose methodology for dynamic updating achieves a practical balance between flexibility, robustness, low overhead, and ease of use.We present a new approach for C-like languages that provides type-safe dynamic updating of native code in an extremely flexible manner (code, data, and types may be updated, at programmer-determined times) and permits the use of automated tools to aid the programmer in the updating process. Our system is based on dynamic patches that both contain the updated code and the code needed to transition from the old version to the new. A novel aspect of our patches is that they consist of verifiable native code (e.g. Proof-Carrying Code [17] or Typed Assembly Language [16]), which is native code accompanied by annotations that allow on-line verification of the code's safety. We discuss how patches are generated mostly automatically, how they are applied using dynamic-linking technology, and how code is compiled to make it updateable.To concretely illustrate our system, we have implemented a dynamically-updateable web server, FlashEd. We discuss our experience building and maintaining FlashEd. Performance experiments show that for FlashEd, the overhead due to updating is typically less than 1\%.},
  booktitle = {Proceedings of the ACM SIGPLAN 2001 Conference on Programming Language Design and Implementation},
  pages = {13–23},
  numpages = {11},
  location = {Snowbird, Utah, USA},
  series = {PLDI '01}
}

@InProceedings{SullivanGriswoldCaiHallen2001,
  author = {Sullivan, Kevin J. and Griswold, William G. and Cai, Yuanfang and Hallen, Ben},
  title = {The Structure and Value of Modularity in Software Design},
  year = {2001},
  isbn = {1581133901},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/503209.503224},
  doi = {10.1145/503209.503224},
  abstract = {The concept of information hiding modularity is a cornerstone of modern software design thought, but its formulation remains casual and its emphasis on changeability is imperfectly related to the goal of creating added value in a given context. We need better explanatory and prescriptive models of the nature and value of information hiding. We evaluate the potential of a new theory---developed to account for the influence of modularity on the evolution of the computer industry---to inform software design. The theory uses design structure matrices to model designs and real options techniques to value them. To test the potential utility of the theory for software we apply it to Parnas's KWIC designs. We contribute an extension to design structure matrices, and we show that the options results are consistent with Parnas's conclusions. Our results suggest that such a theory does have potential to help inform software design.},
  booktitle = {Proceedings of the 8th European Software Engineering Conference Held Jointly with 9th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  pages = {99–108},
  numpages = {10},
  keywords = {real options, design structure matrix, modularity, software},
  location = {Vienna, Austria},
  series = {ESEC/FSE-9}
}

%% 2002

% No mention of recursive types, or fixpoints, etc.: Looks like the NNOOTT to me.
@inproceedings{Bak2002Mixins,
  title={Mixins in Strongtalk},
  author={Bak, Lars and Bracha, Gilad and Grarup, Steffen and Griesemer, Robert and Griswold, David and Hölzle, Urs},
  booktitle={ECOOP 2002 Workshop on Inheritance},
  year={2002},
  url={https://bracha.org/mixins-paper.pdf}
}

% downloaded from https://www.cs.sjtu.edu.cn/~kzhu/cs383/Pierce_Types_Programming_Languages.pdf
% This post claims that TAPL introduces the term "Open Recursion" https://journal.stuffwithstuff.com/2013/08/26/what-is-open-recursion/ - but Cardelli 1992 mentions it already.
% ... see a system $F_{<:}^\omega$
@Book{Pierce2002TAPL,
  Author = {Pierce, Benjamin C.},
  Title = {Types and Programming Languages},
  Year = {2002},
  ISBN = {0262162091},
  Publisher = {MIT Press},
  Edition = {1st},
  url = {https://www.cis.upenn.edu/~bcpierce/tapl/},
  note={.
    TAPL treats objects in chapters 18, 19, 24, 32.
    18 has a gradual approach to implementing not-quite-objects, and adding features
    until the reader has actually implemented objects. It’s clever, but a bit long-winded.
    See my note on Pierce & Turner 1993 regarding letting the user provide a rep type.
    32.10 Pierce does discuss the actual solution, recursive data types, but
    leaves it as an exercise after pointing to the bibliography.
    Pierce is technically masterful, but my impression is that he doesn’t understand the
    purpose of OO, because it is a foreign paradigm (see Gabriel 2012);
    and so not only he cannot drill into the essence of it,
    he spends more time on the non-essentials (imperative programming),
    and leaves the actually interesting essential (recursive types) out of his text,
    using a shortcut (his rep type) to survive without it.
  }
}

% inproceedings
@Misc{findler2002contracts,
  title={Contracts for higher-order functions},
  author={Findler, Robert Bruce and Felleisen, Matthias},
  booktitle={Proceedings of the seventh ACM SIGPLAN international conference on Functional programming},
  pages={48--59},
  year={2002},
  url={https://users.cs.northwestern.edu/~robby/publications/papers/ho-contracts-icfp2002.pdf}
}

%% 2003

@Misc{Kay2003,
  Author={Alan Kay},
  Title={Clarification of "object-oriented" (email)},
  URL={https://www.purl.org/stefan_ram/pub/doc_kay_oop_en},
  Year={2003},
  Month={07},
  Day={23}
}

% https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=693f61d2515ac9b032801dd7a603c34f1b725071
% Wrongly claims that multidispatch forgoes modular typechecking
% Has no definition of modularity, except maybe for typechecking
@phdthesis{millstein2003reconciling,
  title={Reconciling software extensibility with modular program reasoning},
  author={Millstein, Todd David},
  year={2003},
  school={University of Washington},
  doi={10.5555/997550},
  url={https://web.cs.ucla.edu/~todd/research/dissertation.pdf},
}

% https://erlang.org/download/armstrong_thesis_2003.pdf
@phdthesis{Armstrong2003,
  author       = {Joe Armstrong},
  title        = {Making reliable distributed systems in the presence of software errors},
  school       = {Royal Institute of Technology, Stockholm, Sweden},
  year         = {2003},
  url          = {https://nbn-resolving.org/urn:nbn:se:kth:diva-3658},
  urn          = {urn:nbn:se:kth:diva-3658},
  timestamp    = {Mon, 21 Nov 2022 17:42:05 +0100},
  biburl       = {https://dblp.org/rec/phd/basesearch/Armstrong03.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org},
  note={.
    Joe gives an overview of Erlang, the great Concurrency-Oriented Programming Language
    of which he was one of the main authors. Actors taken seriously into production.
    Section 3.8 “Dynamic Code Change” describes support for hot code upgrade.
    Only 2 versions of the code allowed; at the 3rd, processes using the 1st are killed.
    I _suppose_ that means there are again only 2 versions left, and
    only 1 after all processes are fully updated.
    That’s good enough great in Erlang because failure is always a valid fallback,
    but may might not be enough in less resilient systems.
    The semantics of upgrade is well-defined:
    calls to module-qualified name are dynamic, to unqualified name are static.
    Tail-calls are recommended but not mandated.
  }
}

%% 2005

@InProceedings{Salzman2005PrototypesMultipleDispatch,
  author = {Lee Salzman and Jonathan Aldrich},
  title = {Prototypes with Multiple Dispatch: An Expressive and Dynamic Object Model},
  booktitle = {ECOOP},
  year = {2005},
  abstract="Two object-oriented programming language paradigms---dynamic, prototype-based languages and multi-method languages---provide orthogonal benefits to software engineers. These two paradigms appear to be in conflict, however, preventing engineers from realizing the benefits of both technologies in one system. This paper introduces a novel object model, prototypes with multiple dispatch (PMD), which seamlessly unifies these two approaches. We give formal semantics for PMD, and discuss implementation and experience with PMD in the dynamically typed programming language Slate.",
  url={https://www.cs.cmu.edu/~aldrich/papers/ecoop05pmd.pdf}
}

@article{scalableComponentAbstractions2005,
  author = {Odersky, Martin and Zenger, Matthias},
  title = {Scalable component abstractions},
  year = {2005},
  issue_date = {October 2005},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {40},
  number = {10},
  issn = {0362-1340},
  %url = {https://doi.org/10.1145/1103845.1094815},
  url = {http://lampwww.epfl.ch/~odersky/papers/ScalableComponent.pdf},
  doi = {10.1145/1103845.1094815},
  abstract = {We identify three programming language abstractions for the construction of reusable components: abstract type members, explicit selftypes, and modular mixin composition. Together, these abstractions enable us to transform an arbitrary assembly of static program parts with hard references between them into a system of reusable components. The transformation maintains the structure of the original system. We demonstrate this approach in two case studies, a subject/observer framework and a compiler front-end.},
  journal = {SIGPLAN Not.},
  month = {oct},
  pages = {41--57},
  numpages = {17},
  keywords = {Scala, abstract types, classes, components, mixins},
  isbn = {1595930310},
  %booktitle = {Proceedings of the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
  %%booktitle = {OOPSLA '05},
  booktitle = {OOPSLA},
  location = {San Diego, CA, USA},
  series = {OOPSLA '05}
}

% Open Data Types and Open Functions https://www.andres-loeh.de/OpenDatatypes.pdf
% Andres Löh and Ralf Hinze, PPDP 2006 -- not really OO, just use of typeclasses.
% cites O'Haskell (Norlander 2001) vs OOHaskell (Kiselyov & Lämmel 2005)
% https://github.com/nkaretnikov/OOHaskell
% https://arxiv.org/pdf/cs/0509027
% https://api.semanticscholar.org/CorpusID:13547784
@misc{Kiselyov2005HaskellOOS,
      title={Haskell's overlooked object system},
      author={Oleg Kiselyov and Ralf Lämmel},
      year={2005},
      eprint={cs/0509027},
      archivePrefix={arXiv},
      primaryClass={cs.PL},
      url={https://arxiv.org/abs/cs/0509027},
}

%% 2006

@InProceedings{Flatt2006Mixins,
  author = {Matthew Flatt and Robert Bruce Findler and Matthias Felleisen},
  title = {Scheme with classes, mixins, and traits},
  booktitle = {In Asian Symposium on Programming Languages and Systems (APLAS) 2006},
  year = {2006},
  pages = {270--289},
  url = {https://www2.ccs.neu.edu/racket/pubs/asplas06-fff.pdf}
}

@InProceedings{BruceCardelliPierce2006,
    author = {Kim B. Bruce and Luca Cardelli and Benjamin C. Pierce},
    title = {Comparing Object Encodings},
    booktitle = {Journal of Functional Programming},
    volume = {16},
    pages = {375-–414},
    year = {2006},
}
% http://citeseerx.ist.psu.edu/viewdoc/similar?doi=10.1.1.211.6777&type=cc

%% 2007

@Book{Manin2007,
  author={Yuri I. Manin},
  title={Mathematics as Metaphor},
  year=2007,
  isbn={978-0-8218-4331-4},
  doi={10.1093/philmat/nkn013},
  publisher={American Mathematical Society},
  note={.
    This edition includes a nice Foreword by Freeman Dyson.
  }
}

% Pages 9-1 to 9-50, scriblib/bibtex can’t parse that :-/
@InProceedings{self2007hopl,
  author = {Ungar, David and Smith, Randall B.},
  title = {Self},
  year = {2007},
  isbn = {9781595937667},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1238844.1238853},
  doi = {10.1145/1238844.1238853},
  abstract = {The years 1985 through 1995 saw the birth and development of the language Self, starting from its design by the authors at Xerox PARC, through first implementations by Ungar and his graduate students at Stanford University, and then with a larger team formed when the authors joined Sun Microsystems Laboratories in 1991. Self was designed to help programmers become more productive and creative by giving them a simple, pure, and powerful language, an implementation that combined ease of use with high performance, a user interface that off-loaded cognitive burden, and a programming environment that captured the malleability of a physical world of live objects. Accomplishing these goals required innovation in several areas: a simple yet powerful prototype-based object model for mainstream programming, many compilation techniques including customization, splitting, type prediction, polymorphic inline caches, adaptive optimization, and dynamic deoptimization, the application of cartoon animation to enhance the legibility of a dynamic graphical interface, an object-centered programming environment, and a user-interface construction framework that embodied a uniform use-mention distinction. Over the years, the project has published many papers and released four major versions of Self.Although the Self project ended in 1995, its implementation, animation, user interface toolkit architecture, and even its prototype object model impact computer science today (2006). Java virtual machines for desktop and laptop computers have adopted Self's implementation techniques, many user interfaces incorporate cartoon animation, several popular systems have adopted similar interface frameworks, and the prototype object model can be found in some of today's languages, including JavaScript. Nevertheless, the vision we tried to capture in the unified whole has yet to be achieved.},
  booktitle = {Proceedings of the Third ACM SIGPLAN Conference on History of Programming Languages},
  xxpages = {9–1--9–50},
  keywords = {virtual machine, prototype-based programming language, programming environment, object-oriented language, morphic, history of programming languages, exploratory programming, dynamic optimization, dynamic language, cartoon animation, adaptive optimization, Self},
  location = {San Diego, California},
  series = {HOPL III},
  note={.
    Section 4.2 notably describes the failure of their “sender path” attempt at multiple inheritance,
    after which they revert to the “conflict” paradigm.
  }
}

% NB: Extended version of the seminal 2005 TOPLAS paper.
% For a history of lenses, see Jules Hedges' https://julesh.com/2018/08/16/lenses-for-philosophers/
@Article{Foster2007CombinatorsFB,
  title={Combinators for bidirectional tree transformations: A linguistic approach to the view-update problem},
  author={Nate Foster and M. Greenwald and J. T. Moore and B. Pierce and A. Schmitt},
  journal={ACM Trans. Program. Lang. Syst.},
  year={2007},
  volume={29},
  url={https://www.cis.upenn.edu/~bcpierce/papers/lenses-full.pdf}
}

%% 2008

@book{OSullivan2008RWH,
  title={Real World Haskell},
  author={O'Sullivan, Bryan and Goerzen, John and Stewart, Donald Bruce},
  year={2008},
  publisher={O'Reilly Media},
  doi={10.5555/1523280},
  url={https://book.realworldhaskell.org/},
  note={.
    This book demonstrates how Haskell by 2008 had grown into a practical language
    usable to write “Real World” applications.
  }
}

@article{bracha2008newspeak,
  title={The Newspeak Programming Platform},
  author={Bracha, Gilad and Ahe, Peter and Bykov, Vassili and Kashai, Yaron and Miranda, Eliot},
  journal={Cadence Design Systems},
  year={2008},
  url={https://bracha.org/newspeak.pdf}
}

% Master Thesis. BCL
@TechReport{gclviewer2008,
  Author = "Ibrahim Bokharouss",
  Title = "GCL Viewer: a study in improving the understanding of GCL programs",
  Institution = {Eindhoven University of Technology},
  year = 2008,
  url = {https://research.tue.nl/en/studentTheses/gcl-viewer}
  }
% https://pure.tue.nl/ws/portalfiles/portal/46927079/638953-1.pdf

@InProceedings{dolstra2008nixos,
  title={NixOS: A purely functional Linux distribution},
  author={Dolstra, Eelco and L{\"o}h, Andres},
  booktitle={the 13th ACM SIGPLAN international conference on Functional programming},
  pages={367--378},
  year={2008},
  url={https://edolstra.github.io/pubs/nixos-jfp-final.pdf}
}

@webpage{Minsky2008,
  author = {Yaron Minsky},
  title = {The {ML} sweet spot},
  year = 2008,
  month = April,
  url = {https://blog.janestreet.com/the-ml-sweet-spot/},
  lastchecked = {2021-03-14}
}

@book{eopl3,
  author = {Friedman, Daniel P. and Haynes, Christopher T. and Wand, Mitchell},
  title = {Essentials of Programming Languages},
  edition = {3rd},
  year = {2008},
  publisher = {Massachusetts Institute of Technology},
  address = {USA},
  url = {https://www.eopl3.com/},
  isbn = {978-0-262-06279-4},
  doi = {10.5555/1378240},
  note={.
    EOPL is a great classic about Programming Languages.
    However, its chapter on OO only has classes with single inheritance.
    EOPL barely touches multiple inheritance, “powerful, but … problematic”, in exercise 9.26,
    and prototypes in exercise 9.27-9.29. Disappointing on the OO front.
  }
}

@book{PLAI,
  author = {Shriram Khrisnamurthi},
  title = {Programming Languages: Application and Interpretation},
  edition = {1st},
  year = {2008},
  publisher = {Massachusetts Institute of Technology},
  address = {USA},
  url = {https://plai.org/},
  note = {.
    This is a great book about Programming Languages in general, and I love SK.
    SK introduces objects as closures, and even prototypes, in chapter 10.
    But one thing he just doesn’t get is multiple inheritance (10.3.3).
    In 10.3.5 he introduces mixins as a mechanism on top of first-class single-inheritance classes,
    which certainly works, but to me feels like putting the cart before the ox.
    Great stuff outside OO, and even the OO is decent,
    but in the end, like many academics, SK doesn’t grok OO.
  }
}

%% 2009

@InProceedings{Brown_functioninheritance:,
  author = {Daniel Brown and William R. Cook},
  title = {Function Inheritance: Monadic Memoization Mixins},
  booktitle = {Brazilian Symposium on Programming Languages},
  year = {2009},
}

@InProceedings{Cook2009,
  author={William Cook},
  title={On Understanding Data Abstraction, Revisited},
  year=2009,
  doi={10.1145/1640089.1640133},
  url={https://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf},
  year = {2009},
  isbn = {9781605587660},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  booktitle = {Proceedings of the 24th ACM SIGPLAN Conference on Object Oriented Programming Systems Languages and Applications},
  pages = {557–572},
  numpages = {16},
  keywords = {ADT, abstract data type, class, object},
  location = {Orlando, Florida, USA},
  series = {OOPSLA '09},
  note={.
    Cook in 3.1 notes the OO (re)presentation eschews the existential type,
    hiding it under a higher-order function interface,
    but that's false in general—the existential type is there for compatibility
    between values you can build and modify.
    3.2 claims with reference to his thesis that inheritance is orthogonal to OO (!)
    but misses that what makes method invocation “dynamic binding”
    isn’t the records of higher-order functions, but the open recursion on self
    and the sharing of methods between multiple selves thanks to inheritance.
    He also identifies classes as their constructor… a nice implementation trick
    in simple OO languages that does not cover the general case of OO.
    3.3 Cook wrongfully calls “autognosis” (a word that implies runtime reflection)
    the criterion what Bracha calls “Pure OO”, i.e. having all access go through interfaces.
    Cook wholly skips CLOS, and Prototypes. Sad.
    In the end, does not bring much lights to the topic, beyond the obvious.
    Cook understands modularity, but not extensibility.
  }
}

@Unpublished{MonadsMixins,
  title = "The Different Aspects of Monads and Mixins",
  author = "Oliveira, Bruno C. d. S.",
  year = {2009},
  url = {https://www.cs.ox.ac.uk/publications/publication2965-abstract.html}
}

% Recursion Scheme, FP & OOP ???
@article{gibbons2009essence,
  title={The essence of the iterator pattern},
  author={Gibbons, Jeremy and Oliveira, Bruno C d S},
  journal={Journal of functional programming},
  volume={19},
  number={3-4},
  pages={377--402},
  year={2009},
  publisher={Cambridge University Press}
}

%% 2010

@InProceedings{Oliveira10effectiveadvice,
  author = {Oliveira, Bruno C. d. S. and Schrijvers, Tom and Cook, William R.},
  title = {EffectiveAdvice: disciplined advice with explicit effects},
  booktitle = {AOSD’10: 9th International Conference on Aspect-Oriented Software Development},
  pages = {109--120},
  year = {2010}
}

@InProceedings{ASDF2,
  author = {François-René Rideau and Robert Goldman},
  title = {Evolving ASDF: More Cooperation, Less Coordination},
  year = {2010},
  booktitle = {International Lisp Conference},
  url = {http://common-lisp.net/project/asdf/doc/ilc2010draft.pdf}
}

@Webpage{OOP2010,
  title={Ralph Johnson, Joe Armstrong on the State of OOP (Interview at QCon)},
  author={Ralph Johnson and Joe Armstrong},
  year={2010},
  url={https://www.infoq.com/interviews/johnson-armstrong-oop/}
}

%% 2011

% From the Fortress team
@InProceedings{allen2011type,
  title={Type checking modular multiple dispatch with parametric polymorphism and multiple inheritance},
  author={Allen, Eric and Hilburn, Justin and Kilpatrick, Scott and Luchangco, Victor and Ryu, Sukyoung and Chase, David and Steele, Guy},
  booktitle={OOPSLA},
  pages={973--992},
  doi={10.1145/2048066.2048140},
  year={2011},
  url={https://people.mpi-sws.org/~skilpat/papers/multipoly.pdf},
  note={.
    A great paper that shows how to properly type multiple dispatch and multiple inheritance together,
    with a very interesting concept of runtime kin vs compile-time types.
    And yet, at some point the paper becomes too formal and I admit I don’t follow it anymore
    to tell what is missing or what is there that I’m missing.
    One day when I get serious about typesystems,
    I shall surely re-read this paper and try to fully understand it.
    In the meantime, I have complete trust in Guy Steele, and will therefore assume that
    the paper correctly achieves what it says it did, and provides a constructive proof
    that indeed the problem of typing multimethods is solved.
  }
}

%% 2012

@InProceedings{Gabriel2012,
  title={The Structure of a Programming Language Revolution},
  author={Richard P. Gabriel},
  booktitle={Proceedings of the ACM international symposium on New ideas, new paradigms, and reflections on programming and software},
  pages={195--214},
  year={2012},
  url={https://www.dreamsongs.com/Files/Incommensurability.pdf},
  note={.
    A magnificent paper that discusses how different people think about software
    (and everything else) in often incommensurable paradigms.
    In the illustrative example,
    old timers and Lispers approach programming with a “system” paradigm,
    whereas the academic and industrial mainstream since sometime in the 1980s
    has a very different “language” paradigm.
    Interestingly, the paper it rightfully excoriates
    for its authors’ paradigmatic misunderstanding of OO due to their language paradigm,
    is also one of the best papers on the semantics of OO, the Bracha & Cook 1990.
    I suspect it was Cook who wrote the more paradigmatically foreign parts of the paper,
    for I personally know Bracha to very much follow the system paradigm
    (see his beautiful work on Newspeak).
    He still wrongly believes mixin inheritance to be more modular than multiple inheritance, though.
  }
}

@webpage{oconnor2012lenses,
  author={Russell O’Connor},
  title={Polymorphic Update with van Laarhoven Lenses},
  year={2012},
  month={June},
  day={23},
  url={http://r6.ca/blog/20120623T104901Z.html},
  lastchecked={2025-12-01},
  note={
    Classic essay on functional lenses.
  }
}

@InProceedings{LIL2012,
  author = {François-René Rideau},
  title = {LIL: CLOS Reaches Higher-Order, Sheds Identity and has a Transformative Experience},
  url = "http://github.com/fare/lil-ilc2012/",
  booktitle = {International Lisp Conference},
  year = 2012
}

% My replies: https://twitter.com/Ngnghm/status/1791988260266234028
% XXXX UPDATE ENTRY
@Webpage{Cook2012,
  author={William Cook},
  title={A Proposal for Simplified, Modern Definitions of "Object" and "Object Oriented"},
  url={https://wcook.blogspot.com/2012/07/proposal-for-simplified-modern.html},
  year=2012,
  note={.
    Cook delivers lots of precise insight in OO, that show a deep familiarity with the subject
    that few ever possessed, and can much enlighten his readers.
    Then, at crucial times, in the most sophisticated way, he totally misses the point.
    For instance, he claims that “dynamic dispatch of operations is
    the essential characteristic of objects”. But no, all that means is that the object is
    _first-class_, which was the topic of his previous section, yet he failed to notice.
    And being first-class is not specific to OO.
    Maybe Cook’s note on “dynamic dispatch” tells us something important
    about most Class OO languages:
    that despite inheritance happening on second-class entities (classes),
    dispatch still happens on first-class entities (objects).
    Yet Haskell typeclasses show that need not be always the case
    (though in Haskell you can explicitly use Data.Typeable class constraint
    to enable runtime dispatch).
    Now, when Cook claims that inheritance is “useful but not absolutely essential" for OO:
    that's where he loses track of the plot.
    As for 2012 JavaScript (before classes), it _was_ OO already, because it had inheritance.
    What makes OO is inheritance, not existentially-quantified types.
    Cook claims that “inheritance can also be used for… extending ML-style modules”.
    Did he even try??? I did, it doesn’t type.
    “Delegation is the dynamic analog of inheritance, which is usually defined statically.”
    So close to the truth: “delegation”, i.e. inheritance among first-class entities
    (see our section on delegation), is the one and only inheritance that matters,
    it’s just that most people somehow only use it at the type-level
    for ultra restricted metaprogramming.
    The paragraph on "classes" is so right it what little it says, and
    so wrong for being so short—there's an entire topic deserving to be deepened there!
    It's a shame that Cook never took Prototypes seriously except as a short counter-example.
    Telling: he never even says the word!
  }
}

%% 2013

% extended abstract with idiotic proof-by-citation of abdelgawad2014domain
@InProceedings{Cartwright2013Inheritance,
  title={Inheritance IS Subtyping},
  author={Cartwright, Robert and Moez, A AbdelGawad},
  booktitle={The 25th Nordic Workshop on Programming Theory (NWPT)},
  year={2013},
  url={https://cs.rice.edu/~javaplt/papers/Inheritance.pdf},
  note={.
    Lots of handwaving for what is in the but the NNOOTT combined with
    a lack of appreciation for the many previous works that went beyond it,
    some of which is cited. Refers to AbdelGawad 2014 for actual content.
  }
}

%% 2014

% Unsurprisingly, his NOOP is plain NNOOTT.
% No generics, no open recursion, no higher-order functions, all nominal.
% He thanks bpierce for feedback.
@article{abdelgawad2014domain,
  title={A domain-theoretic model of nominally-typed object-oriented programming},
  author={AbdelGawad, Moez A},
  journal={Electronic Notes in Theoretical Computer Science},
  volume={301},
  pages={3--19},
  year={2014},
  doi={10.1016/j.entcs.2014.01.002},
  publisher={Elsevier},
  note={
    The author falls deep into the NNOOTT without realizing it.
    It is more sad than funny to see a young researcher “discover” sixty years later
    as if they were new the naive ideas that our forefathers had when they first
    stumbled upon OO, and dismiss without truly understanding it
    the research that he is citing.
    He is first responsible for his own failing, but
    his publications also reflect poorly on his advisors.
  }
}

@book{Chiusano2014FPScala,
  title={Functional Programming in Scala},
  author={Chiusano, Paul and Bjarnason, Rúnar},
  year={2014},
  publisher={Manning Publications},
  doi={10.5555/2688794},
  isbn={9781617290657},
  url={Standard/official URL (publisher page): https://www.manning.com/books/functional-programming-in-scala},
  note={.
    The authors, core contributors to the ScalaZ library,
    show how to write pure functional programs in Scala.
    ScalaZ uses multiple inheritance to encode mathematical relationships between abstractions
    (like “every monad is a functor”) in the style of Haskell typeclasses,
    not to build traditional stateful imperative object-oriented class hierarchies.
  }
}

@webpage{jsonnet,
  author={Dave Cunningham},
  title={Jsonnet},
  year=2014,
  url={https://jsonnet.org},
  lastchecked={2021-03-11},
  note={.
    Dave took the Google Configuration Language (GCL),
    reduced it to its core concepts,
    rightfully replaced dynamic scoping by lexical scoping,
    and used a syntax in between JavaScript and Python,
    resulting in a beautiful pure functional lazy dynamic language
    with builtin first-class Prototype OO.
    Semantically equivalent to Nix, with a nicer syntax,
    but little tooling and a small ecosystem
    (Dave sadly never got much support from his then employer Google).
    Learning Jsonnet then Nix was key to making me understand OO at long last.
  }
}

@webpage{MythOfRAM2014,
  author    = {Emil Ernerfeldt},
  title     = {The Myth of RAM},
  year      = {2014},
  month     = {April},
  day       = {21},
  url       = {https://www.ilikebigbits.com/2014_04_21_myth_of_ram_1.html},
  lastchecked = {2025-12-01},
  note={.
    These blog posts explain why physics constraints random memory access
    to be actually in O(√N) rather than O(1), where N is the size of the working set.
    The “memory hierarchy” of caches, RAM, disk, remote storage, etc.,
    makes for discrete jumps in latency as you exceed local capacity.
    The ultimate physical limit is ultimately a square root rather than cubic root
    to avoid collapsing into a blackhole.
  }
}

% InProceedings
@Misc{ASDF3,
  author = {François-René Rideau},
  title = {ASDF 3, or Why Lisp is Now an Acceptable Scripting Language},
  url = "https://github.com/fare/asdf3-2013",
  booktitle = {European Lisp Symposium},
  year = 2014
}

%% 2015

@Book{EcmaScript2015,
  added-at = {2015-08-28T15:36:26.000+0200},
  address = {Geneva},
  author = {{Ecma International}},
  biburl = {https://www.bibsonomy.org/bibtex/28d67e2ebf933f3b6f684fcfb1f53b020/gron},
  edition = {6th},
  keywords = {JavaScript spec specification},
  month = {June},
  title = {{ECMAScript 2015 Language Specification}},
  url = {http://www.ecma-international.org/ecma-262/6.0/ECMA-262.pdf},
  year = 2015,
  note={.
    ECMAScript is the official name of the standard everyone more or less follows for JavaScript.
    This 2015 version introduces ECMAScript 6, that includes
    many improvements over previous versions, including a builtin notion of classes,
    when the only form of OO previously was prototypes.
  }
}

@Misc{nix2015,
  title={Nixpkgs fixed-points library},
  author={Peter Simons},
  url={https://github.com/NixOS/nixpkgs/blob/master/lib/fixed-points.nix},
  year={2015},
  urldate={2023-11-29},
  note={.
    Nix implements prototype OO in two functions. Impressive.
    Seeing that after having used Jsonnet (that implements an equivalent object system
    the hard way in C++) is what made OO click for me.
    Peter doesn’t call his extension system “OO” and didn’t know about Prototype OO
    when he wrote that (but had been influenced by others who did);
    but his extensions are used exactly like objects are in Jsonnet,
    for sensibly the same purposes—configuring complex systems in a modular extensible way.
  }
}

@Article{Guha2015EssenceJS,
  author    = {Arjun Guha and
               Claudiu Saftoiu and
               Shriram Krishnamurthi},
  title     = {The Essence of JavaScript},
  journal   = {CoRR},
  volume    = {abs/1510.00925},
  year      = {2015},
  url       = {http://arxiv.org/abs/1510.00925},
  archivePrefix = {arXiv},
  eprint    = {1510.00925},
  timestamp = {Mon, 13 Aug 2018 16:46:22 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/GuhaSK15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  note={.
    This article is great in desugaring the prototype sublanguage of JS,
    but doesn't cover classes.
  }
}

%% 2016

@Misc{grigore2016javagenericsturingcomplete,
      title={Java Generics are Turing Complete},
      author={Radu Grigore},
      year={2016},
      eprint={1605.05274},
      archivePrefix={arXiv},
      primaryClass={cs.PL},
      url={https://arxiv.org/abs/1605.05274},
}

@Misc{ngnghm9,
  author = {François-René Rideau},
  title = {Build Systems and Modularity},
  year = 2016,
  url = {https://ngnghm.github.io/blog/2016/04/26/chapter-9-build-systems-and-modularity/},
  urldate = {2023-11-29}
}


% https://x.com/Ngnghm/status/1988891187340615763
@incollection{EssenceOfInheritance2016,
  title={The Essence of Inheritance},
  author={Black, Andrew P and Bruce, Kim B and Noble, James},
  booktitle={A List of Successes That Can Change the World: Essays Dedicated to Philip Wadler on the Occasion of His 60th Birthday},
  pages={73--94},
  year={2016},
  publisher={Springer},
  doi={10.48550/arXiv.1601.02059},
  url={https://sci-hub.ru/https://link.springer.com/chapter/10.1007/978-3-319-30936-1_4},
  note={.
    The paper vainly tries to convince Philip Wadler
    of how inheritance can help better define software,
    by using two lengthily elaborated examples, respectively based on
    the "expression problem" and extending Erlang code.
    I appreciate the authors and their attempt, but I find the paper too handwavy,
    too accepting of complexity, ineffable semantics.
    The paper lacks an ambition of clear knowledge.
    The authors also have the usual conflict mistreatment of multiple inheritance.
    I love and respect all the authors, and Wadler, but, maybe due to the Paradigm discrepancy
    noticed by Gabriel, they all seem unable understand some key issues about OO—even
    though they are specialists in the field!
  }
}

% https://github.com/namin/dot
% https://namin.seas.harvard.edu/pubs/fool-dot.pdf
% More co-authors
@InProceedings{Amin2016DependentOT,
  title={Dependent Object Types},
  author={Nada Amin, Adriaan Moors, Martin Odersky},
  year={2016},
  url={https://api.semanticscholar.org/CorpusID:265751928}
}

% https://sci-hub.ru/https://link.springer.com/article/10.1007/BF01178920
% Review of object inheritance for prototypes.
% Discusses multiple inheritance, but fails to cite Ani, ThingLab, T, Slate, Sheeple.
% Only passingly discusses super linearization or mixin inheritance. Sad.
@InProceedings{oiwc2016,
  author =	{Jones, Timothy and Homer, Michael and Noble, James and Bruce, Kim},
  title =	{{Object Inheritance Without Classes}},
  booktitle =	{30th European Conference on Object-Oriented Programming (ECOOP 2016)},
  pages =	{13:1--13:26},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-014-9},
  ISSN =	{1868-8969},
  year =	{2016},
  volume =	{56},
  editor =	{Krishnamurthi, Shriram and Lerner, Benjamin S.},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2016.13},
  URN =		{urn:nbn:de:0030-drops-61077},
  doi =		{10.4230/LIPIcs.ECOOP.2016.13},
  annote =	{Keywords: Inheritance, Objects, Classes, Operational semantics}
}

@webpage{GerbilScheme,
  author={Dimitris Vyzovitis},
  title={Gerbil Scheme},
  year=2016,
  url={https://cons.io/},
  lastchecked={2025-04-06}
}

%% 2017

@Article{Pickering2017Optics,
  title={Profunctor Optics: Modular Data Accessors},
  volume={1},
  ISSN={2473-7321},
  url={http://dx.doi.org/10.22152/programming-journal.org/2017/1/7},
  DOI={10.22152/programming-journal.org/2017/1/7},
  number={2},
  journal={The Art, Science, and Engineering of Programming},
  publisher={Aspect-Oriented Software Association (AOSA)},
  author={Pickering, Matthew and Gibbons, Jeremy and Wu, Nicolas},
  year={2017},
  month={Apr}
}

% https://lmcs.episciences.org/4319
% This paper seems to be on the right track, but with much extra formalism and much missing insight.
% Classes add a layer of complexity, and I think there may be bugs. Sigh.
@article{DBLP:journals/corr/abs-1712-06906,
  author       = {Jan Bessai and
                  Tzu{-}Chun Chen and
                  Andrej Dudenhefner and
                  Boris D{\"{u}}dder and
                  Ugo de'Liguoro and
                  Jakob Rehof},
  title        = {Mixin Composition Synthesis based on Intersection Types},
  journal      = {CoRR},
  volume       = {abs/1712.06906},
  year         = {2017},
  url          = {http://arxiv.org/abs/1712.06906},
  eprinttype    = {arXiv},
  eprint       = {1712.06906},
  timestamp    = {Sat, 30 Sep 2023 10:08:07 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-1712-06906.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

%% 2018

@InProceedings{Rideau2018Climbing,
  author={François-René Rideau},
  title={Climbing Up the Semantic Tower --- at Runtime},
  booktitle={Off the Beaten Track Workshop at POPL},
  month={January},
  year={2018},
  url={https://github.com/fare/climbing}
}

@Unpublished{FarePhD,
  Author={François-René Rideau},
  Title={Reconciling Semantics and Reflection},
  School={Telecom Paristech},
  Year={2018},
  url={https://bit.ly/FarePhD},
  Note={Unpublished because undefended.
    First draft completed in 2018, yet still not in a publishable state as of 2025.
  }
}

%% 2020

% Withhold citation until after deanomization
@Misc{GerbilPOOwithheld,
  author = {Author withheld},
  title = {Title withheld},
  url = {https://github.com/repository/withheld},
  year = 2020
}

@webpage{GerbilPOO,
  author = {François-René Rideau},
  title = {Gerbil-POO},
  year = 2020,
  url = {https://github.com/fare/gerbil-poo},
  lastchecked = {2021-04-06}
}

@Misc{Kay2020,
  title={What thought process would lead one to invent Object-Oriented Programming?},
  author={Alan Kay},
  year={2020},
  url={https://www.quora.com/What-thought-process-would-lead-one-to-invent-object-oriented-programming/answer/Alan-Kay-11}
}

%% 2021

% Maybe cite the last episode of this story instead, that explains the concept?
% https://en.wikipedia.org/wiki/Earthshock
% On citing TV series:
% https://www.easybib.com/guides/citation-guides/how-do-i-cite-a/how-to-cite-movie-tv-netflix/
@Webpage{DrWhoFPIT,
  author={Unknown},
  title={Fixed Point in Time},
  year=2021,
  url={https://tardis.fandom.com/wiki/Fixed_point_in_time},
  lastchecked={2021-03-14}
}

@Webpage{WikiC3,
  title = "C3 linearization",
  author = "Wikipedia",
  year = 2021,
  url = {https://en.wikipedia.org/wiki/C3_linearization},
}
@InProceedings{poof2021,
  title = {Prototypes: Object-Orientation, Functionally},
  author = {François-René Rideau and Alex Knauth and Nada Amin},
  year = {2021},
  booktitle = {Scheme and Functional Programming Workshop},
  url = {https://github.com/metareflection/poof},
}

% Adding POP to Nixpkgs:
% https://github.com/NixOS/rfcs/pull/91/
% https://github.com/NixOS/nixpkgs/pull/116275
% https://github.com/divnix/POP
@Webpage{POP2021,
  author =       {François-René Rideau},
  title =        {Pure Object Prototypes},
  url =          {https://github.com/divnix/POP},
  year =         {2021}
}

@article{Prykhodko2021DIT,
  author={Prykhodko, Sergiy and Prykhodko, Natalia and Tatiana, Smykodub},
  year={2021},
  month={06},
  pages={159-172},
  title={A Statistical Evaluation of The Depth of Inheritance Tree Metric for Open-Source Applications Developed in Java},
  volume={46},
  journal={Foundations of Computing and Decision Sciences},
  doi={10.2478/fcds-2021-0011}
}

%% 2022

@Webpage{TopPL2022,
  author={GitHub},
  title={The top programming languages},
  url={https://octoverse.github.com/2022/top-programming-languages},
  year=2022,
  lastchecked={2024-01-04}
}

%% 2025

@Webpage{WikiProto,
  title="Prototype-based programming",
  author="Wikipedia",
  year=2025,
  url={https://en.wikipedia.org/wiki/Prototype-based_programming},
}

% References Butler Lampson https://bwlampson.site/Slides/TuringLecture.htm
% "We can solve any problem by introducing an extra level of indirection"
@Webpage{WikiFTSE,
  title = "Fundamental theorem of software engineering",
  author = "Wikipedia",
  year = 2025,
  url = {https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering},
}

%% UNCLASSIFIED

%%% TODO: Add the following...

% Conway's Law
% Conway, Melvin (1968). "How do committees invent" (PDF). Datamation: 28–31.

% Wegner Zdonik "Inheritance as an incremental modification mechanism or what Like is or isn't like" 1988

% Bracha and Lindstrom 1992 Modularity meets inheritance

% 2000 Oleg Kiselyov USENET post on okmij.org on the possibility of a pure variant of YASOS ?

% Featherweight Jigsaw - Replacing inheritance by composition in Java-like languages
% https://dl.acm.org/doi/10.1016/j.ic.2012.02.004

% C++ template lambda calculus https://gist.github.com/glaebhoerl/8970f682958826ed36f9

% Hewitt, Carl, Viewing Control Structures as Patterns of Passing Messages, MIT AI Lab Memo 410, Dec 1976.

% Gilad Bracha's Newspeak? It's class-based only, though.

% C2 wiki?
% https://wiki.c2.com/?PrototypeBasedProgramming
% https://wiki.c2.com/?ClassesPrototypesComparison
% https://wiki.c2.com/?PrototypeBasedLanguage
% "Popular" Prototype language: NewtonScript, LambdaMOO, Io, REBOL, Lua...

% https://okmij.org/ftp/Computation/typeclass.html#Kaes

% Kaes ESOP 1988
% Stefan Kaes: Parametric overloading in polymorphic programming languages
%Proc. ESOP 1988, Springer's LNCS 300, pp. 131-144
% <http://link.springer.com/chapter/10.1007%2F3-540-19027-9_9>

% Stefan Kaes: Parametrischer Polymorphismus, Ueberladungen und Konversionen
% Dissertation: TU Darmstadt, Fachbereich Informatik, 2005
% <http://tuprints.ulb.tu-darmstadt.de/epda/000544/>

% A History of Haskell: being lazy with class
% Simon Peyton Jones
% The Third ACM SIGPLAN History of Programming Languages Conference (HOPL-III) | June 2007
% https://www.microsoft.com/en-us/research/publication/a-history-of-haskell-being-lazy-with-class/

% http://okmij.org/ftp/Computation/Subtyping/

% Barak Pearlmutter & Kevin Lang's Oaklisp https://github.com/barak/oaklisp

% Look at papers that cite Bracha 1990 on Semantic Scholar, including:
% https://www.semanticscholar.org/paper/Function-Inheritance-%3A-Monadic-Memoization-Mixins-Brown-Cook/d2bf5dc5c6c6bff91d10a0e2dceaaa13c2064765
% https://www.semanticscholar.org/paper/Object-Inheritance-Without-Classes-Jones-Homer/3dbc00e08dd1fa7c29faae9b2da544fb7e8d5579

% Modularity: ch4 and ch9 of taoup, e.g. http://www.catb.org/~esr/writings/taoup/html/ch04s02.html#orthogonality
% Semantics and Types for Objects with First-Class Member Names
% Joe Gibbs Politz, Arjun Guha, Shriram Krishnamurthi
% Foundations of Object-Oriented Languages, 2012
% https://cs.brown.edu/~sk/Publications/Papers/Published/pgk-sem-type-fc-member-name/

% Erik Ernst's work on gBeta:
% https://www.researchgate.net/publication/2806012_gbeta_-_a_Language_with_Virtual_Attributes_Block_Structure_and_Propagating_Dynamic_Inheritance

% Design Rules: The Power of Modularity,  by Baldwin & Clark

% Dart Book, by Gilad Bracha, Section 2.15 on mixins + examples all around, 5.9 on modularity

% CUE rejects inheritance, instead has value/pattern unification along a lattice: https://cuelang.org/docs/concepts/logic/

% https://www.piumarta.com/software/id-objmodel/objmodel2.pdf
% OOPSLA07

% Classes vs. Prototypes - Some Philosophical and Historical Observations
% Antero Taivalsaari • Journal of Object-Oriented Programming • Published 1996
% https://citeseerx.ist.psu.edu/doc_view/pid/30fcb7807ce73f16222761b97e36154f12349efb
% Indeed very philosophical with not enough computer science

% Jonathan Aldritch "The Power of Interoperability: Why Objects are Inevitable" Onward! 1993

% Zhang, Sun, Oliveira "Compositional Programming" TOPLAS 2021

% CECIL also had prototype inheritance / classless objects
% A cursory look at the manual does not mention mutable parents, however

% Guy Steele "Objects have not failed" 2002 https://www.dreamsongs.com/ObjectsHaveNotFailedNarr.html

% Luc Steels "An Applicative View of OOP" 1982

% 2003  Tom Hirschowitz  Call-by-value mixin modules
% https://hirschowitz.pages.math.cnrs.fr/phd/these-tom.pdf
% https://hirschowitz.pages.math.cnrs.fr/

% https://www.quora.com/Why-is-functional-programming-seen-as-the-opposite-of-OOP-rather-than-an-addition-to-it/answer/Henry-Story

% https://people.mpi-sws.org/~rossberg/mixml/
% Andreas Rossberg, Derek Dreyer. Mixin' Up the ML Module System. TOPLAS 35(1), 2013. Revised and significantly extended version of the ICFP paper, including material from the appendices and a lot more.
% Derek Dreyer, Andreas Rossberg. Mixin' Up the ML Module System. ICFP, 2008.
% Derek Dreyer, Andreas Rossberg. Mixin' Up the ML Module System (Extended Mix). Expanded version including technical appendices, 2008.

% More digging on the origins of OO:
% https://x.com/Ngnghm/status/1898493837040849348

% B. Jacobs, Coalgebraic Reasoning about Classes in Object-Oriented Languages. Electr. Notes in Theor. Comp. Sci. 11, 1998. (Special issue on the workshop Coalgebraic Methods in Computer Science (CMCS 1998))

% Peter Wegner. Concepts and Paradigms of O..O..P.. 1990

% Goguen...

% change-class: https://github.com/shriram/plai-public/issues/60

% Bob Harper PFPL existential types / inversion of scope

% Gilad recommends about Inheritance Hierarchies:
% Ossher and Harrison's "Combination of Inheritance Hierarchies' from OOPSLA 1992.

% Category theory:

% Category Theory in Programming
% Noah Ma <noahstorym@gmail.com>
% https://docs.racket-lang.org/ctp/index.html

% Cardelli Wegner 1985

% See this article and its bibliography? https://scholarworks.iu.edu/iuswrrest/api/core/bitstreams/2706b860-ef5e-42b9-98c6-f29e3486220e/content

% cite Douglas Engelbart's 1968 mother of all demos

% https://www.jot.fm/contents/issue_2017_02/article2.html

% https://www.dreamsongs.com/Files/LASC-Overview.pdf
% The Common Lisp Object System by Linda G. DeMichiel

% Does Yaohan Chu introduce the concept of HLL, or is it earlier?
% https://dl.acm.org/doi/pdf/10.1145/800181.810257

% 2024 Stephen H. Kaisler
% Medley LOOPS: The Basic System
% a.k.a. "Lisp Object-Oriented Programming System (LOOPS) Volume I: The Basic System"

% https://www.jot.fm/issues/issue_2005_01/column2/

% Jonathan Aldrich workshop paper on capability-safe reflection and an ECOOP on modular reasoning in aspect-oriented programming (the latter a bit dated now).

% https://github.com/fogus/lang-genealogy

% https://research.scheme.org/lambda-papers/
