%%% Bibliography, roughly sorted by year of publication
% (See TODO at the end for more)

% Full text p.666 of https://www.google.fr/books/edition/Scientific_Memoirs_Selected_from_the_Tra/qsY-AAAAYAAJ?hl=en&gbpv=1&dq=Scientific+Memoirs+Selected+from+the+Transactions+of+Foreign+Academies+of+Science+and+Learned+Societies&printsec=frontcover
% https://x.com/Ngnghm/status/1940199868037046726
% From https://www.netlib.org/bibnet/authors/l/lovelace-ada-augusta.html
% InCollection
@Misc{Lovelace:1843:NTL,
  author =       "Augusta Ada Lovelace",
  booktitle =    "Richard Taylor's Scientific Memoirs",
  title =        "Notes [on translation of {Luigi Federico Menebrae}'s
                 paper on {Babbage's Analytical Engine}]",
  pages =        "666--731",
  month =        August,
  year =         "1843",
  bibsource =    "https://www.math.utah.edu/pub/bibnet/authors/l/lovelace-ada-augusta.bib;
                 https://www.math.utah.edu/pub/tex/bib/adabooks.bib",
  note =         "Translation to English, with notes about three times
                 the length of the original French article, of
                 \cite{Menabrea:1842:NMA}. See \cite[pages
                 260--282]{Woolley:1999:BSR} and \cite[pages
                 162--164]{Swade:2001:DEC} for accounts of how those
                 notes were written, and despite vigorous opposition
                 from Charles Babbage \cite{Babbage:1843:AMM}, finally
                 published in this book. The author was listed only as
                 the initials `A. A. L.', because it was then considered
                 inappropriate for a woman, particularly one of high
                 rank, to author a scientific paper.",
  acknowledgement = ack-nhfb,
  author-dates = "Ada Augusta King, Countess of Lovelace (10 December
                 1815--27 November 1852)",
  remark =       "Luigi Menebrae went on to become Prime Minister of the
                 newly-unified Italy.",
  xxnote =       "Check publication information: need to locate original
                 source!",
  url = {https://www.google.com/books/edition/Scientific_Memoirs_Selected_from_the_Tra/qsY-AAAAYAAJ?gbpv=1&pg=PA666}
}

@book{dumas1844,
  author={Alexandre Dumas},
  title={Les Trois Mousquetaires},
  year={1844},
  note={This novel, despite being named "The Three Musketeers",
        has four musketeers as protagonists.}
}

% About the Burroughs B5000
% Push-down stack, memory location independence,
% "right-hand Polish notation" later used by FORTH!
@article{lonergan1961,
  author = {Lonergan, William M. and King, Paul A.},
  title = {Design of the B5000 System},
  journal = {Datamation},
  volume = {7},
  number = {5},
  pages = {28--32},
  year = {1961}
}

% Architect of the Burroughs B5000
@inproceedings{barton1961,
  author = {Barton, R. S.},
  title = {A New Approach to the Functional Design of a Digital Computer},
  year = {1961},
  isbn = {9781450378727},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1460690.1460736},
  doi = {10.1145/1460690.1460736},
  abstract = {The present methods of determining the functional design of computers are critically reviewed and a new approach proposed. This is illustrated by explaining, in abstracted form, part of the control organization of a new and different machine based, in part, on the ALGOL 60 language. The concepts of expression and procedure lead directly to use of a Polish string program. A new arrangement of control registers results, which provides for automatic allocation of temporary storage within expressions and procedures, and a generalized subroutine linkage.The simplicity and power of these notions suggests that there is much room for improvement in present machines and that more attention should be given to control functions in new designs.},
  booktitle = {Papers Presented at the May 9-11, 1961, Western Joint IRE-AIEE-ACM Computer Conference},
  pages = {393–396},
  numpages = {4},
  location = {Los Angeles, California},
  series = {IRE-AIEE-ACM '61 (Western)}
}

@inproceedings{sketchpad1963,
  author = {Ivan E. Sutherland},
  title = {Sketchpad: A Man-Machine Graphical Communication System},
  year = {1963},
  isbn = {9781450378802},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1461551.1461591},
  doi = {10.1145/1461551.1461591},
  abstract = {The Sketchpad system makes it possible for a man and a computer to converse rapidly through the medium of line drawings. Heretofore, most interaction between man and computers has been slowed down by the need to reduce all communication to written statements that can be typed; in the past, we have been writing letters to rather than conferring with our computers. For many types of communication, such as describing the shape of a mechanical part or the connections of an electrical circuit, typed statements can prove cumbersome. The Sketchpad system, by eliminating typed statements (except for legends) in favor of line drawings, opens up a new area of man-machine communication.},
  booktitle = {Proceedings of the May 21-23, 1963, Spring Joint Computer Conference},
  pages = {329–346},
  numpages = {18},
  location = {Detroit, Michigan},
  series = {AFIPS '63 (Spring)}
}

@article{hoare1965record,
  title={Record handling},
  author={Hoare, C.A.R.},
  journal={Algol Bulletin},
  volume={21},
  pages={39--69},
  year={1965},
  url={http://archive.computerhistory.org/resources/text/Knuth_Don_X4100/PDF_index/k-9-pdf/k-9-u2293-Record-Handling-Hoare.pdf},
  note={This seminal paper introduces classes and subclasses,
        and many other notions now familiar and ubiquitous,
        including his infamous "million dollar mistake", null.
        Hoare calls "objects" and "attributes" high-level entities being modeled, "classes" their types,
        "records" and "fields" the low-level representations of the previous as
        "consecutive words of computer store", and "record classes" their types.
        "References" are typed pointers, and "null" is a special reference
        for when a correspondence is partial rather than total.
        "Discrimination" is a form of type-safe pattern-matching between subclasses.
        Hoare considers recursive data structures, yet does not anticipate that
        for them, subclassing will differ from subtyping.}
}
% How original are the boxes-and-arrows drawings for pointers? The heap allocation?
% compacting garbage collection - Aha, he cites LISP. And SIMULA.

% Warren Teitelman MIT PhD dissertation "Pilot: A Step Toward Man-Computer Symbiosis" 1966
% Gabriel2012 claims it introduces mixins as "advice".
@PhDThesis{teitelman1966,
  author={Warren Teitelman},
  title={PILOT: a step toward man-computer symbiosis},
  year={1966},
  school={MIT},
  url={https://dspace.mit.edu/bitstream/handle/1721.1/6905/AITR-221.pdf}
}

% Simula I back in 1966 has processes and more, but DOES NOT have OO
@article{Simula1966,
  author = {Dahl, Ole-Johan and Nygaard, Kristen},
  title = {SIMULA: An ALGOL-Based Simulation Language},
  year = {1966},
  issue_date = {Sept. 1966},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {9},
  number = {9},
  issn = {0001-0782},
  url = {https://doi.org/10.1145/365813.365819},
  doi = {10.1145/365813.365819},
  abstract = {This paper is an introduction to SIMULA, a programming language designed to provide a systems analyst with unified concepts which facilitate the concise description of discrete event systems. A system description also serves as a source language simulation program. SIMULA is an extension of ALGOL 60 in which the most important new concept is that of quasi-parallel processing.},
  journal = {Commun. ACM},
  month = {sep},
  pages = {671--678},
  numpages = {8}
}

% Ole-Johan Dahl and Kristen Nygaard. Class and subclass declarations 1967 (pdf)
% https://www.ub.uio.no/english/subjects/naturalscience-technology/informatics/themes/dns/index.html
% First implements classes, and introduces inheritance (though not the word);
% introduces the words "prefix class", "subclasses", "prefix sequence", "this", "inner".
% The "prefix" class also offers a suffix, and uses the "inner" separator to "split" its "body"
% and specify where the subclass body will go. BETA will also follow this approach
% of the superclass specifying how to compose with the subclass semantics,
% when most other OO languages take the approach of the subclass specifying
% how to reuse information specified by superclasses.
% "objects" have "attributes"
@Misc{Simula1967,
  author = {Dahl, Ole-Johan and Nygaard, Kristen},
  title = {Class and subclass declarations},
  year = {1967},
  url = {https://www.ub.uio.no/fag/naturvitenskap-teknologi/informatikk/faglig/dns/dokumenter/classandsubclass1967.pdf}
}

% Introduces the notion of "Ad hoc polymorphism"
@Misc{Strachey67,
  Author = {Christopher Strachey},
  Title = {Fundamental Concepts in Programming Languages},
  Year = {1967},
  url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.332.3161},
}

% More condensed than the above, with more language context
@Misc{Simula1968,
  Author = {Ole-Johan Dahl and Bjørn Myhrhaug and Kristen Nygaard},
  Title = {SIMULA 67 Common Base Language},
  Year = {1968},
  url = {https://web.archive.org/web/20131225084408/http://www.edelweb.fr/Simula/scb-1.pdf}
}

% Identifies class with procedure that computes an algorithm and constructs a record
% and yields current values multiple times to other activities with "detach" (call again for next)
% section 6 has "concatenation" for single inheritance
% InCollection
@Misc{dahl1972chapter,
  title={Chapter III: Hierarchical program structures},
  author={Dahl, Ole-Johan and Hoare, Charles Antony Richard},
  booktitle={Structured programming},
  pages={175--220},
  year={1972}
}

@Article{Parnas1972,
  author = {Parnas, D. L.},
  title = {On the Criteria to Be Used in Decomposing Systems into Modules},
  year = {1972},
  issue_date = {Dec. 1972},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {15},
  number = {12},
  issn = {0001-0782},
  url = {https://doi.org/10.1145/361598.361623},
  doi = {10.1145/361598.361623},
  abstract = {This paper discusses modularization as a mechanism for improving the flexibility and comprehensibility of a system while allowing the shortening of its development time. The effectiveness of a “modularization” is dependent upon the criteria used in dividing the system into modules. A system design problem is presented and both a conventional and unconventional decomposition are described. It is shown that the unconventional decompositions have distinct advantages for the goals outlined. The criteria used in arriving at the decompositions are discussed. The unconventional decomposition, if implemented with the conventional assumption that a module consists of one or more subroutines, will be less efficient in most cases. An alternative approach to implementation which does not have this effect is sketched.},
  journal = {Commun. ACM},
  month = {dec},
  pages = {1053--1058},
  numpages = {6},
  keywords = {modules, software, KWIC index, modularity, software engineering, software design}
}

% XXX TODO
% Hewitt, Bishop, Greif, Smith, Matson, Steiger
% Actor Induction and Meta-evaluation
% POPL
% 1973

% Minsky's 1974 paper on Frames uses the words "prototype" and "inherit", but incidentally,
% not at all to refer to the concepts at stake. MIT AIM-306
@article{minsky1974framework,
  title={A Framework for Representing Knowledge},
  author={Minsky, Marvin},
  year={1974},
  url={https://dspace.mit.edu/handle/1721.1/6089}
}

% 1975 Hewitt Stereotypes
% p.101 “The "frame" problem of McCarthy for assertional frames corresponds closely to
% the problems of "inheritance of attributes" and "default values" for object frames.
% For example the fable quoted by Minsky about the wolf and the lamb is very close to
% the frame problems of McCarthy.”
% Bibliography includes by McCarthy "Programs with Common Sense" (1958),
% and "Some philosophical problems from the standpoint of Artificial Intelligence" (1969),
% neither of which has it, and by Minksy "A Framework for Representing Knowledge",
% that discusses “"default" assignments” and discusses how the wolf is lying in accusing the lamb
% and the issues with representing knowledge for that.

% So far as I can tell, the earliest use of "inheritance", in "inheritance of properties", p. 197.,
% along the hierarchy of frames. The variant it designates is multiple-inheritance,
% though that word isn't coined. The exact resolution algorithm is not explained,
% As the title implies, this is not quite for *data* yet not quite for *code* but somewhere in between.
% https://api.pageplace.de/preview/DT0400.9781483299150_A23889670/preview-9781483299150_A23889670.pdf
%
% The use of the name "inheritance" is not fully formal, though.
% It is probably through Dan Ingalls' implementation of (single) inheritance in Smalltalk 1976
% that "inheritance" became formally known as such.
% Winograd also inspired Kahn and Borning for their Prototype OO systems, etc.
%
% Not sure how to name namings, but here are at least four kinds:
% - evocation: neither name nor concept owns the other, yet an allusion is made.
% - distinction: the name distinguishes the concept from others, but isn't owned by it.
% - identification: name and concept own each other, though the limits of the concept may not be clear.
% - definition: the essence of the concept being named is finally well understood.
% For "inheritance", evocation happened in Minsky 1975, distinction in Winograd 1975,
% and identification around 1976 quite possibly by Kay,
% practical definition in the early 1980s with Flavors and T,
% theoretical definition around 1990 by Cook & Bracha, and works on multipe inheritance culminating with C3.
% Final definition around 2025 by this very series of papers?
%
% not to name concepts in their formal object, rather as part of its informal (meta) context.
% Yet no doubt they primed Winograd for when he did use them to name concepts of KRL in 1975.
%
% InCollection
@Misc{Winograd1975,
  author = {Terry Winograd},
  title = {Frame Representations and the Declarative/Procedural Controversy},
  editor = {Daniel G. Bobrow and Allan Collins},
  booktitle = {Representation and Understanding},
  publisher = {Morgan Kaufmann},
  address = {San Diego},
  pages = {185-210},
  year = {1975},
  isbn = {978-0-12-108550-6},
  doi = {10.1016/B978-0-12-108550-6.50012-4},
  url = {https://www.sciencedirect.com/science/article/pii/B9780121085506500124},
  abstract = {Publisher Summary
This chapter presents some criteria for evaluating ideas for representation. It also presents a rough sketch of a particular version of a frame representation, and discusses the ways in which it can deal with the issues raised. The proceduralists assert that human knowledge is primarily a knowing how. The human information processor is a stored program device, with its knowledge of the world embedded in the programs. The declarativists do not believe that knowledge of a subject is intimately bound with the procedures for its use. They see intelligence as resting on two bases: a quite general set of procedures for manipulating facts of all sorts, and a set of specific facts describing particular knowledge domains. In thinking, the general procedures are applied to the domain-specific data to make deductions. Often this process has been based on the model of axiomatic mathematics. The facts are axioms and the thought process involves proof procedures for drawing conclusions from them.}
}

% https://link.springer.com/chapter/10.1007/3-540-07168-7_77
% We take the following statements to be the objectives of modular programming:
% 1. One must be able to convince himself of the correctness of a program module,
% independently of the context of its use in building larger units of software.
% 2. One must be able to conveniently put together program modules written under
% different authorities without knowledge of their inner workings.
% InBook
@Misc{Dennis1975,
  author="Dennis, Jack B.",
  editor="Bauer, F. L.
  and Dennis, J. B.
  and Waite, W. M.
  and Gotlieb, C. C.
  and Graham, R. M.
  and Griffiths, M.
  and Helms, H. J.
  and Morton, B.
  and Poole, P. C.
  and Tsichritzis, D.",
  title="Modularity",
  bookTitle="Software Engineering: An Advanced Course",
  year="1975",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="128--182",
  isbn="978-3-540-37502-9",
  doi="10.1007/3-540-07168-7_77",
  url="https://doi.org/10.1007/3-540-07168-7_77"
}


% AITR-346.ps
% Uses the word prototypes and objects in a suggestive but informal way.
% The knowledge representation is a decision tree in a 3kloc LISP program
% with over a thousand COND.
% There is some notion of hierarchy and overriding/extending descriptive features,
% but not obviously one of fixed-point or self-reference; at least not discussed.
@article{hollerbach1975hierarchical,
  title={Hierarchical shape description of objects by selection and modification of prototypes},
  author={Hollerbach, John M},
  year={1975},
  url={https://dspace.mit.edu/handle/1721.1/6897}
}

@InProceedings{DeRemerKron1975,
  author = {DeRemer, Frank and Kron, Hans},
  title = {Programming-in-the Large versus Programming-in-the-Small},
  year = {1975},
  isbn = {9781450373852},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/800027.808431},
  doi = {10.1145/800027.808431},
  abstract = {We distinguish the activity of writing large programs from that of writing small ones. By large programs we mean systems consisting of many small programs (modules), possibly written by different people.We need languages for programming-in-the-small, i.e. languages not unlike the common programming languages of today, for writing modules. We also need a “module interconnection language” for knitting those modules together into an integrated whole and for providing an overview that formally records the intent of the programmer(s) and that can be checked for consistency by a compiler.We explore the software reliability aspects of such an interconnection language. Emphasis is placed on facilities for information hiding and for defining layers of virtual machines.},
  booktitle = {Proceedings of the International Conference on Reliable Software},
  pages = {114–121},
  numpages = {8},
  keywords = {Module interconnection language, Accessibility, Visibility, Protection, Linking, Scope of definition, Virtual machine, Project management tool., Information hiding, External name, System hierarchy},
  location = {Los Angeles, California}
}

% Unnamed language inspired by Hewitt's actors (PLASMA) and Smalltalk-72.
% Prototype-based ("objects" reply to "messages", "prototype" not used),
% that have "parents" or "children" (single inheritance is described; "inheritance of properties" is used)
% There are "classes" that handle otherwise unhandled messages, but the relationship between
% classes and parents is not explained -- are they the same hierarchy? a separate one?
% Are the child/parent and class/instance relationships the same or different?
@InProceedings{Kahn1976,
  author = {Kahn, Kenneth Michael},
  title = {An Actor-Based Computer Animation Language},
  year = {1976},
  isbn = {9781450377898},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/1024273.1024278},
  abstract = {This paper describes a computer language based upon actor semantics designed especially for computer graphics and animation. The thesis that animation is best facilitated by considering each entity on the display screen as an independent process is discussed and demonstrated by examples. The system is built upon MacLisp and is compatible with Lisp-Logo. The language is designed to be used by both very sophisticated programmers and by school children.},
  booktitle = {Proceedings of the ACM/SIGGRAPH Workshop on User-Oriented Design of Interactive Graphics Systems},
  pages = {37–43},
  numpages = {7},
  location = {Pittsburgh, PA},
  series = {UODIGS '76},
  url = {https://dspace.mit.edu/handle/1721.1/41950}
}

% Also published in Cognitive Science, V. 1, No. 1, 1977.
% Has multiple inheritance (without using the word) as multiple "descriptors"
% each providing a "perspective" on a given "object" or "prototype",
% and "inheritance of properties".
% Meant as a declarative system of data on which operations are then performed,
% rather than as code as such (though coding is possible).
@Misc{Bobrow1976,
  author={Daniel G. Bobrow and Terry Winograd},
  title={An Overview of KRL, A Knowledge Representation Language},
  year={1976},
  note={Stanford Artificial Intelligence Laboratory Memo AIM-293},
  url={https://exhibits.stanford.edu/stanford-pubs/catalog/pf235fy3176}
}

% Starts with modularity principle
% Mentions multiple inheritance of traits, but does not explain too much
@inproceedings{Smalltalk78,
  author = {Ingalls, Daniel H. H.},
  title = {The Smalltalk-76 programming system design and implementation},
  year = {1978},
  isbn = {9781450373487},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/512760.512762},
  doi = {10.1145/512760.512762},
  abstract = {This paper describes a programming system based on the metaphor of communicating objects. Experience with a running system shows that this model provides flexibility, modularity and compactness. A compiled representation for the language is presented, along with an interpreter suitable for microcoding. The object-oriented model provides naturally efficient addressing; a corresponding virtual memory is described which offers dense utilization of resident space.},
  booktitle = {Proceedings of the 5th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
  pages = {9–16},
  numpages = {8},
  location = {Tucson, Arizona},
  series = {POPL '78}
}

% Uses the word "prototypes", and has no classes. And multiple inheritance.
@InProceedings{Borning1977,
  author = {Alan Hamilton Borning},
  title = {{ThingLab} --- an Object-Oriented System for Building Simulations using Constraints},
  booktitle={5th International Conference on Artificial Intelligence},
  pages={497--498},
  month = {August},
  year = {1977},
  url = {https://www.ijcai.org/Proceedings/77-1/Papers/085.pdf}
}

@PhDThesis{Borning1979,
  author = {Borning, Alan Hamilton},
  title = {{ThingLab} --- A Constraint-Oriented Simulation Laboratory},
  biburl = {https://www.bibsonomy.org/bibtex/263cae088243a5fd341d7d634d8176bb3/n770},
  publisher = {Palo Alto Research Center XEROX},
  url = {https://constraints.cs.washington.edu/ui/thinglab-tr.pdf},
  school = {Stanford University},
  year = 1979
}

% This paper is about the higher-level system Ani, that generates plans for Director.
% Director is the actor-based system with turtle graphics
% (see Director Guide, AIM-482b, 1978 revised 1979),
% while Ani is a constraint solver based on a knowledge representation of the film being directed:
% very crude 2d film with polygons as "performers" that move toward, away from,
% around or between each other, at various speeds appropriate for the action,
% as would humans on a stage.
@PhDThesis{Kahn1979,
  title = {Creation of computer animation from story descriptions},
  author = {Kahn, Kenneth Michael},
  school = {MIT},
  year = {1979},
  url = {https://dspace.mit.edu/handle/1721.1/16012}
}


% Borning1982 cites a 1980 version of the Flavors report, from MIT. Originally from 1979.
% Also a 1982 version of LOOPS
@Misc{Cannon1979,
  title={Flavors: A non-hierarchical approach to object-oriented programming},
  author={Howard Cannon},
  publisher={Symbolics Inc.},
  year=1979,
  url={https://www.softwarepreservation.org/projects/LISP/MIT/nnnfla1-20040122.pdf}
}

% http://worrydream.com/refs/Borning%20-%20The%20Programming%20Language%20Aspects%20of%20ThingLab.pdf
% https://dl.acm.org/doi/abs/10.1145/357146.357147
@Article{Borning1981,
  author = {Borning, Alan Hamilton},
  title = {The Programming Language Aspects of ThingLab, a Constraint-Oriented Simulation Laboratory},
  year = {1981},
  issue_date = {Oct. 1981},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {3},
  number = {4},
  issn = {0164-0925},
  url = {https://doi.org/10.1145/357146.357147},
  doi = {10.1145/357146.357147},
  journal = {ACM Trans. Program. Lang. Syst.},
  month = oct,
  pages = {353--387},
  numpages = {35}
}

% Yale T Scheme. Introduces functional syntax for object method invocation.
% Norman I. Adams, IV -- but the IV doesn't get processed correctly
% Can't find it on http://mumble.net/~jar/tproject/
@InProceedings{Rees82t:a,
  author = {Jonathan A. Rees and Norman I. Adams},
  title = {T: a dialect of LISP or, Lambda: the ultimate software tool},
  booktitle = {Symposium on Lisp and Functional Programming, ACM},
  pages = {114--122},
  year = {1982},
  url = {https://www.researchgate.net/publication/221252249_T_a_dialect_of_Lisp_or_LAMBDA_The_ultimate_software_tool}
}

% Successor to a 1980 experiment by Borning. No method combination. Unclear linearization. Low on details.
% Uses the Link class from SIMULA, and ReadWriteStream as motivations for multiple inheritance.
% ThingLab 1981 has multiple inheritance (already in 1977),
% and so have PIE (Goldstein&Bobrow 1980), Flavors 1980, LOOPS 1982.
% Traits from Mesa since 1979 [Curry 1982]
% Conflict resolution is by erroring if inheriting more than one method without an explicit override
@InProceedings{borning1982multiple,
  title={Multiple inheritance in Smalltalk-80},
  author={Borning, Alan H and Ingalls, Daniel HH},
  booktitle={Proceedings at the National Conference on AI},
  volume={82},
  pages={234--237},
  year={1982},
  url={http://www.laputan.org/pub/papers/MI-Borning-Ingalls.PDF}
}

% Has metaclasses, multiple inheritance.
% Still ugly syntax, with INTERLISP-style very short uppercase identifiers.
@book{Bobrow1983Loops,
  title={The LOOPS manual},
  author={Bobrow, Daniel Gureasko and Stefik, Mark},
  volume={10},
  year={1983},
  publisher={Xerox Corporation Palo Alto, CA}
}

% After discussing multiple inheritance informally, omits it completely from the formal treatment,
% but does introduce a framework for subtyping of a lambda-calculus with records and fixed-points.
@InProceedings{Cardelli1984ASO,
  title={A Semantics of Multiple Inheritance},
  author={Luca Cardelli},
  booktitle={Information and Computation},
  year={1984},
  url={https://api.semanticscholar.org/CorpusID:13032155}
}

% Wegner & Cardelli have plenty of good concepts,
% including universal and existential quantification...
% and then in section 6.1 they fall squarely into NNOOTT,
% explicitly confusing inheritance and subtyping.
% They also cite Smalltalk and Flavors in 6.3, just to immediately drop the ball.
% Beyond lame.
@book{cardelli1986understanding,
  title={On understanding types, data abstraction, and polymorphism},
  author={Cardelli, Luca and Wegner, Peter},
  year={1986},
  publisher={Brown University. Department of Computer Science},
  url={http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf}
}

% url={https://homepages.cwi.nl/~storm/teaching/reader/Lieberman86.pdf}
@InProceedings{Lieberman1986,
  title={Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems},
  author={Henry Lieberman},
  booktitle={OOPLSA},
  pages={214--223},
  year={1986},
  url={https://web.media.mit.edu/~lieber/Lieberary/OOP/Delegation/Delegation.html}
}

@InProceedings{Borning1986,
  title={Classes Versus Prototypes in Object-Oriented Languages},
  author={Alan Hamilton Borning},
  booktitle={1986 Fall Joint Computer Conference},
  pages={36--40},
  year={1986},
  doi={10.5555/324493.324538},
}

% Also a 1985 report.
% Has generic functions, method caching, multimethods,
% As in 1983, metaclasses-mediated definitions&slots, etc.
% Almost modern syntax, lower case long(ish) identifiers.
@InProceedings{Bobrow86CommonLoops,
  title={CommonLoops: Merging Lisp and Object-Oriented Programming},
  author={Daniel G. Bobrow and Kenneth Kahn and Gregor Kiczales and Larry Masinter and Mark Stefyk and Frank Zdybel},
  booktitle={OOPSLA},
  year={1986},
  doi={10.1145/28697.28700}
}

% David Moon "Object-Oriented Programming with Flavors" 1986
% Gabriel2012 says it's the first academic publication on mixins after Cannon's MIT report on Flavors.
% It describes the New Flavors from Symbolics. GF syntax. Insists on modularity.
% Claims that local order is enforced, but I doubt it.
@article{Moon1986Flavors,
author = {Moon, David A.},
title = {Object-oriented programming with flavors},
year = {1986},
issue_date = {Nov. 1986},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {11},
issn = {0362-1340},
url = {https://doi.org/10.1145/960112.28698},
doi = {10.1145/960112.28698},
abstract = {This paper describes Symbolics' newly redesigned object-oriented programming system, Flavors. Flavors encourages program modularity, eases the development of large, complex programs, and provides high efficiency at run time. Flavors is integrated into Lisp and the Symbolics program development environment. This paper describes the philosophy and some of the major characteristics of Symbolics' Flavors and shows how the above goals are addressed. Full details of Flavors are left to the programmers' manual, Reference Guide to Symbolics Common Lisp. (5)},
journal = {SIGPLAN Not.},
month = jun,
pages = {1--8},
numpages = {8}
}

% Calls "graph oriented" the conflict view of multiple inheritance
% Discusses the consequence for his clients of the designer of a class making a change.
% Explains the advantages of the Flavors "Linear Solution",
% but claims sometimes a subclass wants to directly call some method of its superclass
% without intermediate classes meddling from somewhere else in the hierarchy. Why?
% Why not then call a static helper, or a helper with a different name?
% Seems very dubious-solution in search of a problem.
% His solution in CommonObjects is systematic conflict, and "duplicating nodes",
% i.e. like C++ non-virtual classes later. Shame.
% NB: Much updated 1987 version at https://archive.org/details/researchdirectio00shri/page/164/mode/2up
@InProceedings{Snyder1986Encapsulation,
  author = {Snyder, Alan},
  title = {Encapsulation and Inheritance in Object-Oriented Programming Languages},
  year = {1986},
  isbn = {0897912047},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/28697.28702},
  doi = {10.1145/28697.28702},
  abstract = {Object-oriented programming is a practical and useful programming methodology that encourages modular design and software reuse. Most object-oriented programming languages support data abstraction by preventing an object from being manipulated except via its defined external operations. In most languages, however, the introduction of inheritance severely compromises the benefits of this encapsulation. Furthermore, the use of inheritance itself is globally visible in most languages, so that changes to the inheritance hierarchy cannot be made safely. This paper examines the relationship between inheritance and encapsulation and develops requirements for full support of encapsulation with inheritance.},
  booktitle = {Conference Proceedings on Object-Oriented Programming Systems, Languages and Applications},
  pages = {38–45},
  numpages = {8},
  location = {Portland, Oregon, USA},
  series = {OOPSLA '86}
}

% Stein 1987 "Delegation is Inheritance", cited by cook1989inheritance


% https://beta.cs.au.dk/ ?
@article{kristensen1987beta,
  title={The BETA programming language},
  author={Kristensen, Bent Bruun and Madsen, Ole Lehrmann and Møller-Pedersen, Birger and Nygaard, Kristen},
  journal={DAIMI Report Series},
  number={229},
  year={1987},
  url={https://www.semanticscholar.org/paper/The-BETA-Programming-Language-Kristensen-Madsen/3971897f708518e13809d3c0772105bd86526e50}
}

% Specification of function behavior, similar to later CLHS
% https://www.researchgate.net/publication/220178512_Common_Lisp_Object_System_Specification_X2JI3_Document_88-002R
@Article{Bobrow88CLOS,
  title={Common Lisp Object Specification X3J13},
  author={D. G. Bobrow and L. D. DeMichiel and R. P. Gabriel and S. E. Kleene and G. Kiczales and D. A. Moon},
  journal={SIGPLAN Notices 23 (Special Issue)},
  year={1988},
  doi={10.1007/bf01806962},
  url={https://link.springer.com/content/pdf/10.1007/bf01806962.pdf}
}

@InProceedings{Kamin1988,
  title={Inheritance in Smalltalk-80: A Denotational Definition},
  author={Samuel N. Kamin},
  %booktitle={POPL '88},
  booktitle={POPL},
  year={1988},
  doi={10.1145/73560.73567},
  %url={https://dl.acm.org/doi/10.1145/73560.73567}
}

% https://core.ac.uk/download/pdf/42828491.pdf
@InProceedings{ObjectsAsClosures,
  author = {Reddy, Uday},
  title = {Objects as Closures - Abstract Semantics of Object Oriented Languages},
  %booktitle = {ACM Symposium on LISP and Functional Programming},
  booktitle = {LFP},
  %month = {02},
  pages = {289–-297},
  doi = {10.1145/62678.62721},
  year = {1988},
}

% First entry (alphabetically by name?) in ltuo
@InProceedings{adams88oopscheme,
  Author = {Norman Adams and Jonathan Rees},
  Title = {Object-Oriented Programming in Scheme},
  url = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.954",
  %booktitle = {ACM Conference on Lisp and Functional Programming},
  booktitle = {LFP},
  pages = {277--288},
  Year = {1988},
  note = {Expounds the object system of Yale T Scheme, actually implemented circa 1982.
          T has class-less objects (it's what we'd call prototypes, but they don't use the word).
          The low-level machine merges objects and functions:
          an object is a function with multiple entry points (one per method) including a default one.
          A function stricto sensu is an object with a single method.
          T objects as such have single-inheritance, but
          "components" provide mixin inheritance.}
}

% Unless a base class is "virtual", multiple copies are inherited.
% Conflict resolution is manual; you can explicitly call a superclass method,
% but there is no linearization mechanism to preserve method linearity
% in case of "ambiguities" (paper does not say "diamonds")
@article{stroustrup1989multiple,
  title={Multiple inheritance for C++},
  author={Stroustrup, Bjarne},
  journal={Computing Systems},
  volume={2},
  number={4},
  pages={367--395},
  year={1989}
}

% Cook2012 cites his own thesis in arguing that Inheritance is neither necessary nor specific to OO.
@PhDThesis{Cook1989,
    author = {William R. Cook},
    title = {A Denotational Semantics of Inheritance},
    school = {Brown University},
    year = {1989},
    url = {https://www.cs.utexas.edu/~wcook/papers/thesis/cook89.pdf}
}

% POPL, short reprise of what's in his thesis
% Also single-inheritance, records only
@Article{cook1989denotational,
  title={A denotational semantics of inheritance and its correctness},
  author={Cook, William and Palsberg, Jens},
  journal={ACM Sigplan Notices},
  volume={24},
  number={10},
  pages={433--443},
  year={1989},
  publisher={ACM New York, NY, USA}
}

% The right fixed-point semantics, actually for prototypes as well as classes!
% 2.2 claims to avoid the "subsumption" rule for record subtyping in Cardelli (allows more rows)
% but in later sections seem to implicitly rely on it (or else on some dynamic or deferred typing?)
% 3 uses specs and targets without saying it
% 4.1 Has class as object constructor, reflexively accessible from object as "self class" method,
% and then uses double Y to resolve both class and self prototypes,
% instead of having an explicit Lieberman-like construction of class as prototype.
% 4.2 seems to implicitly have a type dependency (what are F and G ib (5)?)
% url={https://dl.acm.org/doi/abs/10.1145/96709.96721}
% Cites Mitch Wand 1987, 1989, 1989... gotta go deeper
@InProceedings{cook1989inheritance,
  title={Inheritance is not subtyping},
  author={Cook, William R and Hill, Walter and Canning, Peter S},
  %booktitle={Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  booktitle={POPL},
  pages={125--135},
  year={1989},
  doi={10.1145/96709.96721}
}


@InProceedings{chambers1989efficient,
  author = {Chambers, C. and Ungar, D. and Lee, E.},
  title = {An Efficient Implementation of SELF a Dynamically-Typed Object-Oriented Language Based on Prototypes},
  year = {1989},
  isbn = {0897913337},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/74877.74884},
  doi = {10.1145/74877.74884},
  abstract = {We have developed and implemented techniques that double the performance of dynamically-typed object-oriented languages. Our SELF implementation runs twice as fast as the fastest Smalltalk implementation, despite SELF's lack of classes and explicit variables.To compensate for the absence of classes, our system uses implementation-level maps to transparently group objects cloned from the same prototype, providing data type information and eliminating the apparent space overhead for prototype-based systems. To compensate for dynamic typing, user-defined control structures, and the lack of explicit variables, our system dynamically compiles multiple versions of a source method, each customized according to its receiver's map. Within each version the type of the receiver is fixed, and thus the compiler can statically bind and inline all messages sent to self. Message splitting and type prediction extract and preserve even more static type information, allowing the compiler to inline many other messages. Inlining dramatically improves performance and eliminates the need to hard-wire low-level methods such as +,==, and ifTrue:.Despite inlining and other optimizations, our system still supports interactive programming environments. The system traverses internal dependency lists to invalidate all compiled methods affected by a programming change. The debugger reconstructs inlined stack frames from compiler-generated debugging information, making inlining invisible to the SELF programmer.},
  booktitle = {OOPSLA},
  pages = {49–70},
  numpages = {22},
  location = {New Orleans, Louisiana, USA}
}

% Not obviously worth citing in this context?
% @TechReport ?
@Misc{Lawall89SelfInScheme,
  Author = {Julia L. Lawall and Daniel P. Friedman},
  Title = {Embedding the Self Language in Scheme},
  url = "https://legacy.cs.indiana.edu/ftp/techreports/TR276.pdf",
  Year = {1989}
}

% Introduction of Typeclasses
% https://www.research.ed.ac.uk/en/publications/how-to-make-ad-hoc-polymorphism-less-ad-hoc
@InProceedings{typeclasses,
  title = "How to make ad-hoc polymorphism less ad hoc",
  abstract = "This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication, and generalise the {"}eqtype variables{"} of Standard ML. Type classes extend the Hindley/Milner polymorphic type system, and provide a new approach to issues that arise in object-oriented programming, bounded type quantification, and abstract data types. This paper provides an informal introduction to type classes, and defines them formally by means of type inference rules. ",
  author = "P. Wadler and S. Blott",
  year = "1989",
  doi = "10.1145/75277.75283",
  language = "English",
  isbn = "0-89791-294-2",
  pages = "60--76",
  %booktitle = "POPL '89 Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages",
  booktitle = "POPL",
  publisher = "ACM"
}

@TechReport{PCLSRing,
        Author={Alan Bawden},
	Title={{PCLSR}ing: {K}eeping {P}rocess {S}tate {M}odular},
	Institution={MIT},
	Year="1989",
	url={http://fare.tunes.org/tmp/emergent/pclsr.htm}
}

@book{cltl2,
  author = {Steele, Guy},
  title = {Common Lisp: The Language, 2nd edition},
  year = {1990},
  isbn = {0131515071},
  publisher = {Digital Press},
  address = {USA},
  doi = {10.5555/1098646},
  url = {http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/cltl2.html}
}

% https://www.semanticscholar.org/paper/Mixin-based-inheritance-Bracha-Cook/cbc4f2d93bb62d1c287f4fe458de6ac416379282
% url = {https://doi.org/10.1145/97945.97982},
@InProceedings{bracha1990mixin,
  author = {Gilad Bracha and William Cook},
  title = {Mixin-Based Inheritance},
  year = {1990},
  issue_date = {Oct. 1990},
  isbn = {0897914112},
  volume = {25},
  number = {10},
  issn = {0362-1340},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://bracha.org/oopsla90.pdf},
  doi = {10.1145/97945.97982},
  abstract = {The diverse inheritance mechanisms provided by Smalltalk, Beta, and CLOS are interpreted as different uses of a single underlying construct. Smalltalk and Beta differ primarily in the direction of class hierarchy growth. These inheritance mechanisms are subsumed in a new inheritance model based on composition of mixins, or abstract subclasses. This form of inheritance can also encode a CLOS multiple-inheritance hierarchy, although changes to the encoded hierarchy that would violate encapsulation are difficult. Practical application of mixin-based inheritance is illustrated in a sketch of an extension to Modula-3.},
  booktitle = {OOPLSA/ECOOP},
  pages = {303–311},
  numpages = {9},
  location = {Ottawa, Canada},
  journal = {SIGPLAN Not.},
  month = sep
}

% Introduces Recursion Schemes. Heavy on math notation.
% Kind of category theory
@inproceedings{bananas1991,
  author = {Meijer, Erik and Fokkinga, Maarten and Paterson, Ross},
  title = {Functional programming with bananas, lenses, envelopes and barbed wire},
  year = {1991},
  isbn = {0387543961},
  publisher = {Springer-Verlag},
  address = {Berlin, Heidelberg},
  booktitle = {Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture},
  pages = {124–144},
  numpages = {21},
  location = {Cambridge, Massachusetts, USA}
}

% Original DEFSYSTEM is a 1990 paper, but hard to find independently from the others.
@TechReport{kantrowitz1991,
  author =       {Mark Kantrowitz},
  title =        {Portable Utilities for {C}ommon {L}isp},
  institution =  {School of Computer Science, Carnegie-Mellon University},
  number =       {CMU-CS-91-143},
  year =         1991,
  month =        May,
  url =          {https://cl-pdx.com/static/CMU-CS-91-143.pdf}
}

@Article{gabriel1991clos,
  title={CLOS: Integrating object-oriented and functional programming},
  author={Gabriel, Richard P and White, Jon L and Bobrow, Daniel G},
  journal={Communications of the ACM},
  volume={34},
  number={9},
  pages={29--38},
  year={1991},
  publisher={ACM New York, NY, USA}
}

@Book{amop,
  Title={The {A}rt of the {M}eta-{O}bject {P}rotocol},
  Author={Kiczales, Gregor and Des Rivières, Jim and Bobrow, Daniel Gureasko},
  Year={1991},
  Publisher={MIT Press},
  url={https://direct.mit.edu/books/book/2607/The-Art-of-the-Metaobject-Protocol}
}

@InProceedings{Ungar91organizingprograms,
  Title = {Organizing Programs Without Classes},
  author = {David Ungar and Craig Chambers and Bay-Wei Chang and Urs Hölzle},
  journal = {Lisp and Symbolic Computation},
  year = {1991},
  pages = {223--242},
  publisher = {Kluwer Academic Publishers}
}

@TechReport{eppl91,
  Author={Matthias Felleisen},
  Title={On the Expressive Power of Programming Languages},
  Institution={Rice University},
  Year={1991},
  url={https://www.cs.rice.edu/CS/PLT/Publications/Scheme/}
}

% What a mess. https://x.com/xadh/status/1945251704011665663
% https://github.com/shriram/plai-public/issues/62
%
% "prioritized inheritance": superclasses are assigned priorities,
% and between "ordered" superclasses at different priorities, it's like linearization,
% but between "unordered" superclasses at same priority, it's ambiguousMessage error.
% Also, when invoking a method, remember not just the self but the invoking super,
% according to a "sender path tiebreaking rule" unique to SELF.
% so that further slot accesses follow the path (what about nested access, though?
% Reset at SELF? stack of previous super?)
% Also, dynamic inheritance: can dynamically add/remove slots and superclasses (at various priorities)
% call-next-method is called "resend" and can change method (unlike CLOS, to follow same path)
% and arguments but not self, and also specify the sending parent (one level of parent,
% must be superclass of current sending parent).
% No method combinations: cites CLOS, but wants "simplicity" for SELF.
% Mention rename in Eiffel as an alternative, static way to deal with unordered inheritance
% Notes that C++ linearizes superclasses for constructors and destructors, just not for regular methods
%
% Issues: SELF mixins must be parentless to avoid their general parents
% overriding the mixed class's specific slots. "Backtracking", i.e. lack of a stack of senders as above.
% "considering altering SELF's lookup rule to always search children before their ancestors"
% and be more like CLOS in this way.
% NB: In their "complexities" they note how their lack a clear story for resend with dynamic inheritance
% --- but then I'm not sure if CLOS specifies it, especially in presence of concurrency, so there.
% They also support cycles but say it's too complex to explain how in the paper.
%
@InProceedings{parentsSharedParts1991,
  title={Parents are Shared Parts of Objects: Inheritance and Encapsulation in SELF},
  author={Craig Chambers, David Ungar, Bay-Wei Chang, Urs Hölzle},
  booktitle={Lisp and Symbolic Computation},
  year={1991},
  url={https://bibliography.selflanguage.org/parents-shared-parts.html}
}

% HPL-91-50
% A possibly shortened version also published in *IEEE Software*, January 1993
% as "The Essence of Objects: Concepts and Terms"
@Misc{Snyder1991Essence,
  author = {Alan Snyder},
  title = {The Essence of Objects: Common Concepts and Terminology},
  year = {1991},
  abstract = {Core concepts in object-oriented technology are defined. The concepts are the basis for characterizing and contrasting various object-oriented technologies. The core concepts are: all objects embody an abstraction, objects provide services, clients issue requests, objects are encapsulated, requests identify operations, requests can identify objects, new objects can be created, operations can be generic, objects can be classified in terms of their services, objects can have a common implementation, and objects can share partial implementations. To address communication problems, a glossary of terms appropriate for the diverse set of domains in which object-oriented concepts are being applied is developed. The definitions are grouped into three sections in top-down order: terms related to abstraction, terms related to requesting services, and terms related to performing services.},
  month = june,
  numpages = {24},
  keywords = {abstraction, object-oriented programming, object-oriented technology, requests, services},
  url = {https://shiftleft.com/mirrors/www.hpl.hp.com/techreports/91/HPL-91-50.pdf},
  note = {
    Alan Snyder tries to introduce and name the common concepts in OO,
    in a way mindful of the variety of OO languages and systems,
    from C++ to CLOS to the Iris db and more.
    He insists on abstraction and encapsulation — features of what I would call "modularity",
    and only very quickly goes over inheritance, without details.
  }
}

% According to Scholar.Google.com, this paper introduces "Open Recursion" in the context of CS,
% p.31,32, to describe how to extract a class and subclass from fixpoint of operator, after Cook89.
@book{cardelli1992extensible,
  title={Extensible records in a pure calculus of subtyping},
  author={Cardelli, Luca},
  year={1992},
  publisher={Digital. Systems Research Center},
  url="https://bitsavers.trailing-edge.com/pdf/dec/tech_reports/SRC-RR-81.pdf"
}

% Like Traits 1982, errors out in case of conflicting methods along the hierarchy
@InProceedings{CecilMultimethods,
  author="Chambers, Craig",
  editor="Madsen, Ole Lehrmann",
  title="Object-oriented multi-methods in Cecil",
  booktitle="ECOOP",
  year="1992",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="33--56",
  abstract="Multiple dispatching provides increased expressive power over single dispatching by guiding method lookup using the values of all arguments instead of only the receiver. However, existing languages with multiple dispatching do not encourage the data-abstraction-oriented programming style that is encouraged by traditional single-dispatching languages; instead existing multiple-dispatching languages tend to foster a function-oriented programming style organized around generic functions. We propose an alternative view of multiple dispatching that is intended to promote a data-abstraction-oriented programming style. Instead of viewing a multi-method as ``outside'' of all objects, we view a multi-method as ``inside'' the objects for which the multi-method applies (on which it dispatches). Because objects are closely connected to the multi-methods implementing their operations, the internals of an object can be encapsulated by being accessible only to the closely-connected multi-methods. We are exploring this object-oriented view of multi-methods in the context of a new programming language named Cecil.",
  isbn="978-3-540-47268-1",
  url="http://www.laputan.org/pub/papers/cecil-ecoop-92.pdf"
}

% Introduces the concept of “Abstraction Inversion”
@article{Baker1992CritiqueDKL,
  title={Critique of DIN Kernel Lisp definition version 1.2},
  author={Henry G. Baker},
  journal={LISP and Symbolic Computation},
  year={1992},
  volume={4},
  pages={371-398},
  url={https://api.semanticscholar.org/CorpusID:6330838}
}

% Dissects the mechanisms of modularity in programming languages,
% offers a zoo of solution, but not in a constructive way.
% The constructive part, mixin inheritance, is great, though.
% p. 24 Says "diamond problem", quoted Bertrand Meyer who says "repeated inheritance",
% Gilad says he didn't invent "diamond" but probably got it from C++ community newsgroups.
% His [65] is a 1987 updated reprint as a book chapter the [64] OOPSLA 1986
% p. 25 Cites CLOS but wrongly claims without argument that it shares the same diamond problem
% as Flavor-less multiple inheritance system. Not aware of how method combination changes the game.
@PhDThesis{bracha1992jigsaw,
  author = {Gilad Bracha},
  title = {The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance},
  school = {University of Utah},
  year = {1992},
  url = {http://www.bracha.org/jigsaw.pdf}
}

@Article{dickey1992scheming,
  title={Scheming with objects},
  author={Dickey, Ken},
  url={http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/oop/yasos/swob.txt},
  journal={AI Expert},
  volume={7},
  number={10},
  pages={24--33},
  year={1992}
}

@InProceedings{chambers92objectoriented,
  author = {Craig Chambers},
  title = {Object-oriented multi-methods in Cecil},
  booktitle = {ECOOP},
  volume = "615",
  publisher = "Springer-Verlag",
  address = "Berlin, Heidelberg, New York, Tokyo",
  editor = "Ole Lehrmann Madsen",
  isbn = "3-540-55668-0",
  pages = "33--56",
  year = "1992",
  url = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.121.134"
}

% Defines the constraints used by C3, but uses a global rather than local tie break rule,
% and goes on rather than errors out if rules are incompatible
@article{Ducournau1992Monotonic,
  title={Monotonic conflict resolution mechanisms for inheritance},
  author={Ducournau, Roland and Habib, Michel and Huchard, Marianne and Mugnier, Marie-Laure},
  journal={ACM SIGPLAN Notices},
  volume={27},
  number={10},
  pages={16--24},
  year={1992},
  publisher={ACM New York, NY, USA}
}

% http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3952
@InProceedings{ImplementingTypeClasses,
  title = "Implementing Type Classes",
  author = "John Peterson and Mark Jones",
  booktitle = "Proceedings of ACM SIGPLAN Symposium on Programming Language Design and Implementation",
  year = "1993",
  url = "http://web.cecs.pdx.edu/~mpj/pubs/pldi93.html",
  publisher = {Elsevier Science},
}

% Traces (A cut at the “make isn't generic” problem)
% Gregor Kiczales
% 1993
% https://link.springer.com/chapter/10.1007/3-540-57342-9_64
@InProceedings{10.1007/3-540-57342-9_64,
  author="Kiczales, Gregor",
  editor="Nishio, Shojiro
  and Yonezawa, Akinori",
  title="Traces (A cut at the ``make isn't generic'' problem)",
  booktitle="Object Technologies for Advanced Software",
  year="1993",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="27--42",
  abstract="Object-oriented techniques are a powerful tool for making a system end-programmer specializable. But, in cases where the system not only accepts objects as input, but also creates objects internally, specialization has been more difficult. This has been referred to as the ``make isn't generic problem.'' We present a new object-oriented language concept, called traces, that we have used successfully to support specialization in cases that were previously cumbersome.",
  isbn="978-3-540-48075-4"
}

% First version POPL 1993, also U of Edinburgh ECS-LFCS-92-225 "Object-Oriented Programming Without Recursive Types"
% Based on F^\omega_\leq
% Instead of hiding state via scoping, hide it via type abstraction.
% Handles modularity via existential types, pure objects:
% Object = Fun(M:*->*) Some(Rep) {| state: Rep, methods: M Rep |}
% also implements single inheritance on top, but really with mixin inheritance underneath.
% Examples include polymorphic collection.
%
% Pierce pushes difficult fixpoints into a corner, lets users tie simple knots, and
% his automation takes it from there. It’s brilliant, even insightful.
% Yet in the end he dodges the hard problem of OO rather than solves it.
% “Tell me what you need, I'll show you how to do without.”
@misc{PT1993STTFOOP,
  author={Pierce, Benjamin C. and Turner, David N.},
  title={Simple Type-Theoretic Foundations for Object-Oriented Programming},
  year={1993}
}
% @article
%  volume={4},
%  DOI={10.1017/S0956796800001040},
%  number={2},
%  journal={Journal of Functional Programming},
%  year={1994},
%  pages={207–247}

@inproceedings{Ducournau1994Monotonic,
author = {Ducournau, R. and Habib, M. and Huchard, M. and Mugnier, M. L.},
title = {Proposal for a monotonic multiple inheritance linearization},
year = {1994},
isbn = {0897916883},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191080.191110},
doi = {10.1145/191080.191110},
abstract = {Previous studies concerning multiple inheritance convinced us that a better analysis of conflict resolution mechanisms was necessary. In [DHHM92], we stated properties that a sound mechanism has to respect. Among them, a monotonicity principle plays a critical role, ensuring that the inheritance mechanism behaves “naturally” relative to the incremental design of the inheritance hierarchy. We focus here on linearizations and present an intrinsically monotonic linearization, whereas currently used linearizations are not. This paper describes the algorithm in detail, explains the design choices, and compares it to other linearizations, with LOOPS and CLOS taken as references. In particular, this new linearization extends CLOS and LOOPS linearizations, producing the same  results when these linearizations are sound.},
booktitle = {Proceedings of the Ninth Annual Conference on Object-Oriented Programming Systems, Language, and Applications},
pages = {164–175},
numpages = {12},
location = {Portland, Oregon, USA},
series = {OOPSLA '94}
}

% https://api.semanticscholar.org/CorpusID:16832709
% University of Illinois at Urbana-Champaign
% October 4, 1993
@InProceedings{Kamin1994TwoSM,
  title={Two semantic models of object-oriented languages},
  author={Samuel N. Kamin and Uday S. Reddy},
  year={1994},
  url={https://www.cs.bham.ac.uk/~udr/papers/oosem.pdf}
}

@Article{Cook1994,
  title={A Denotational Semantics of Inheritance and Its Correctness},
  author={W. Cook and J. Palsberg},
  journal={Information and Computation},
  year={1994},
  volume={114},
  pages={329--350},
  url = {https://www.cs.utexas.edu/~wcook/papers/ic94/ic94.pdf}
}

@book{GoF1994,
  title={Design patterns: elements of reusable object-oriented software},
  author={Erich Gamma and Richard Helm and Ralph Johnson and John Vlissides},
  year={1994},
  publisher={Addison-Wesley}
}

% Extend a simply typed LC (terminating) with simple objects and a typesystem
% (can add or override messages; difference meaningful because of type system)
% Prove the typesystem sound.
@article{LambdaCalculusObjects1994,
  title={A Lambda-Calculus of Objects and Method Specialization},
  author={Kathleen Fisher and Furio Honsell and John C. Mitchell},
  year={1994},
  journal={Nordic Journal of Computing},
  volume={1},
  pages={3-37}
}

% https://www.researchgate.net/publication/225917432_Object_inheritance_beyond_subtyping
% Yet another bullshit Category Theory application to the NNOOTT.
% No warning about cluelessness
% Tries to redefine "inheritance" as refinement, except that when it's "non-monotonic",
% you only have a partial map, and anything goes (you said nothing). Shameful.
@article{sernadas1994,
  author = {Costa, J. and Sernadas, Amilcar and Sernadas, Cristina},
  year = {1994},
  month = {06},
  pages = {5-26},
  title = {Object inheritance beyond subtyping},
  volume = {31},
  journal = {Acta Informatica},
  doi = {10.1007/BF01178920}
}

% Modules & Functors for SML
% https://dl.acm.org/doi/pdf/10.1145/174675.176927
% Problem is that subtyping is not decidable
% @InProceedings
@Misc{harper1994modules,
  title={A type-theoretic approach to higher-order modules with sharing},
  author={Harper, Robert and Lillibridge, Mark},
  booktitle={Proceedings of the 21st ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  pages={123--137},
  year={1994}
}

% https://scispace.com/pdf/programming-objects-with-ml-art-an-extension-to-ml-with-3s0xd52vz4.pdf
% Uses extensible records and a form of existential,
% plus "projective types" (to palliate lack for *->*),
% to emulate what Pierce and Turner do with F^\omega_\leq
% Implements multiple inheritance (or is it really mixin inheritance?), mutation or not.
% No subtyping.
@inproceedings{remy1994mlart,
  title={Programming objects with ML-ART an extension to ML with abstract and record types},
  author={R{\'e}my, Didier},
  booktitle={International Symposium on Theoretical Aspects of Computer Software},
  pages={321--346},
  year={1994},
  organization={Springer}
}


% I-SOOP
% https://pl.cs.jhu.edu/projects/type-constraints/papers/type-inference-for-recursively-constrained-types-and-its-application-to-oop-longer-version.pdf
@article{isoop1995,
  title={Type inference for recursively constrained types and its application to OOP},
  author={Eifrig, Jonathan and Smith, Scott and Trifonov, Valery},
  journal={Electronic Notes in Theoretical Computer Science},
  volume={1},
  pages={132--153},
  year={1995},
  publisher={Elsevier},
  url={https://pl.cs.jhu.edu/projects/type-constraints/papers/type-inference-for-recursively-constrained-types-and-its-application-to-oop.pdf}
}

% I-LOOP, language with classes, macro-reduced to I-SOOP, with type inference.
% "Sound polymorphic type inference for objects" 1995
% Polymorphic recursively constrained types
% https://dl.acm.org/doi/pdf/10.1145/217838.217858
@inproceedings{iloop1995,
  title={Sound polymorphic type inference for objects},
  author={Eifrig, Jonathan and Smith, Scott and Trifonov, Valery},
  booktitle={Proceedings of the tenth annual conference on Object-oriented programming systems, languages, and applications},
  pages={169--184},
  year={1995},
  doi={10.1145/217838.217858}
}

% W7
% and Sussman, Gerald Jay ???
@PhDThesis{rees1995,
  author = {Rees, Jonathan Allen},
  title = {A Security Kernel Based on the Lambda Calculus},
  year = {1995},
  publisher = {Massachusetts Institute of Technology},
  school = {Massachusetts Institute of Technology},
  address = {USA},
  url = {http://mumble.net/~jar/pubs/secureos/},
  abstract = {Cooperation between independent agents depends upon establishing a degree of security. Each of the cooperating agents needs assurance that the cooperation will not endanger resources of value to that agent. In a computer system, a computational mechanism can assure safe cooperation among the system's users by mediating resource access according to desired security policy. Such a mechanism, which is called a security kernel, lies at the heart of many operating systems and programming environments. The dissertation describes Scheme 48, a programming environment whose design is guided by established principles of operating system security. Scheme 48's security kernel is small, consisting of the call-by-value $lambda$-calculus with a few simple extensions to support abstract data types, object mutation, and access to hardware resources. Each agent (user or subsystem) has a separate evaluation environment that holds objects representing privileges granted to that agent. Because environments ultimately determine availability of object references, protection and sharing can be controlled largely by the way in which environments are constructed.I will describe experience with Scheme 48 that shows how it serves as a robust and flexible experimental platform. Two successful applications of Scheme 48 are the programming environment for the Cornell mobile robots, where Scheme 48 runs with no (other) operating system support; and a secure multi-user environment that runs on workstations. (Copies available exclusively from MIT Libraries, Rm. 14-0551, Cambridge, MA 02139-4307. Ph. 617-253-5668; Fax 617-253-1690.)},
  note = {AAI0576129}
}

@Misc{eich1995javascript,
  title={JavaScript},
  author={Brendan Eich},
  journal={Mozilla Foundation},
  year={1995}
}

% Cited by Cook2012, mentioned positively by him in private email
% https://static.aminer.org/pdf/PDF/000/137/588/objects_and_classes_co_algebraically.pdf
% In the last paragraph of section 2, Jacobs says that Ai, Bi, Ci are (constant) sets.
% All the bullshit concentrated in a single word, what more in parentheses,
% that restricts classes to the non-recursive subset where the NNOOTT applies. Wow.
% https://x.com/Ngnghm/status/1985873697949761682
% InProceedings
@Misc{Jacobs1995ObjectsAC,
  title={Objects and Classes, Co-Algebraically},
  author={Bart Jacobs},
  booktitle={Object Orientation with Parallelism and Persistence},
  pages={83--103},
  year={1995},
  url={https://api.semanticscholar.org/CorpusID:15457129}
}

% Same bullshit as in 1995. At least constant
% https://sci-hub.ru/https://link.springer.com/chapter/10.1007/BFb0053063
% Second paragraph of section 2:
% "where A and B are constant sets, not depending on the “unknown” type X (of self)"
% InProceedings
@Misc{Jacobs1996InheritanceAC,
  title={Inheritance and Cofree Constructions},
  author={Bart Jacobs},
  booktitle={European Conference on Object-Oriented Programming},
  year={1996},
  url={https://api.semanticscholar.org/CorpusID:1143267}
}

% The C3 superclass linearization algorithm
@InProceedings{Barrett96amonotonic,
  author = {Kim Barrett and Bob Cassels and Paul Haahr and David A. Moon and Keith Playford and P. Tucker Withington},
  title = {A Monotonic Superclass Linearization for Dylan},
  journal={OOPSLA},
  month = {oct},
  pages = {69–82},
  numpages = {14},
  year = {1996},
  booktitle = {OOPSLA},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/236337.236343},
  %url = {https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.3910},
}

@article{inheritance1996,
  author = {Taivalsaari, Antero},
  title = {On the Notion of Inheritance},
  year = {1996},
  issue_date = {Sept. 1996},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {28},
  number = {3},
  issn = {0360-0300},
  url = {https://doi.org/10.1145/243439.243441},
  doi = {10.1145/243439.243441},
  abstract = {One of the most intriguing—and at the same time most problematic—notions in object-oriented programing is inheritance. Inheritance is commonly regarded as the feature that distinguishes object-oriented programming from other modern programming paradigms, but researchers rarely agree on its meaning and usage. Yet inheritance of often hailed as a solution to many problems hampering software development, and many of the alleged benefits of object-oriented programming, such as improved conceptual modeling and reusability, are largely credited to it. This article aims at a comprehensive understanding of inheritance, examining its usage, surveying its varieties, and presenting a simple taxonomy of mechanisms that can be seen as underlying different inheritance models.},
  journal = {ACM Comput. Surv.},
  month = {sep},
  pages = {438--479},
  numpages = {42},
  keywords = {object-oriented programming, language constructs, delegation, inheritance, incremental modification, programming languages}
}

% Inheritance is discussed in section 11.5.1.
% SIMULA-style inheritance was deliberately left out of his work on FLEX and early Smalltalk.
% Kay credits Larry Tesler (slot inheritance), Henry Lieberman (delegation),
% and Bobrow and Winograd's KRL (Frames).
% InCollection ?
@Misc{kay1996early,
  title={The Early History of Smalltalk},
  author={Alan C. Kay},
  booktitle={History of programming languages---II},
  pages={511--598},
  year={1996},
  doi={10.1145/234286.1057828}
}

% PhDThesis
@book{Fisher1996thesis,
  title={Type Systems for object-oriented programming languages},
  author={Fisher, Kathleen Shanahan},
  year={1996},
  publisher={Stanford University}
}

% https://kbb04747.sites.pomona.edu/README.html#Match
% Good explanation of the problems with the NNOOTT
% "The notions of type and class are often confounded in object-oriented programming languages" p.5
@article{bruce1996typing,
  title={Typing in object-oriented languages: Achieving expressiveness and safety},
  author={Bruce, Kim B},
  journal={Unpublished, June},
  year={1996}
}

% https://www.stroustrup.com/hopl2.pdf
@inbook{stroustrup1996hopl,
  author = {Stroustrup, Bjarne},
  title = {A history of C++: 1979--1991},
  year = {1996},
  isbn = {0201895021},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/234286.1057836},
  abstract = {This paper outlines the history of the C++ programming language. The emphasis is on the ideas, constraints, and people that shaped the language, rather than the minutiae of language features. Key design decisions relating to language features are discussed, but the focus is one the overall design goals and practical constraints. The evolution of C++ is traced from C with Classes to the current ANSI and ISO standards work and the explosion of use, interest, commercial activity, compilers, tools, environments, and libraries.},
  booktitle = {History of Programming Languages---II},
  pages = {699–769},
  numpages = {71}
}

% InProceedings
@Misc{SubtypingMatch1997,
  doi={10.1007/BFb0053376},
  author="Bruce, Kim B.
and Petersen, Leaf
and Fiech, Adrian",
  editor="Ak{\c{s}}it, Mehmet
and Matsuoka, Satoshi",
  title="Subtyping is not a good ``match'' for object-oriented languages",
  booktitle="ECOOP'97 --- Object-Oriented Programming",
  year="1997",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="104--127",
  abstract="We present the design and rationale of a new statically-typed object-oriented language, LOOM. LOOM, retains most of the features of the earlier language PolyTOIL. However the subtyping relation is dropped from LOOM in favor of the matching relation. ``Hash types'', which are denned in terms of matching, are introduced to provide some of the benefits of subtyping. These types can be used to provide support for heterogeneous data stuctures in LOOM. LOOM. is considerably simpler than PolyTOIL, yet is just as expressive. The type system for the language is decidable and provably type safe. The addition of modules to the language provides better control over information hiding and allows the provision of access like that of C++'s friends.",
  ISBN="978-3-540-69127-3"
}

@Book{AbadiCardelli1997ToO,
  author = {Martín Abadi and Luca Cardelli},
  title = {A theory of objects},
  year = {1997},
  doi = {10.1007/978-1-4419-8598-9}
}

@InProceedings{aop97,
  author = {Kiczales, G. and Lamping, J. and Mendhekar, A. and Maeda, C. and Lopes, C. and Loingtier, J. M. and Irwin, J.},
  title = {Aspect-oriented programming},
  booktitle = {ECOOP},
  pages = {220--242},
  year = {1997}
}

@inproceedings{10.1145/301618.301638,
author = {Fisher, Kathleen and Reppy, John},
title = {The design of a class mechanism for Moby},
year = {1999},
isbn = {1581130945},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/301618.301638},
doi = {10.1145/301618.301638},
abstract = {Typical class-based languages, such as C++ and JAVA, provide complex class mechanisms but only weak module systems. In fact, classes in these languages incorporate many of the features found in richer module mechanisms. In this paper, we describe an alternative approach to designing a language that has both classes and modules. In our design, we rely on a rich ML-style module system to provide features such as visibility control and parameterization, while providing a minimal class mechanism that includes only those features needed to support inheritance. Programmers can then use the combination of modules and classes to implement the full range of class-based features and idioms. Our approach has the advantage that it provides a full-featured module system (useful in its own right), while keeping the class mechanism quite simple.We have incorporated this design in MOBY, which is an ML-style language that supports class-based object-oriented programming. In this paper, we describe our design via a series of simple examples, show how various class-based features and idioms are realized in MOBY, compare our design with others, and sketch its formal semantics.},
booktitle = {Proceedings of the ACM SIGPLAN 1999 Conference on Programming Language Design and Implementation},
pages = {37–49},
numpages = {13},
location = {Atlanta, Georgia, USA},
series = {PLDI '99}
}

@article{10.1145/301631.301638,
  author = {Kathleen Fisher and John Reppy},
  title = {The Design of a Class Mechanism for Moby},
  year = {1999},
  issue_date = {May 1999},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {34},
  number = {5},
  issn = {0362-1340},
  url = {https://doi.org/10.1145/301631.301638},
  doi = {10.1145/301631.301638},
  abstract = {Typical class-based languages, such as C++ and JAVA, provide complex class mechanisms but only weak module systems. In fact, classes in these languages incorporate many of the features found in richer module mechanisms. In this paper, we describe an alternative approach to designing a language that has both classes and modules. In our design, we rely on a rich ML-style module system to provide features such as visibility control and parameterization, while providing a minimal class mechanism that includes only those features needed to support inheritance. Programmers can then use the combination of modules and classes to implement the full range of class-based features and idioms. Our approach has the advantage that it provides a full-featured module system (useful in its own right), while keeping the class mechanism quite simple.We have incorporated this design in MOBY, which is an ML-style language that supports class-based object-oriented programming. In this paper, we describe our design via a series of simple examples, show how various class-based features and idioms are realized in MOBY, compare our design with others, and sketch its formal semantics.},
  journal = {SIGPLAN Not.},
  month = may,
  pages = {37–49},
  numpages = {13}
}

% CBPV
@InProceedings{conf/tlca/Levy99,
  title = {Call-by-Push-Value: A Subsuming Paradigm},
  year = {1999},
  author = {Blain Levy, Paul},
  publisher = {Springer},
  booktitle = {Typed Lambda Calculi and Applications, 4th International Conference, TLCA'99, L'Aquila, Italy, April 7-9, 1999, Proceedings},
  pages = {228--243},
  doi = {10.1007/3-540-48959-2_17}
}

% Defines a dialect of Java with mixins, MixedJava, to illustrate the approach taken in MzScheme,
% later better described in their 2006 paper.
% https://www.semanticscholar.org/paper/Classes-and-mixins-Flatt-Krishnamurthi/c20e5f2a424b96209e6b400b23d319558932afa3
@Misc{Mixins1998,
  author = {Flatt, Matthew and Krishnamurthi, Shriram and Felleisen, Matthias},
  title = {Classes and mixins},
  year = {1998},
  isbn = {0897919793},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/268946.268961},
  doi = {10.1145/268946.268961},
  abstract = {While class-based object-oriented programming languages provide a flexible mechanism for re-using and managing related pieces of code, they typically lack linguistic facilities for specifying a uniform extension of many classes with one set of fields and methods. As a result, programmers are unable to express certain abstractions over classes.In this paper we develop a model of class-to-class functions that we refer to as mixins. A mixin function maps a class to an extended class by adding or overriding fields and methods. Programming with mixins is similar to programming with single inheritance classes, but mixins more directly encourage programming to interfaces.The paper develops these ideas within the context of Java. The results are 1. an intuitive model of an essential Java subset; 2. an extension that explains and models mixins; and 3. type soundness theorems for these languages.},
  booktitle = {Proceedings of the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages = {171–183},
  numpages = {13},
  location = {San Diego, California, USA},
  series = {POPL '98}
}

@Misc{ecmascript,
  title={ECMAScript Language Specification},
  author={ECMA, Final Draft},
  year={1999}
}

% Implements proper multiple inheritance on top of C++, but
% you have to manually linearize and pass the Super in a template.
% InProceedings
@Misc{smaragdakis2000mixin,
  title={Mixin-based programming in C++},
  author={Yannis Smaragdakis and Don Batory},
  booktitle={International Symposium on Generative and Component-Based Software Engineering},
  pages={164--178},
  year={2000},
  organization={Springer}
}

% https://www.math.nagoya-u.ac.jp/~garrigue/papers/variant-reuse.pdf
% Open Recursion, etc., is not just for extensible products, but also extensible variants.
% The requirement for the subclass's type to be a subtype is imbecillic at best,
% even at the specification level, what more at the target level.
@inproceedings{garrigue2000code,
  title={Code reuse through polymorphic variants},
  author={Garrigue, Jacques},
  booktitle={Workshop on Foundations of Software Engineering},
  volume={13},
  year={2000}
}

@InProceedings{DSU2001,
  author = {Hicks, Michael and Moore, Jonathan T. and Nettles, Scott},
  title = {Dynamic Software Updating},
  year = {2001},
  isbn = {1581134142},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/378795.378798},
  doi = {10.1145/378795.378798},
  abstract = {Many important applications must run continuously and without interruption, yet must be changed to fix bugs or upgrade functionality. No prior general-purpose methodology for dynamic updating achieves a practical balance between flexibility, robustness, low overhead, and ease of use.We present a new approach for C-like languages that provides type-safe dynamic updating of native code in an extremely flexible manner (code, data, and types may be updated, at programmer-determined times) and permits the use of automated tools to aid the programmer in the updating process. Our system is based on dynamic patches that both contain the updated code and the code needed to transition from the old version to the new. A novel aspect of our patches is that they consist of verifiable native code (e.g. Proof-Carrying Code [17] or Typed Assembly Language [16]), which is native code accompanied by annotations that allow on-line verification of the code's safety. We discuss how patches are generated mostly automatically, how they are applied using dynamic-linking technology, and how code is compiled to make it updateable.To concretely illustrate our system, we have implemented a dynamically-updateable web server, FlashEd. We discuss our experience building and maintaining FlashEd. Performance experiments show that for FlashEd, the overhead due to updating is typically less than 1\%.},
  booktitle = {Proceedings of the ACM SIGPLAN 2001 Conference on Programming Language Design and Implementation},
  pages = {13–23},
  numpages = {11},
  location = {Snowbird, Utah, USA},
  series = {PLDI '01}
}

@InProceedings{SullivanGriswoldCaiHallen2001,
  author = {Sullivan, Kevin J. and Griswold, William G. and Cai, Yuanfang and Hallen, Ben},
  title = {The Structure and Value of Modularity in Software Design},
  year = {2001},
  isbn = {1581133901},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/503209.503224},
  doi = {10.1145/503209.503224},
  abstract = {The concept of information hiding modularity is a cornerstone of modern software design thought, but its formulation remains casual and its emphasis on changeability is imperfectly related to the goal of creating added value in a given context. We need better explanatory and prescriptive models of the nature and value of information hiding. We evaluate the potential of a new theory---developed to account for the influence of modularity on the evolution of the computer industry---to inform software design. The theory uses design structure matrices to model designs and real options techniques to value them. To test the potential utility of the theory for software we apply it to Parnas's KWIC designs. We contribute an extension to design structure matrices, and we show that the options results are consistent with Parnas's conclusions. Our results suggest that such a theory does have potential to help inform software design.},
  booktitle = {Proceedings of the 8th European Software Engineering Conference Held Jointly with 9th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  pages = {99–108},
  numpages = {10},
  keywords = {real options, design structure matrix, modularity, software},
  location = {Vienna, Austria},
  series = {ESEC/FSE-9}
}

% See notably chapters 18, 19, 24, 32.
% downloaded from https://www.cs.sjtu.edu.cn/~kzhu/cs383/Pierce_Types_Programming_Languages.pdf
% This post claims that TAPL introduces the term "Open Recursion" https://journal.stuffwithstuff.com/2013/08/26/what-is-open-recursion/ - but Cardelli 1992 mentions it already.
% 32.10 Notes gives pointers to a lot of papers on types for OO.
% ... see a system $F_{<:}^\omega$
% See note on PT1993STTFOOP about the approach of letting the user provide a rep type.
% Pierce does discuss the actual solution, recursive data types, but
% leaves it as an exercise after pointing to the bibliography.
@Book{Pierce2002TAPL,
  Author = {Pierce, Benjamin C.},
  Title = {Types and Programming Languages},
  Year = {2002},
  ISBN = {0262162091},
  Publisher = {MIT Press},
  Edition = {1st},
  url = {https://www.cis.upenn.edu/~bcpierce/tapl/}
}

% inproceedings
@Misc{findler2002contracts,
  title={Contracts for higher-order functions},
  author={Findler, Robert Bruce and Felleisen, Matthias},
  booktitle={Proceedings of the seventh ACM SIGPLAN international conference on Functional programming},
  pages={48--59},
  year={2002},
  url={https://users.cs.northwestern.edu/~robby/publications/papers/ho-contracts-icfp2002.pdf}
}

@Misc{Kay2003,
  Author={Alan Kay},
  Title={Clarification of "object-oriented" (email)},
  URL={https://www.purl.org/stefan_ram/pub/doc_kay_oop_en},
  Year={2003},
  Month={07},
  Day={23}
}

% https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=693f61d2515ac9b032801dd7a603c34f1b725071
% Wrongly claims that multidispatch forgoes modular typechecking
% Has no definition of modularity, except maybe for typechecking
@phdthesis{millstein2003reconciling,
  title={Reconciling software extensibility with modular program reasoning},
  author={Millstein, Todd David},
  year={2003},
  school={University of Washington},
  doi={10.5555/997550},
  url={https://web.cs.ucla.edu/~todd/research/dissertation.pdf}
}

% Section 3.8 Dynamic Code Change describes support for hot code upgrade;
% Only 2 versions of the code allowed; at the 3rd, processes using the 1st are killed.
% I *suppose* that means there are again only 2 versions,
% and only 1 after all processes are fully updated.
% module-qualified name = dynamic, unqualified = static. Tail-call recommended but not mandated.
% https://erlang.org/download/armstrong_thesis_2003.pdf
@phdthesis{DBLP:phd/basesearch/Armstrong03,
  author       = {Joe Armstrong},
  title        = {Making reliable distributed systems in the presence of software errors},
  school       = {Royal Institute of Technology, Stockholm, Sweden},
  year         = {2003},
  url          = {https://nbn-resolving.org/urn:nbn:se:kth:diva-3658},
  urn          = {urn:nbn:se:kth:diva-3658},
  timestamp    = {Mon, 21 Nov 2022 17:42:05 +0100},
  biburl       = {https://dblp.org/rec/phd/basesearch/Armstrong03.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}


@InProceedings{Salzman05prototypeswith,
  author = {Lee Salzman and Jonathan Aldrich},
  title = {Prototypes with multiple dispatch: An expressive and dynamic object model},
  booktitle = {ECOOP},
  year = {2005},
  abstract="Two object-oriented programming language paradigms---dynamic, prototype-based languages and multi-method languages---provide orthogonal benefits to software engineers. These two paradigms appear to be in conflict, however, preventing engineers from realizing the benefits of both technologies in one system. This paper introduces a novel object model, prototypes with multiple dispatch (PMD), which seamlessly unifies these two approaches. We give formal semantics for PMD, and discuss implementation and experience with PMD in the dynamically typed programming language Slate."
}

@article{scalableComponentAbstractions2005,
  author = {Odersky, Martin and Zenger, Matthias},
  title = {Scalable component abstractions},
  year = {2005},
  issue_date = {October 2005},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {40},
  number = {10},
  issn = {0362-1340},
  %url = {https://doi.org/10.1145/1103845.1094815},
  url = {http://lampwww.epfl.ch/~odersky/papers/ScalableComponent.pdf},
  doi = {10.1145/1103845.1094815},
  abstract = {We identify three programming language abstractions for the construction of reusable components: abstract type members, explicit selftypes, and modular mixin composition. Together, these abstractions enable us to transform an arbitrary assembly of static program parts with hard references between them into a system of reusable components. The transformation maintains the structure of the original system. We demonstrate this approach in two case studies, a subject/observer framework and a compiler front-end.},
  journal = {SIGPLAN Not.},
  month = {oct},
  pages = {41--57},
  numpages = {17},
  keywords = {Scala, abstract types, classes, components, mixins},
  isbn = {1595930310},
  %booktitle = {Proceedings of the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
  %%booktitle = {OOPSLA '05},
  booktitle = {OOPSLA},
  location = {San Diego, CA, USA},
  series = {OOPSLA '05}
}

@misc{Kiselyov2005HaskellOOS,
      title={Haskell's overlooked object system},
      author={Oleg Kiselyov and Ralf Lämmel},
      year={2005},
      eprint={cs/0509027},
      archivePrefix={arXiv},
      primaryClass={cs.PL},
      url={https://arxiv.org/abs/cs/0509027},
}

@InProceedings{Flatt2006Mixins,
  author = {Matthew Flatt and Robert Bruce Findler and Matthias Felleisen},
  title = {Scheme with classes, mixins, and traits},
  booktitle = {In Asian Symposium on Programming Languages and Systems (APLAS) 2006},
  year = {2006},
  pages = {270--289},
  url = {https://www2.ccs.neu.edu/racket/pubs/asplas06-fff.pdf}
}

@InProceedings{BruceCardelliPierce2006,
    author = {Kim B. Bruce and Luca Cardelli and Benjamin C. Pierce},
    title = {Comparing Object Encodings},
    booktitle = {Journal of Functional Programming},
    volume = {16},
    pages = {375-–414},
    year = {2006},
}
% http://citeseerx.ist.psu.edu/viewdoc/similar?doi=10.1.1.211.6777&type=cc

% Section 4.2 describes the failure of their "sender path" attempt at multiple inheritance
@InProceedings{self2007hopl,
  author = {Ungar, David and Smith, Randall B.},
  title = {Self},
  year = {2007},
  isbn = {9781595937667},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1238844.1238853},
  doi = {10.1145/1238844.1238853},
  abstract = {The years 1985 through 1995 saw the birth and development of the language Self, starting from its design by the authors at Xerox PARC, through first implementations by Ungar and his graduate students at Stanford University, and then with a larger team formed when the authors joined Sun Microsystems Laboratories in 1991. Self was designed to help programmers become more productive and creative by giving them a simple, pure, and powerful language, an implementation that combined ease of use with high performance, a user interface that off-loaded cognitive burden, and a programming environment that captured the malleability of a physical world of live objects. Accomplishing these goals required innovation in several areas: a simple yet powerful prototype-based object model for mainstream programming, many compilation techniques including customization, splitting, type prediction, polymorphic inline caches, adaptive optimization, and dynamic deoptimization, the application of cartoon animation to enhance the legibility of a dynamic graphical interface, an object-centered programming environment, and a user-interface construction framework that embodied a uniform use-mention distinction. Over the years, the project has published many papers and released four major versions of Self.Although the Self project ended in 1995, its implementation, animation, user interface toolkit architecture, and even its prototype object model impact computer science today (2006). Java virtual machines for desktop and laptop computers have adopted Self's implementation techniques, many user interfaces incorporate cartoon animation, several popular systems have adopted similar interface frameworks, and the prototype object model can be found in some of today's languages, including JavaScript. Nevertheless, the vision we tried to capture in the unified whole has yet to be achieved.},
  booktitle = {Proceedings of the Third ACM SIGPLAN Conference on History of Programming Languages},
  pages = {9–1–9–50},
  keywords = {virtual machine, prototype-based programming language, programming environment, object-oriented language, morphic, history of programming languages, exploratory programming, dynamic optimization, dynamic language, cartoon animation, adaptive optimization, Self},
  location = {San Diego, California},
  series = {HOPL III}
}

% NB: Extended version of the seminal 2005 TOPLAS paper.
% For a history of lenses, see Jules Hedges' https://julesh.com/2018/08/16/lenses-for-philosophers/
@Article{Foster2007CombinatorsFB,
  title={Combinators for bidirectional tree transformations: A linguistic approach to the view-update problem},
  author={Nate Foster and M. Greenwald and J. T. Moore and B. Pierce and A. Schmitt},
  journal={ACM Trans. Program. Lang. Syst.},
  year={2007},
  volume={29},
  url={https://www.cis.upenn.edu/~bcpierce/papers/lenses-full.pdf}
}

@article{bracha2008newspeak,
  title={The Newspeak Programming Platform},
  author={Bracha, Gilad and Ahe, Peter and Bykov, Vassili and Kashai, Yaron and Miranda, Eliot},
  journal={Cadence Design Systems},
  year={2008}
}

% Master Thesis. BCL
@TechReport{gclviewer2008,
  Author = "Ibrahim Bokharouss",
  Title = "GCL Viewer: a study in improving the understanding of GCL programs",
  Institution = {Eindhoven University of Technology},
  year = 2008,
  url = {https://research.tue.nl/en/studentTheses/gcl-viewer}
  }
% https://pure.tue.nl/ws/portalfiles/portal/46927079/638953-1.pdf

@InProceedings{dolstra2008nixos,
  title={NixOS: A purely functional Linux distribution},
  author={Dolstra, Eelco and L{\"o}h, Andres},
  booktitle={Proceedings of the 13th ACM SIGPLAN international conference on Functional programming},
  pages={367--378},
  year={2008},
  url={https://edolstra.github.io/pubs/nixos-jfp-final.pdf}
}

% April 2
@Misc{minsky08,
  author = {Yaron Minsky},
  title = {The {ML} sweet spot},
  year = 2008,
  url = {https://blog.janestreet.com/the-ml-sweet-spot/},
  urldate = {2021-03-14}
}

% From the Fortress team
@InProceedings{allen2011type,
  title={Type checking modular multiple dispatch with parametric polymorphism and multiple inheritance},
  author={Allen, Eric and Hilburn, Justin and Kilpatrick, Scott and Luchangco, Victor and Ryu, Sukyoung and Chase, David and Steele, Guy},
  booktitle={OOPSLA},
  pages={973--992},
  year={2011},
  url={https://people.mpi-sws.org/~skilpat/papers/multipoly.pdf}
}

% EOPL only has classes with single inheritance.
% barely touches multiple inheritance, "powerful, but … problematic", in exercise 9.26,
% and prototypes in exercise 9.27-9.29
@book{eopl3,
  author = {Friedman, Daniel P. and Haynes, Christopher T. and Wand, Mitchell},
  title = {Essentials of Programming Languages (3rd Ed.)},
  year = {2008},
  publisher = {Massachusetts Institute of Technology},
  address = {USA},
  url = {https://www.eopl3.com/}
}

% PLAI 1st ed has objects as closures and even prototypes in ch 10.
% 10.3.3 shits on multiple inheritance.
% 10.3.5 introduces mixins as a mechanism on top of first-class single-inheritance classes.
@book{plai,
  author = {Shriram Khrisnamurthi},
  title = {Programming Languages: Application and Interpretation (1st Ed.)},
  year = {2008},
  publisher = {Massachusetts Institute of Technology},
  address = {USA},
  url = {https://plai.org/},
}

@InProceedings{Brown_functioninheritance:,
  author = {Daniel Brown and William R. Cook},
  title = {Function Inheritance: Monadic Memoization Mixins},
  booktitle = {Brazilian Symposium on Programming Languages},
  year = {2009},
}

% TODO
% Claims that objects are about modularity of "classes" used only through "interfaces", not inheritance
@Misc{Cook2009,
  author = {William Cook},
  title = {On Understanding Data Abstraction, Revisited},
  year = 2009
}

% Unpublished
@Misc{MonadsMixins,
  title = "The Different Aspects of Monads and Mixins",
  author = "Oliveira, Bruno C. d. S.",
  year = {2009},
  url = {https://www.cs.ox.ac.uk/publications/publication2965-abstract.html}
}

@InProceedings{Oliveira10effectiveadvice,
  author = {Oliveira, Bruno C. d. S. and Schrijvers, Tom and Cook, William R.},
  title = {EffectiveAdvice: disciplined advice with explicit effects},
  booktitle = {AOSD’10: 9th International Conference on Aspect-Oriented Software Development},
  pages = {109--120},
  year = {2010}
}

% Why won't InProceedings work in eoo* ?
@InProceedings{ASDF2,
  author = {François-René Rideau and Robert Goldman},
  title = {Evolving ASDF: More Cooperation, Less Coordination},
  year = {2010},
  booktitle = {International Lisp Conference},
  url = {http://common-lisp.net/project/asdf/doc/ilc2010draft.pdf}
}

@Misc{OOP2010,
  title={Ralph Johnson, Joe Armstrong on the State of OOP (Interview at QCon)},
  author={Ralph Johnson and Joe Armstrong},
  year={2010},
  url={https://www.infoq.com/interviews/johnson-armstrong-oop/}
}

% Incommensurability -- uses bracha1990mixin as its pivot!
@inproceedings{gabriel2012,
  title={The Structure of a Programming Language Revolution},
  author={Richard P. Gabriel},
  booktitle={Proceedings of the ACM international symposium on New ideas, new paradigms, and reflections on programming and software},
  pages={195--214},
  year={2012},
  url={https://www.dreamsongs.com/Files/Incommensurability.pdf}
}

@misc{oconnor2012lenses,
  author    = {Russell O’Connor},
  title     = {Polymorphic Update with van Laarhoven Lenses},
  year      = {2012},
  month     = {June},
  day       = {23},
  url       = {http://r6.ca/blog/20120623T104901Z.html},
  urldate   = {2025-12-01},
  howpublished = {Blog post}
}

@InProceedings{LIL2012,
  author = {François-René Rideau},
  title = {{LIL}: {CLOS} ~ Reaches Higher-Order, Sheds Identity and has a Transformative Experience},
  url = "http://github.com/fare/lil-ilc2012/",
  booktitle = {International Lisp Conference},
  year = 2012
}

% My replies: https://twitter.com/Ngnghm/status/1791988260266234028
% XXXX UPDATE ENTRY
@Misc{Cook2012,
  author = {William Cook},
  title = {A Proposal for Simplified, Modern Definitions of "Object" and "Object Oriented"},
  url = {https://wcook.blogspot.com/2012/07/proposal-for-simplified-modern.html},
  year = 2012
}

% @online leads to scribble complaining about undefined tag(?)
@Misc{jsonnet,
  author = {Dave Cunningham},
  title = {Jsonnet},
  year = 2014,
  url = {https://jsonnet.org},
  urldate = {2021-03-11},
  note = {Accessed 2021-03-01}
}

% Random memory access is in sqrt(N) where N is the size of the working set
% @online
@misc{MythOfRAM2014,
  author    = {Emil Ernerfeldt},
  title     = {The Myth of RAM},
  year      = {2014},
  month     = {April},
  day       = {21},
  url       = {https://www.ilikebigbits.com/2014_04_21_myth_of_ram_1.html},
  urldate   = {2025-12-01},
  note      = {Accessed 2025-12-01},
  howpublished = {Blog post}
}



% InProceedings
@Misc{ASDF3,
  author = {François-René Rideau},
  title = {{ASDF 3}, or {W}hy {L}isp is {N}ow an {A}cceptable {S}cripting {L}anguage},
  url = "https://github.com/fare/asdf3-2013",
  booktitle = {European Lisp Symposium},
  year = 2014
}

@Book{EcmaScript:15,
  added-at = {2015-08-28T15:36:26.000+0200},
  address = {Geneva},
  author = {{Ecma International}},
  biburl = {https://www.bibsonomy.org/bibtex/28d67e2ebf933f3b6f684fcfb1f53b020/gron},
  edition = {6th},
  interhash = {8212a5bb4b7ac3137534f10d599cb526},
  intrahash = {8d67e2ebf933f3b6f684fcfb1f53b020},
  keywords = {JavaScript spec specification},
  month = {June},
  timestamp = {2015-08-28T15:37:30.000+0200},
  title = {{ECMAScript 2015 Language Specification}},
  url = {http://www.ecma-international.org/ecma-262/6.0/ECMA-262.pdf},
  year = 2015
}

@Misc{nix2015,
  title={Nixpkgs fixed-points library},
  author={Peter Simons},
  url={https://github.com/NixOS/nixpkgs/blob/master/lib/fixed-points.nix},
  year={2015},
  urldate={2023-11-29},
  note = {Accessed 2023-11-29}
}

% This article is great in desugaring the prototype sublanguage of JS,
% but doesn't cover classes.
@Article{DBLP:journals/corr/GuhaSK15,
  author    = {Arjun Guha and
               Claudiu Saftoiu and
               Shriram Krishnamurthi},
  title     = {The Essence of JavaScript},
  journal   = {CoRR},
  volume    = {abs/1510.00925},
  year      = {2015},
  url       = {http://arxiv.org/abs/1510.00925},
  archivePrefix = {arXiv},
  eprint    = {1510.00925},
  timestamp = {Mon, 13 Aug 2018 16:46:22 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/GuhaSK15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@Misc{grigore2016javagenericsturingcomplete,
      title={Java Generics are Turing Complete},
      author={Radu Grigore},
      year={2016},
      eprint={1605.05274},
      archivePrefix={arXiv},
      primaryClass={cs.PL},
      url={https://arxiv.org/abs/1605.05274},
}

@Misc{ngnghm9,
  author = {François-René Rideau},
  title = {Build Systems and Modularity},
  year = 2016,
  url = {https://ngnghm.github.io/blog/2016/04/26/chapter-9-build-systems-and-modularity/},
  urldate = {2023-11-29}
}


% https://sci-hub.ru/https://link.springer.com/chapter/10.1007/978-3-319-30936-1_4
% Has two elaborate examples of how inheritance can help better define software.
% https://x.com/Ngnghm/status/1988891187340615763
% It saddens me when three authors I love and respect wallow in disenlightening handwaving instead of seeking and bringing clarity.
% It's not that the paper says anything outright false, but that it accepts complexity, ineffable semantics, and abandons the ambition of clear knowledge—all that in a vain attempt to thereby convince Wadler that inheritance is useful, by example.
% Also, I find the examples long-winded. Maybe the one that takes on a Wadler paper is relevant to Wadler—but I would think the example was artificial even to him. And the Armstrong example is also way too much investment to the payoff.
% Finally, the mistreatment of multiple inheritance, what more citing Cook 1990 and Snyder 1986 about "conflicts" when Cannon 1979 showed there needed not be conflicts (solution ignored by C++ but adopted by Lisp, Ruby, Python, Scala)... it feels like OO academia missed the train.
@incollection{EssenceOfInheritance2016,
  title={The Essence of Inheritance},
  author={Black, Andrew P and Bruce, Kim B and Noble, James},
  booktitle={A List of Successes That Can Change the World: Essays Dedicated to Philip Wadler on the Occasion of His 60th Birthday},
  pages={73--94},
  year={2016},
  publisher={Springer}
}

@Article{Pickering_2017,
  title={Profunctor Optics: Modular Data Accessors},
  volume={1},
  ISSN={2473-7321},
  url={http://dx.doi.org/10.22152/programming-journal.org/2017/1/7},
  DOI={10.22152/programming-journal.org/2017/1/7},
  number={2},
  journal={The Art, Science, and Engineering of Programming},
  publisher={Aspect-Oriented Software Association (AOSA)},
  author={Pickering, Matthew and Gibbons, Jeremy and Wu, Nicolas},
  year={2017},
  month={Apr}
}

% Withhold citation until after deanomization
@Misc{GerbilPOOwithheld,
  author = {Author withheld},
  title = {Title withheld},
  url = {https://github.com/repository/withheld},
  year = 2020
}

@Misc{GerbilPOO,
  author = {François-René Rideau},
  title = {Gerbil-POO},
  year = 2020,
  url = {https://github.com/fare/gerbil-poo},
  urldate = {2021-04-06}
}

@Misc{Kay2020,
  title={What thought process would lead one to invent Object-Oriented Programming?},
  author={Alan Kay},
  year={2020},
  url={https://www.quora.com/What-thought-process-would-lead-one-to-invent-object-oriented-programming/answer/Alan-Kay-11}
}

% Maybe cite the last episode of this story instead, that explains the concept?
% https://en.wikipedia.org/wiki/Earthshock
% On citing TV series:
% https://www.easybib.com/guides/citation-guides/how-do-i-cite-a/how-to-cite-movie-tv-netflix/
@Misc{DrWhoFPIT,
  author = {Unknown},
  title = {Fixed Point in Time},
  year = 2021,
  url = {https://tardis.fandom.com/wiki/Fixed_point_in_time},
  urldate = {2021-03-14}
}

@Misc{WikiC3,
  title = "C3 linearization",
  author = "Wikipedia",
  year = 2021,
  url = {https://en.wikipedia.org/wiki/C3_linearization},
}

@Misc{WikiProto,
  title = "Prototype-based programming",
  author = "Wikipedia",
  year = 2025,
  url = {https://en.wikipedia.org/wiki/Prototype-based_programming},
}

% References Butler Lampson https://bwlampson.site/Slides/TuringLecture.htm
% "We can solve any problem by introducing an extra level of indirection"
@Misc{WikiFTSE,
  title = "Fundamental theorem of software engineering",
  author = "Wikipedia",
  year = 2025,
  url = {https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering},
}

@InProceedings{poof2021,
  title = {Prototypes: Object-Orientation, Functionally},
  author = {François-René Rideau and Alex Knauth and Nada Amin},
  year = {2021},
  booktitle = {Scheme and Functional Programming Workshop},
  url = {https://github.com/metareflection/poof},
}

@Misc{POP2021,
  author =       {François-René Rideau},
  title =        {Pure Object Prototypes},
  url =          {https://github.com/divnix/POP},
  year =         {2021}
}

@Misc{TopPL2022,
  author =       {GitHub},
  title =        {The top programming languages},
  url =          {https://octoverse.github.com/2022/top-programming-languages},
  year =         2022,
  urldate =      {2024-01-04}
}

%%% TODO: Add the following...

% Conway's Law
% Conway, Melvin (1968). "How do committees invent" (PDF). Datamation: 28–31.

% 1979 https://constraints.cs.washington.edu/ui/thinglab-tr.pdf

% Wegner Zdonik "Inheritance as an incremental modification mechanism or what Like is or isn't like" 1988

% [2] Object-Oriented Programming Versus Abstract Data Types In Proceedings of the REX School/Workshop on Foundations of Object-Oriented Languages, Springer-Verlag, pp. 151-178 (1990).
% http://www.cs.utexas.edu/~wcook/papers/OOPvsADT/CookOOPvsADT90.pdf
% PDA (Procedural Data Abstraction) organized around constructors (for classes, etc.) vs
% ADT (Abstract Data Types) organized around observations (pattern-matching for data types).
% Cook is baffled by CLOS and its multimethods wrt his PDA (like Smalltalk) vs ADT (like CLU)

% William R. Cook: On Understanding Data Abstraction, Revisited
% [1] On understanding data abstraction, revisited. Onward! Essay in Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications (OOPSLA). pp. 557-572 (2009).
% https://cs.utexas.edu/~wcook/Drafts/2009/essay.pdf
% Good presentation of ADTs
% 3.1 notes the "OO" (re)presentation eschews the existential type, hiding it under HOF i/f,
% but that's false in general---the existential type is there for compatibility between values you can build and modify.
% 3.2 claims with ref to his thesis that inheritance is orthogonal to OO (!)
% misses that what makes method invocation "dynamic binding" isn't the HOF records,
% but the open recursion on self and the sharing of methods between multiple selves
% thanks to inheritance.
% Also identifies classes as their constructor...
% 3.3 "Autognosis" is the criterion what Bracha calls "Pure OO", i.e. all accesses through interface
% Wholly skips CLOS, unlike his 1990 paper.
% Wholly skips Prototypes.
% In the end, does not bring much lights to the topic, beyond the obvious.


% Bracha and Lindstrom 1992 Modularity meets inheritance

% 2000 Oleg Kiselyov USENET post on okmij.org on the possibility of a pure variant of YASOS ?

% Featherweight Jigsaw - Replacing inheritance by composition in Java-like languages
% https://dl.acm.org/doi/10.1016/j.ic.2012.02.004

% C++ template lambda calculus https://gist.github.com/glaebhoerl/8970f682958826ed36f9

% TODO: trace prototypes back to earlier Actor systems???
%
% Hewitt, Carl, Viewing Control Structures as Patterns of Passing Messages, MIT AI Lab Memo 410, Dec 1976.

% Adding POP to Nixpkgs:
% https://github.com/NixOS/rfcs/pull/91/
% https://github.com/NixOS/nixpkgs/pull/116275
% https://github.com/divnix/POP

% Gilad Bracha's Newspeak? It's class-based only, though.

% C2 wiki?
% https://wiki.c2.com/?PrototypeBasedProgramming
% https://wiki.c2.com/?ClassesPrototypesComparison
% https://wiki.c2.com/?PrototypeBasedLanguage
% "Popular" Prototype language: NewtonScript, LambdaMOO, Io, REBOL, Lua...

% ThingLab https://github.com/cdglabs/thinglab

% https://okmij.org/ftp/Computation/typeclass.html#Kaes

% Kaes ESOP 1988
% Stefan Kaes: Parametric overloading in polymorphic programming languages
%Proc. ESOP 1988, Springer's LNCS 300, pp. 131-144
% <http://link.springer.com/chapter/10.1007%2F3-540-19027-9_9>

% Stefan Kaes: Parametrischer Polymorphismus, Ueberladungen und Konversionen
% Dissertation: TU Darmstadt, Fachbereich Informatik, 2005
% <http://tuprints.ulb.tu-darmstadt.de/epda/000544/>

% A History of Haskell: being lazy with class
% Simon Peyton Jones
% The Third ACM SIGPLAN History of Programming Languages Conference (HOPL-III) | June 2007
% https://www.microsoft.com/en-us/research/publication/a-history-of-haskell-being-lazy-with-class/

% http://okmij.org/ftp/Computation/Subtyping/

% Barak Pearlmutter & Kevin Lang's Oaklisp https://github.com/barak/oaklisp

% Look at papers that cite Bracha 1990 on Semantic Scholar, including:
% https://www.semanticscholar.org/paper/Function-Inheritance-%3A-Monadic-Memoization-Mixins-Brown-Cook/d2bf5dc5c6c6bff91d10a0e2dceaaa13c2064765
% https://www.semanticscholar.org/paper/Object-Inheritance-Without-Classes-Jones-Homer/3dbc00e08dd1fa7c29faae9b2da544fb7e8d5579

% Modularity: ch4 and ch9 of taoup, e.g. http://www.catb.org/~esr/writings/taoup/html/ch04s02.html#orthogonality
% Semantics and Types for Objects with First-Class Member Names
% Joe Gibbs Politz, Arjun Guha, Shriram Krishnamurthi
% Foundations of Object-Oriented Languages, 2012
% https://cs.brown.edu/~sk/Publications/Papers/Published/pgk-sem-type-fc-member-name/

% Erik Ernst's work on gBeta:
% https://www.researchgate.net/publication/2806012_gbeta_-_a_Language_with_Virtual_Attributes_Block_Structure_and_Propagating_Dynamic_Inheritance

% Design Rules: The Power of Modularity,  by Baldwin & Clark

% Dart Book, by Gilad Bracha, Section 2.15 on mixins + examples all around, 5.9 on modularity

% StrongTalk.org still runs on Windows 10.

% CUE rejects inheritance, instead has value/pattern unification along a lattice: https://cuelang.org/docs/concepts/logic/

% https://www.piumarta.com/software/id-objmodel/objmodel2.pdf
% OOPSLA07

% Classes vs. Prototypes - Some Philosophical and Historical Observations
% Antero Taivalsaari • Journal of Object-Oriented Programming • Published 1996
% https://citeseerx.ist.psu.edu/doc_view/pid/30fcb7807ce73f16222761b97e36154f12349efb
% Indeed very philosophical with not enough computer science

% Jonathan Aldritch "The Power of Interoperability: Why Objects are Inevitable" Onward! 1993

% Zhang, Sun, Oliveira "Compositional Programming" TOPLAS 2021

% CECIL also had prototype inheritance / classless objects
% A cursory look at the manual does not mention mutable parents, however

% Introduces "traits", for multiple inheritance in the Mesa programming language
% used to implement WS, the workstation software of the Xerox Star 8010,
% since late 1979 (Mesa started early 1978 with Single-Inheritance).
% p.6 conflict resolution is manual.
@article{Traits,
  author = {Curry, Gael and Baer, Larry and Lipkie, Daniel and Lee, Bruce},
  title = {Traits: An approach to multiple-inheritance subclassing},
  year = {1982},
  issue_date = {June 21-23, 1982},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {3},
  number = {1–2},
  issn = {0737-819X},
  url = {https://doi.org/10.1145/966873.806468},
  doi = {10.1145/966873.806468},
  abstract = {This paper describes a new technique for organizing software which has been used successfully by the Xerox Star 8010 workstation. The workstation (WS) software is written in an “object-oriented” style: it can be viewed as a system of inter-communicating objects of different object types. Most of the WS software considers object types to be constructed by assembling more primitive abstractions called traits. A trait is a characteristic of an object, and is expressed as a set of operations which may be applied to objects carrying that trait. The traits model of subclassing generalizes the SIMULA-67 model by permitting multiple inheritance paths. This paper describes the relationship of WS software to the traits model and then describes the model itself.},
  journal = {ACM SIGOA Newsletter},
  month = {jun},
  pages = {1--9},
  numpages = {9}
}

% https://github.com/namin/dot
% https://namin.seas.harvard.edu/pubs/fool-dot.pdf
% More co-authors
@InProceedings{Amin2016DependentOT,
  title={Dependent Object Types},
  author={Nada Amin, Adriaan Moors, Martin Odersky},
  year={2016},
  url={https://api.semanticscholar.org/CorpusID:265751928}
}

% https://sci-hub.ru/https://link.springer.com/article/10.1007/BF01178920
% InProceedings
% Review of object inheritance for prototypes.
% Discusses multiple inheritance, but fails to cite Ani, ThingLab, T, Slate, Sheeple.
% Only passingly discusses super linearization or mixin inheritance. Sad.
@Misc{oiwc2016,
  author =	{Jones, Timothy and Homer, Michael and Noble, James and Bruce, Kim},
  title =	{{Object Inheritance Without Classes}},
  booktitle =	{30th European Conference on Object-Oriented Programming (ECOOP 2016)},
  pages =	{13:1--13:26},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-014-9},
  ISSN =	{1868-8969},
  year =	{2016},
  volume =	{56},
  editor =	{Krishnamurthi, Shriram and Lerner, Benjamin S.},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2016.13},
  URN =		{urn:nbn:de:0030-drops-61077},
  doi =		{10.4230/LIPIcs.ECOOP.2016.13},
  annote =	{Keywords: Inheritance, Objects, Classes, Operational semantics}
}

% Guy Steele "Objects have not failed" 2002 https://www.dreamsongs.com/ObjectsHaveNotFailedNarr.html

% https://lmcs.episciences.org/4319
% This paper seems to be on the right track, but with much extra formalism and much missing insight.
% Classes add a layer of complexity, and I think there may be bugs. Sigh.
@article{DBLP:journals/corr/abs-1712-06906,
  author       = {Jan Bessai and
                  Tzu{-}Chun Chen and
                  Andrej Dudenhefner and
                  Boris D{\"{u}}dder and
                  Ugo de'Liguoro and
                  Jakob Rehof},
  title        = {Mixin Composition Synthesis based on Intersection Types},
  journal      = {CoRR},
  volume       = {abs/1712.06906},
  year         = {2017},
  url          = {http://arxiv.org/abs/1712.06906},
  eprinttype    = {arXiv},
  eprint       = {1712.06906},
  timestamp    = {Sat, 30 Sep 2023 10:08:07 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-1712-06906.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

% Open Data Types and Open Functions https://www.andres-loeh.de/OpenDatatypes.pdf
% Andres Löh and Ralf Hinze, PPDP 2006 -- not really OO, just use of typeclasses.
% cites O'Haskell (Norlander 2001) vs OOHaskell (Kiselyov & Lämmel 2005)
% https://github.com/nkaretnikov/OOHaskell
% https://arxiv.org/pdf/cs/0509027
@article{Kiselyov2005HaskellsOO,
  title={Haskell's overlooked object system},
  author={Oleg Kiselyov and Ralf L{\"a}mmel},
  journal={ArXiv},
  year={2005},
  volume={abs/cs/0509027},
  url={https://api.semanticscholar.org/CorpusID:13547784}
}

% TODO: Henry Lieberman papers about Actors, etc. -- when did he do inheritance / delegation?

% 2003  Tom Hirschowitz  Call-by-value mixin modules
% https://hirschowitz.pages.math.cnrs.fr/phd/these-tom.pdf
% https://hirschowitz.pages.math.cnrs.fr/

% https://www.quora.com/Why-is-functional-programming-seen-as-the-opposite-of-OOP-rather-than-an-addition-to-it/answer/Henry-Story
%

% https://people.mpi-sws.org/~rossberg/mixml/
% Andreas Rossberg, Derek Dreyer. Mixin' Up the ML Module System. TOPLAS 35(1), 2013. Revised and significantly extended version of the ICFP paper, including material from the appendices and a lot more.
% Derek Dreyer, Andreas Rossberg. Mixin' Up the ML Module System. ICFP, 2008.
% Derek Dreyer, Andreas Rossberg. Mixin' Up the ML Module System (Extended Mix). Expanded version including technical appendices, 2008.

% More digging on the origins of OO:
% https://x.com/Ngnghm/status/1898493837040849348

% B. Jacobs, Coalgebraic Reasoning about Classes in Object-Oriented Languages. Electr. Notes in Theor. Comp. Sci. 11, 1998. (Special issue on the workshop Coalgebraic Methods in Computer Science (CMCS 1998))

% Peter Wegner. Concepts and Paradigms of O..O..P.. 1990

% Goguen...

% Studies λ-calculus with polymorphism, meets and joins, expresses naturals and others in it.
% Discusses the need for type annotations due to undecidable typechecking without.
% Does not discuss general fixpoints, though implicitly can deal with recursion for numbers.
% Fun, but not applicable to OO.
@article{pierce1991programming,
  title={Programming with intersection types, union types, and polymorphism},
  author={Pierce, Benjamin C},
  year={1991},
  publisher={Carnegie Mellon University}
}

% change-class: https://github.com/shriram/plai-public/issues/60

% Bob Harper PFPL existential types / inversion of scope

% Gilad recommends about Inheritance Hierarchies:
% Ossher and Harrison's "Combination of Inheritance Hierarchies' from OOPSLA 1992.

% Category theory:

% Category Theory in Programming
% Noah Ma <noahstorym@gmail.com>
% https://docs.racket-lang.org/ctp/index.html
%

@book{cct1988,
  author = {Rydeheard, David E. and Burstall, Rod M.},
  title = {Computational category theory},
  year = {1988},
  ISBN = {0131627368},
  doi={10.5555/49340},
  publisher = {Prentice Hall International (UK) Ltd.},
  url = {https://www.cs.man.ac.uk/~david/categories/book/book.pdf}
}

@article{mitchell1988abstract,
  title={Abstract types have existential type},
  author={Mitchell, John C and Plotkin, Gordon D},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={10},
  number={3},
  pages={470--502},
  year={1988},
  publisher={ACM New York, NY, USA}
}

% Introduces abstract classes and concrete classes, according to Grok
% https://www.cse.msu.edu/~cse870/Input/SS2002/MiniProject/Sources/DRC.pdf
@article{johnson1988designing,
  title={Designing reusable classes},
  author={Johnson, Ralph E and Foote, Brian},
  journal={Journal of object-oriented programming},
  volume={1},
  number={2},
  pages={22--35},
  year={1988}
}

% Cardelli Wegner 1985

% Recursion Scheme, FP & OOP ???
@article{gibbons2009essence,
  title={The essence of the iterator pattern},
  author={Gibbons, Jeremy and Oliveira, Bruno C d S},
  journal={Journal of functional programming},
  volume={19},
  number={3-4},
  pages={377--402},
  year={2009},
  publisher={Cambridge University Press}
}

% See this article and its bibliography? https://scholarworks.iu.edu/iuswrrest/api/core/bitstreams/2706b860-ef5e-42b9-98c6-f29e3486220e/content

% cite Douglas Engelbart's 1968 mother of all demos

% https://www.jot.fm/contents/issue_2017_02/article2.html

% https://www.dreamsongs.com/Files/LASC-Overview.pdf
% The Common Lisp Object System by Linda G. DeMichiel

% Does Yaohan Chu introduce the concept of HLL, or is it earlier?
% https://dl.acm.org/doi/pdf/10.1145/800181.810257

% 2024 Stephen H. Kaisler
% Medley LOOPS: The Basic System
% a.k.a. "Lisp Object-Oriented Programming System (LOOPS) Volume I: The Basic System"

% Authors of EuLisp don't like multiple inheritance, want mixin inheritance
@book{bretthauer1989multiple,
  title={Multiple Vs. Single Inheritance in Object-oriented Programming Languages: What Do We Really Want?},
  author={Bretthauer, Harry and Christaller, Thomas and Kopp, J{\"u}rgen},
  year={1989},
  publisher={Gesellschaft f{\"u}r Mathematik und Datenverarbeitung mbH}
}
