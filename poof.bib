%%% Bibliography, roughly sorted by year of publication
% (See TODO at the end for more)

@book{dumas1844,
  title={Les Trois Mousquetaires},
  author={Alexandre Dumas},
  year={1844}
}

% Calls objects and attributes the things being modeled, classes their types
% Records and fields the things doing the modeling, record classes their types.
% Introduces null for partial relationships (is that the first null???)
% No inheritance, sharing of attributes, etc. Classes are mutually exclusive.
@article{hoare1965record,
  title={Record handling},
  author={Hoare, C.A.R.},
  journal={Algol Bulletin},
  volume={21},
  pages={39--69},
  year={1965},
  url={http://archive.computerhistory.org/resources/text/Knuth_Don_X4100/PDF_index/k-9-pdf/k-9-u2293-Record-Handling-Hoare.pdf}
}

% Warren Teitelman MIT PhD dissertation "Pilot: A Step Toward Man-Computer Symbiosis" 1966
% Gabriel2012 claims it introduces mixins as "advice".

% Simula I back in 1966 has processes and more, but DOES NOT have OO
@article{Simula1966,
  author = {Dahl, Ole-Johan and Nygaard, Kristen},
  title = {SIMULA: An ALGOL-Based Simulation Language},
  year = {1966},
  issue_date = {Sept. 1966},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {9},
  number = {9},
  issn = {0001-0782},
  url = {https://doi.org/10.1145/365813.365819},
  doi = {10.1145/365813.365819},
  abstract = {This paper is an introduction to SIMULA, a programming language designed to provide a systems analyst with unified concepts which facilitate the concise description of discrete event systems. A system description also serves as a source language simulation program. SIMULA is an extension of ALGOL 60 in which the most important new concept is that of quasi-parallel processing.},
  journal = {Commun. ACM},
  month = {sep},
  pages = {671--678},
  numpages = {8}
}

% Ole-Johan Dahl and Kristen Nygaard. Class and subclass declarations 1967 (pdf)
% https://www.ub.uio.no/english/subjects/naturalscience-technology/informatics/themes/dns/index.html
% First implements classes, and introduces inheritance (though not the word);
% introduces the words "prefix class", "subclasses", "prefix sequence", "this", "inner".
% The "prefix" class also offers a suffix, and uses the "inner" separator to "split" its "body"
% and specify where the subclass body will go. BETA will also follow this approach
% of the superclass specifying how to compose with the subclass semantics,
% when most other OO languages take the approach of the subclass specifying
% how to reuse information specified by superclasses.
% "objects" have "attributes"
@Misc{Simula1967,
  author = {Dahl, Ole-Johan and Nygaard, Kristen},
  title = {Class and subclass declarations},
  year = {1967},
  url = {https://www.ub.uio.no/fag/naturvitenskap-teknologi/informatikk/faglig/dns/dokumenter/classandsubclass1967.pdf}
}

% Introduces the notion of "Ad hoc polymorphism"
@Misc{Strachey67,
  Author = {Christopher Strachey},
  Title = {Fundamental Concepts in Programming Languages},
  Year = {1967},
  url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.332.3161},
}

% More condensed than the above, with more language context
@Misc{Simula1968,
  Author = {Ole-Johan Dahl and Bjørn Myhrhaug and Kristen Nygaard},
  Title = {SIMULA 67 Common Base Language},
  Year = {1968},
  url = {https://web.archive.org/web/20131225084408/http://www.edelweb.fr/Simula/scb-1.pdf}
}

% Identifies class with procedure that computes an algorithm and constructs a record
% and yields current values multiple times to other activities with "detach" (call again for next)
% section 6 has "concatenation" for single inheritance
% InCollection
@Misc{dahl1972chapter,
  title={Chapter III: Hierarchical program structures},
  author={Dahl, Ole-Johan and Hoare, Charles Antony Richard},
  booktitle={Structured programming},
  pages={175--220},
  year={1972}
}

@Article{Parnas1972,
  author = {Parnas, D. L.},
  title = {On the Criteria to Be Used in Decomposing Systems into Modules},
  year = {1972},
  issue_date = {Dec. 1972},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {15},
  number = {12},
  issn = {0001-0782},
  url = {https://doi.org/10.1145/361598.361623},
  doi = {10.1145/361598.361623},
  abstract = {This paper discusses modularization as a mechanism for improving the flexibility and comprehensibility of a system while allowing the shortening of its development time. The effectiveness of a “modularization” is dependent upon the criteria used in dividing the system into modules. A system design problem is presented and both a conventional and unconventional decomposition are described. It is shown that the unconventional decompositions have distinct advantages for the goals outlined. The criteria used in arriving at the decompositions are discussed. The unconventional decomposition, if implemented with the conventional assumption that a module consists of one or more subroutines, will be less efficient in most cases. An alternative approach to implementation which does not have this effect is sketched.},
  journal = {Commun. ACM},
  month = {dec},
  pages = {1053--1058},
  numpages = {6},
  keywords = {modules, software, KWIC index, modularity, software engineering, software design}
}

% XXX TODO
% Hewitt, Bishop, Greif, Smith, Matson, Steiger
% Actor Induction and Meta-evaluation
% POPL
% 1973

% Minsky's 1974 paper on Frames uses the words "prototype" and "inherit", but incidentally,
% not at all to refer to the concepts at stake. MIT AIM-306
@article{minsky1974framework,
  title={A Framework for Representing Knowledge},
  author={Minsky, Marvin},
  year={1974},
  url={https://dspace.mit.edu/handle/1721.1/6089}
}

% 1975 Hewitt Stereotypes
% p.101 “The "frame" problem of McCarthy for assertional frames corresponds closely to
% the problems of "inheritance of attributes" and "default values" for object frames.
% For example the fable quoted by Minsky about the wolf and the lamb is very close to
% the frame problems of McCarthy.”
% Bibliography includes by McCarthy "Programs with Common Sense" (1958),
% and "Some philosophical problems from the standpoint of Artificial Intelligence" (1969),
% neither of which has it, and by Minksy "A Framework for Representing Knowledge",
% that discusses “"default" assignments” and discusses how the wolf is lying in accusing the lamb
% and the issues with representing knowledge for that.

% So far as I can tell, the earliest use of "inheritance", in "inheritance of properties", p. 197.,
% along the hierarchy of frames. The variant it designates is multiple-inheritance,
% though that word isn't coined. The exact resolution algorithm is not explained,
% As the title implies, this is not quite for *data* yet not quite for *code* but somewhere in between.
% https://api.pageplace.de/preview/DT0400.9781483299150_A23889670/preview-9781483299150_A23889670.pdf
%
% The use of the name "inheritance" is not fully formal, though.
% It is probably through Dan Ingalls' implementation of (single) inheritance in Smalltalk 1976
% that "inheritance" became formally known as such.
% Winograd also inspired Kahn and Borning for their Prototype OO systems, etc.
%
% Not sure how to name namings, but here are at least four kinds:
% - evocation: neither name nor concept owns the other, yet an allusion is made.
% - distinction: the name distinguishes the concept from others, but isn't owned by it.
% - identification: name and concept own each other, though the limits of the concept may not be clear.
% - definition: the essence of the concept being named is finally well understood.
% For "inheritance", evocation happened in Minsky 1975, distinction in Winograd 1975,
% and identification around 1976 quite possibly by Kay,
% practical definition in the early 1980s with Flavors and T,
% theoretical definition around 1990 by Cook & Bracha, and works on multipe inheritance culminating with C3.
% Final definition around 2025 by this very series of papers?
%
% not to name concepts in their formal object, rather as part of its informal (meta) context.
% Yet no doubt they primed Winograd for when he did use them to name concepts of KRL in 1975.
%
% InCollection
@Misc{Winograd1975,
  author = {Terry Winograd},
  title = {Frame Representations and the Declarative/Procedural Controversy},
  editor = {Daniel G. Bobrow and Allan Collins},
  booktitle = {Representation and Understanding},
  publisher = {Morgan Kaufmann},
  address = {San Diego},
  pages = {185-210},
  year = {1975},
  isbn = {978-0-12-108550-6},
  doi = {https://doi.org/10.1016/B978-0-12-108550-6.50012-4},
  url = {https://www.sciencedirect.com/science/article/pii/B9780121085506500124},
  abstract = {Publisher Summary
This chapter presents some criteria for evaluating ideas for representation. It also presents a rough sketch of a particular version of a frame representation, and discusses the ways in which it can deal with the issues raised. The proceduralists assert that human knowledge is primarily a knowing how. The human information processor is a stored program device, with its knowledge of the world embedded in the programs. The declarativists do not believe that knowledge of a subject is intimately bound with the procedures for its use. They see intelligence as resting on two bases: a quite general set of procedures for manipulating facts of all sorts, and a set of specific facts describing particular knowledge domains. In thinking, the general procedures are applied to the domain-specific data to make deductions. Often this process has been based on the model of axiomatic mathematics. The facts are axioms and the thought process involves proof procedures for drawing conclusions from them.}
}

% https://link.springer.com/chapter/10.1007/3-540-07168-7_77
% We take the following statements to be the objectives of modular programming:
% 1. One must be able to convince himself of the correctness of a program module,
% independently of the context of its use in building larger units of software.
% 2. One must be able to conveniently put together program modules written under
% different authorities without knowledge of their inner workings.
% InBook
@Misc{Dennis1975,
  author="Dennis, Jack B.",
  editor="Bauer, F. L.
  and Dennis, J. B.
  and Waite, W. M.
  and Gotlieb, C. C.
  and Graham, R. M.
  and Griffiths, M.
  and Helms, H. J.
  and Morton, B.
  and Poole, P. C.
  and Tsichritzis, D.",
  title="Modularity",
  bookTitle="Software Engineering: An Advanced Course",
  year="1975",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="128--182",
  isbn="978-3-540-37502-9",
  doi="10.1007/3-540-07168-7_77",
  url="https://doi.org/10.1007/3-540-07168-7_77"
}


% AITR-346.ps
% Uses the word prototypes and objects in a suggestive but informal way.
% The knowledge representation is a decision tree in a 3kloc LISP program
% with over a thousand COND.
% There is some notion of hierarchy and overriding/extending descriptive features,
% but not obviously one of fixed-point or self-reference; at least not discussed.
@article{hollerbach1975hierarchical,
  title={Hierarchical shape description of objects by selection and modification of prototypes},
  author={Hollerbach, John M},
  year={1975},
  url={https://dspace.mit.edu/handle/1721.1/6897}
}

@InProceedings{DeRemerKron1975,
  author = {DeRemer, Frank and Kron, Hans},
  title = {Programming-in-the Large versus Programming-in-the-Small},
  year = {1975},
  isbn = {9781450373852},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/800027.808431},
  doi = {10.1145/800027.808431},
  abstract = {We distinguish the activity of writing large programs from that of writing small ones. By large programs we mean systems consisting of many small programs (modules), possibly written by different people.We need languages for programming-in-the-small, i.e. languages not unlike the common programming languages of today, for writing modules. We also need a “module interconnection language” for knitting those modules together into an integrated whole and for providing an overview that formally records the intent of the programmer(s) and that can be checked for consistency by a compiler.We explore the software reliability aspects of such an interconnection language. Emphasis is placed on facilities for information hiding and for defining layers of virtual machines.},
  booktitle = {Proceedings of the International Conference on Reliable Software},
  pages = {114–121},
  numpages = {8},
  keywords = {Module interconnection language, Accessibility, Visibility, Protection, Linking, Scope of definition, Virtual machine, Project management tool., Information hiding, External name, System hierarchy},
  location = {Los Angeles, California}
}

% Unnamed language inspired by Hewitt's actors (PLASMA) and Smalltalk-72.
% Prototype-based ("objects" reply to "messages", "prototype" not used),
% that have "parents" or "children" (single inheritance is described; "inheritance of properties" is used)
% There are "classes" that handle otherwise unhandled messages, but the relationship between
% classes and parents is not explained -- are they the same hierarchy? a separate one?
% Are the child/parent and class/instance relationships the same or different?
@InProceedings{Kahn1976,
  author = {Kahn, Kenneth Michael},
  title = {An Actor-Based Computer Animation Language},
  year = {1976},
  isbn = {9781450377898},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/1024273.1024278},
  abstract = {This paper describes a computer language based upon actor semantics designed especially for computer graphics and animation. The thesis that animation is best facilitated by considering each entity on the display screen as an independent process is discussed and demonstrated by examples. The system is built upon MacLisp and is compatible with Lisp-Logo. The language is designed to be used by both very sophisticated programmers and by school children.},
  booktitle = {Proceedings of the ACM/SIGGRAPH Workshop on User-Oriented Design of Interactive Graphics Systems},
  pages = {37–43},
  numpages = {7},
  location = {Pittsburgh, PA},
  series = {UODIGS '76},
  url = {https://dspace.mit.edu/handle/1721.1/41950}
}

% Also published in Cognitive Science, V. 1, No. 1, 1977.
% Has multiple inheritance (without using the word) as multiple "descriptors"
% each providing a "perspective" on a given "object" or "prototype",
% and "inheritance of properties".
% Meant as a declarative system of data on which operations are then performed,
% rather than as code as such (though coding is possible).
@Misc{Bobrow1976,
  author={Daniel G. Bobrow and Terry Winograd},
  title={An Overview of KRL, A Knowledge Representation Language},
  year={1976},
  note={Stanford Artificial Intelligence Laboratory Memo AIM-293}
}


% Uses the word "prototypes", and has no classes. And multiple inheritance.
@InProceedings{Borning1977,
  author = {Alan Hamilton Borning},
  title = {{ThingLab} --- an Object-Oriented System for Building Simulations using Constraints},
  booktitle={5th International Conference on Artificial Intelligence},
  pages={497--498},
  month = {August},
  year = {1977},
  url = {https://www.ijcai.org/Proceedings/77-1/Papers/085.pdf}
}

@PhDThesis{Borning1979,
  author = {Borning, Alan Hamilton},
  title = {{ThingLab} --- A Constraint-Oriented Simulation Laboratory},
  biburl = {https://www.bibsonomy.org/bibtex/263cae088243a5fd341d7d634d8176bb3/n770},
  publisher = {Palo Alto Research Center XEROX},
  url = {https://constraints.cs.washington.edu/ui/thinglab-tr.pdf},
  school = {Stanford University},
  year = 1979
}

% This paper is about the higher-level system Ani, that generates plans for Director.
% Director is the actor-based system with turtle graphics
% (see Director Guide, AIM-482b, 1978 revised 1979),
% while Ani is a constraint solver based on a knowledge representation of the film being directed:
% very crude 2d film with polygons as "performers" that move toward, away from,
% around or between each other, at various speeds appropriate for the action,
% as would humans on a stage.
@PhDThesis{Kahn1979,
  title = {Creation of computer animation from story descriptions},
  author = {Kahn, Kenneth Michael},
  school = {MIT},
  year = {1979},
  url = {https://dspace.mit.edu/handle/1721.1/16012}
}

% http://worrydream.com/refs/Borning%20-%20The%20Programming%20Language%20Aspects%20of%20ThingLab.pdf
% https://dl.acm.org/doi/abs/10.1145/357146.357147
@Article{Borning1981,
  author = {Borning, Alan Hamilton},
  title = {The Programming Language Aspects of ThingLab, a Constraint-Oriented Simulation Laboratory},
  year = {1981},
  issue_date = {Oct. 1981},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {3},
  number = {4},
  issn = {0164-0925},
  url = {https://doi.org/10.1145/357146.357147},
  doi = {10.1145/357146.357147},
  journal = {ACM Trans. Program. Lang. Syst.},
  month = oct,
  pages = {353--387},
  numpages = {35}
}

% Yale T Scheme. Introduces functional syntax for object method invocation.
% Norman I. Adams, IV -- but the IV doesn't get processed correctly
% Can't find it on http://mumble.net/~jar/tproject/
@InProceedings{Rees82t:a,
  author = {Jonathan A. Rees and Norman I. Adams},
  title = {T: a dialect of LISP or, Lambda: the ultimate software tool},
  booktitle = {Symposium on Lisp and Functional Programming, ACM},
  pages = {114--122},
  year = {1982},
  url = {https://www.researchgate.net/publication/221252249_T_a_dialect_of_Lisp_or_LAMBDA_The_ultimate_software_tool}
}

% Borning1982 cites a 1980 version of the Flavors report, from MIT. Originally from 1979.
% Also a 1982 version of LOOPS
@Misc{Cannon1979,
  title={Flavors: A non-hierarchical approach to object-oriented programming},
  author={Howard Cannon},
  publisher={Symbolics Inc.},
  year=1979,
  url={https://www.softwarepreservation.org/projects/LISP/MIT/nnnfla1-20040122.pdf}
}

% Has metaclasses, multiple inheritance.
% Still ugly syntax, with INTERLISP-style very short uppercase identifiers.
@book{bobrow1983loops,
  title={The LOOPS manual},
  author={Bobrow, Daniel Gureasko and Stefik, Mark},
  volume={10},
  year={1983},
  publisher={Xerox Corporation Palo Alto, CA}
}

% After discussing multiple inheritance informally, omits it completely from the formal treatment,
% but does introduce a framework for subtyping of a lambda-calculus with records and fixed-points.
@InProceedings{Cardelli1984ASO,
  title={A Semantics of Multiple Inheritance},
  author={Luca Cardelli},
  booktitle={Information and Computation},
  year={1984},
  url={https://api.semanticscholar.org/CorpusID:13032155}
}

% url={https://homepages.cwi.nl/~storm/teaching/reader/Lieberman86.pdf}
@InProceedings{Lieberman1986,
  title={Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems},
  author={Henry Lieberman},
  booktitle={OOPLSA},
  pages={214--223},
  year={1986},
  url={https://web.media.mit.edu/~lieber/Lieberary/OOP/Delegation/Delegation.html}
}

@InProceedings{Borning1986,
  title={Classes Versus Prototypes in Object-Oriented Languages},
  author={Alan Hamilton Borning},
  booktitle={1986 Fall Joint Computer Conference},
  pages={36--40},
  year={1986},
  doi={10.5555/324493.324538},
}

% Also a 1985 report.
% Has generic functions, method caching, multimethods,
% As in 1983, metaclasses-mediated definitions&slots, etc.
% Almost modern syntax, lower case long(ish) identifiers.
@InProceedings{bobrow86commonloops,
  title={CommonLoops: Merging Lisp and Object-Oriented Programming},
  author={Daniel G. Bobrow and Kenneth Kahn and Gregor Kiczales and Larry Masinter and Mark Stefyk and Frank Zdybel},
  booktitle={OOPSLA},
  year={1986},
  doi={10.1145/28697.28700}
}

% David Moon "Object-Oriented Programming with Flavors" 1986
% Gabriel2012 says it's the first academic publication on mixins after Cannon's MIT report on Flavors.
% It describes the New Flavors from Symbolics. GF syntax. Insists on modularity.
@article{Moon1986Flavors,
author = {Moon, David A.},
title = {Object-oriented programming with flavors},
year = {1986},
issue_date = {Nov. 1986},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {11},
issn = {0362-1340},
url = {https://doi.org/10.1145/960112.28698},
doi = {10.1145/960112.28698},
abstract = {This paper describes Symbolics' newly redesigned object-oriented programming system, Flavors. Flavors encourages program modularity, eases the development of large, complex programs, and provides high efficiency at run time. Flavors is integrated into Lisp and the Symbolics program development environment. This paper describes the philosophy and some of the major characteristics of Symbolics' Flavors and shows how the above goals are addressed. Full details of Flavors are left to the programmers' manual, Reference Guide to Symbolics Common Lisp. (5)},
journal = {SIGPLAN Not.},
month = jun,
pages = {1--8},
numpages = {8}
}

% Stein 1987 "Delegation is Inheritance", cited by cook1989inheritance


% https://beta.cs.au.dk/ ?
@article{kristensen1987beta,
  title={The BETA programming language},
  author={Kristensen, Bent Bruun and Madsen, Ole Lehrmann and Møller-Pedersen, Birger and Nygaard, Kristen},
  journal={DAIMI Report Series},
  number={229},
  year={1987},
  url={https://www.semanticscholar.org/paper/The-BETA-Programming-Language-Kristensen-Madsen/3971897f708518e13809d3c0772105bd86526e50}
}

@Article{bobrow88clos,
  title={Common Lisp Object Specification X3J13},
  author={D. G. Bobrow and L. D. DeMichiel and R. P. Gabriel and S. E. Kleene and G. Kiczales and D. A. Moon},
  journal={SIGPLAN Notices 23 (Special Issue)},
  year={1988},
  doi={10.1007/bf01806962},
  url={https://link.springer.com/content/pdf/10.1007/bf01806962.pdf}
}

@InProceedings{Kamin1988,
  title={Inheritance in Smalltalk-80: A Denotational Definition},
  author={Samuel N. Kamin},
  %booktitle={POPL '88},
  booktitle={POPL},
  year={1988},
  doi={10.1145/73560.73567},
  %url={https://dl.acm.org/doi/10.1145/73560.73567}
}

% https://core.ac.uk/download/pdf/42828491.pdf
@InProceedings{ObjectsAsClosures,
  author = {Reddy, Uday},
  title = {Objects as Closures - Abstract Semantics of Object Oriented Languages},
  %booktitle = {ACM Symposium on LISP and Functional Programming},
  booktitle = {LFP},
  %month = {02},
  pages = {289–-297},
  doi = {10.1145/62678.62721},
  year = {1988},
}

@InProceedings{adams88oopscheme,
  Author = {Norman Adams and Jonathan Rees},
  Title = {Object-Oriented Programming in Scheme},
  url = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.954",
  %booktitle = {ACM Conference on Lisp and Functional Programming},
  booktitle = {LFP},
  pages = {277--288},
  Year = {1988}
}

% Unless a base class is "virtual", multiple copies are inherited.
% Conflict resolution is manual; you can explicitly call a superclass method,
% but there is no linearization mechanism to avoid exponential calls
% to supermethods in case of "diamonds" (TODO: find paper about the diamond problem?)
@article{stroustrup1989multiple,
  title={Multiple inheritance for C++},
  author={Stroustrup, Bjarne},
  journal={Computing Systems},
  volume={2},
  number={4},
  pages={367--395},
  year={1989}
}

% Cook2012 cites his own thesis in arguing that Inheritance is neither necessary nor specific to OO.
@PhDThesis{Cook1989,
    author = {William R. Cook},
    title = {A Denotational Semantics of Inheritance},
    school = {Brown University},
    year = {1989},
    url = {https://www.cs.utexas.edu/~wcook/papers/thesis/cook89.pdf}
}

% POPL, short reprise of what's in his thesis
% Also single-inheritance, records only
@Article{cook1989denotational,
  title={A denotational semantics of inheritance and its correctness},
  author={Cook, William and Palsberg, Jens},
  journal={ACM Sigplan Notices},
  volume={24},
  number={10},
  pages={433--443},
  year={1989},
  publisher={ACM New York, NY, USA}
}

% The right fixe-point semantics, actually for prototypes as well as classes!
% 2.2 claims to avoid the "subsumption" rule for record subtyping in Cardelli (allows more rows)
% but in later sections seem to implicitly rely on it (or else on some dynamic or deferred typing?)
% 3 uses specs and targets without saying it
% 4.1 Has class as object constructor, reflexively accessible from object as "self class" method,
% and then uses double Y to resolve both class and self prototypes,
% instead of having an explicit Lieberman-like construction of class as prototype.
% 4.2 seems to implicitly have a type dependency (what are F and G ib (5)?)
% url={https://dl.acm.org/doi/abs/10.1145/96709.96721}
% Cites Mitch Wand 1987, 1989, 1989... gotta go deeper
@InProceedings{cook1989inheritance,
  title={Inheritance is not subtyping},
  author={Cook, William R and Hill, Walter and Canning, Peter S},
  %booktitle={Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  booktitle={POPL},
  pages={125--135},
  year={1989},
  doi={10.1145/96709.96721}
}


@InProceedings{chambers1989efficient,
  author = {Chambers, C. and Ungar, D. and Lee, E.},
  title = {An Efficient Implementation of SELF a Dynamically-Typed Object-Oriented Language Based on Prototypes},
  year = {1989},
  isbn = {0897913337},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/74877.74884},
  doi = {10.1145/74877.74884},
  abstract = {We have developed and implemented techniques that double the performance of dynamically-typed object-oriented languages. Our SELF implementation runs twice as fast as the fastest Smalltalk implementation, despite SELF's lack of classes and explicit variables.To compensate for the absence of classes, our system uses implementation-level maps to transparently group objects cloned from the same prototype, providing data type information and eliminating the apparent space overhead for prototype-based systems. To compensate for dynamic typing, user-defined control structures, and the lack of explicit variables, our system dynamically compiles multiple versions of a source method, each customized according to its receiver's map. Within each version the type of the receiver is fixed, and thus the compiler can statically bind and inline all messages sent to self. Message splitting and type prediction extract and preserve even more static type information, allowing the compiler to inline many other messages. Inlining dramatically improves performance and eliminates the need to hard-wire low-level methods such as +,==, and ifTrue:.Despite inlining and other optimizations, our system still supports interactive programming environments. The system traverses internal dependency lists to invalidate all compiled methods affected by a programming change. The debugger reconstructs inlined stack frames from compiler-generated debugging information, making inlining invisible to the SELF programmer.},
  booktitle = {OOPSLA},
  pages = {49–70},
  numpages = {22},
  location = {New Orleans, Louisiana, USA}
}

% Not obviously worth citing in this context?
% @TechReport ?
@Misc{Lawall89SelfInScheme,
  Author = {Julia L. Lawall and Daniel P. Friedman},
  Title = {Embedding the Self Language in Scheme},
  url = "https://legacy.cs.indiana.edu/ftp/techreports/TR276.pdf",
  Year = {1989}
}

% Introduction of Typeclasses
% https://www.research.ed.ac.uk/en/publications/how-to-make-ad-hoc-polymorphism-less-ad-hoc
@InProceedings{typeclasses,
  title = "How to make ad-hoc polymorphism less ad hoc",
  abstract = "This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication, and generalise the {"}eqtype variables{"} of Standard ML. Type classes extend the Hindley/Milner polymorphic type system, and provide a new approach to issues that arise in object-oriented programming, bounded type quantification, and abstract data types. This paper provides an informal introduction to type classes, and defines them formally by means of type inference rules. ",
  author = "P. Wadler and S. Blott",
  year = "1989",
  doi = "10.1145/75277.75283",
  language = "English",
  isbn = "0-89791-294-2",
  pages = "60--76",
  %booktitle = "POPL '89 Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages",
  booktitle = "POPL",
  publisher = "ACM"
}

@book{cltl2,
  author = {Steele, Guy},
  title = {Common Lisp: The Language, 2nd edition},
  year = {1990},
  isbn = {0131515071},
  publisher = {Digital Press},
  address = {USA},
  doi = {10.5555/1098646},
  url = {http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/cltl2.html}
}

% https://www.semanticscholar.org/paper/Mixin-based-inheritance-Bracha-Cook/cbc4f2d93bb62d1c287f4fe458de6ac416379282
% url = {https://doi.org/10.1145/97945.97982},
@InProceedings{bracha1990mixin,
  author = {Gilad Bracha and William Cook},
  title = {Mixin-Based Inheritance},
  year = {1990},
  issue_date = {Oct. 1990},
  isbn = {0897914112},
  volume = {25},
  number = {10},
  issn = {0362-1340},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://bracha.org/oopsla90.pdf},
  doi = {10.1145/97945.97982},
  abstract = {The diverse inheritance mechanisms provided by Smalltalk, Beta, and CLOS are interpreted as different uses of a single underlying construct. Smalltalk and Beta differ primarily in the direction of class hierarchy growth. These inheritance mechanisms are subsumed in a new inheritance model based on composition of mixins, or abstract subclasses. This form of inheritance can also encode a CLOS multiple-inheritance hierarchy, although changes to the encoded hierarchy that would violate encapsulation are difficult. Practical application of mixin-based inheritance is illustrated in a sketch of an extension to Modula-3.},
  booktitle = {OOPLSA/ECOOP},
  pages = {303–311},
  numpages = {9},
  location = {Ottawa, Canada},
  journal = {SIGPLAN Not.},
  month = sep,
}

% Original DEFSYSTEM is a 1990 paper, but hard to find independently from the others.
@TechReport{kantrowitz1991,
  author =       {Mark Kantrowitz},
  title =        {Portable Utilities for {C}ommon {L}isp},
  institution =  {School of Computer Science, Carnegie-Mellon University},
  number =       {CMU-CS-91-143},
  year =         1991,
  month =        May,
  url =          {https://cl-pdx.com/static/CMU-CS-91-143.pdf}
}

@Article{gabriel1991clos,
  title={CLOS: Integrating object-oriented and functional programming},
  author={Gabriel, Richard P and White, Jon L and Bobrow, Daniel G},
  journal={Communications of the ACM},
  volume={34},
  number={9},
  pages={29--38},
  year={1991},
  publisher={ACM New York, NY, USA}
}

@Book{amop,
  Title={The {A}rt of the {M}eta-{O}bject {P}rotocol},
  Author={Kiczales, Gregor and Des Rivières, Jim and Bobrow, Daniel Gureasko},
  Year={1991},
  Publisher={MIT press},
  url={https://direct.mit.edu/books/book/2607/The-Art-of-the-Metaobject-Protocol}
}

@InProceedings{Ungar91organizingprograms,
  Title = {Organizing Programs Without Classes},
  author = {David Ungar and Craig Chambers and Bay-Wei Chang and Urs Hölzle},
  journal = {Lisp and Symbolic Computation},
  year = {1991},
  pages = {223--242},
  publisher = {Kluwer Academic Publishers}
}

@TechReport{eppl91,
  Author={Matthias Felleisen},
  Title={On the Expressive Power of Programming Languages},
  Institution={Rice University},
  Year={1991},
  url={https://www.cs.rice.edu/CS/PLT/Publications/Scheme/}
}

@Book{AMOP,
  Title={The {A}rt of the {M}eta-{O}bject {P}rotocol},
  Author={Bobrow, Daniel and Kiczales, Gregor and des Rivières, Jim},
  Publisher={MIT Press},
  Year={1991}
}

% Like Traits 1982, errors out in case of conflicting methods along the hierarchy
@InProceedings{CecilMultimethods,
  author="Chambers, Craig",
  editor="Madsen, Ole Lehrmann",
  title="Object-oriented multi-methods in Cecil",
  booktitle="ECOOP",
  year="1992",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="33--56",
  abstract="Multiple dispatching provides increased expressive power over single dispatching by guiding method lookup using the values of all arguments instead of only the receiver. However, existing languages with multiple dispatching do not encourage the data-abstraction-oriented programming style that is encouraged by traditional single-dispatching languages; instead existing multiple-dispatching languages tend to foster a function-oriented programming style organized around generic functions. We propose an alternative view of multiple dispatching that is intended to promote a data-abstraction-oriented programming style. Instead of viewing a multi-method as ``outside'' of all objects, we view a multi-method as ``inside'' the objects for which the multi-method applies (on which it dispatches). Because objects are closely connected to the multi-methods implementing their operations, the internals of an object can be encapsulated by being accessible only to the closely-connected multi-methods. We are exploring this object-oriented view of multi-methods in the context of a new programming language named Cecil.",
  isbn="978-3-540-47268-1",
  url="http://www.laputan.org/pub/papers/cecil-ecoop-92.pdf"
}

@PhDThesis{bracha1992jigsaw,
  author = {Gilad Bracha},
  title = {The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance},
  school = {University of Utah},
  year = {1992},
  url = {http://www.bracha.org/jigsaw.pdf}
}

@Article{dickey1992scheming,
  title={Scheming with objects},
  author={Dickey, Ken},
  url={http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/scheme/oop/yasos/swob.txt},
  journal={AI Expert},
  volume={7},
  number={10},
  pages={24--33},
  year={1992}
}

@InProceedings{chambers92objectoriented,
  author = {Craig Chambers},
  title = {Object-oriented multi-methods in Cecil},
  booktitle = {ECOOP},
  volume = "615",
  publisher = "Springer-Verlag",
  address = "Berlin, Heidelberg, New York, Tokyo",
  editor = "Ole Lehrmann Madsen",
  isbn = "3-540-55668-0",
  pages = "33--56",
  year = "1992",
  url = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.121.134"
}

% Defines the constraints used by C3, but uses a global rather than local tie break rule,
% and goes on rather than errors out if rules are incompatible
@article{ducournau1992monotonic,
  title={Monotonic conflict resolution mechanisms for inheritance},
  author={Ducournau, Roland and Habib, Michel and Huchard, Marianne and Mugnier, Marie-Laure},
  journal={ACM SIGPLAN Notices},
  volume={27},
  number={10},
  pages={16--24},
  year={1992},
  publisher={ACM New York, NY, USA}
}

% http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3952
@InProceedings{ImplementingTypeClasses,
  title = "Implementing Type Classes",
  author = "John Peterson and Mark Jones",
  booktitle = "Proceedings of ACM SIGPLAN Symposium on Programming Language Design and Implementation",
  year = "1993",
  url = "http://web.cecs.pdx.edu/~mpj/pubs/pldi93.html",
  publisher = {Elsevier Science},
}

% Traces (A cut at the “make isn't generic” problem)
% Gregor Kiczales
% 1993
% https://link.springer.com/chapter/10.1007/3-540-57342-9_64
@InProceedings{10.1007/3-540-57342-9_64,
  author="Kiczales, Gregor",
  editor="Nishio, Shojiro
  and Yonezawa, Akinori",
  title="Traces (A cut at the ``make isn't generic'' problem)",
  booktitle="Object Technologies for Advanced Software",
  year="1993",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="27--42",
  abstract="Object-oriented techniques are a powerful tool for making a system end-programmer specializable. But, in cases where the system not only accepts objects as input, but also creates objects internally, specialization has been more difficult. This has been referred to as the ``make isn't generic problem.'' We present a new object-oriented language concept, called traces, that we have used successfully to support specialization in cases that were previously cumbersome.",
  isbn="978-3-540-48075-4"
}

@inproceedings{ProposalMonotonicMultipleInheritance1994,
author = {Ducournau, R. and Habib, M. and Huchard, M. and Mugnier, M. L.},
title = {Proposal for a monotonic multiple inheritance linearization},
year = {1994},
isbn = {0897916883},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/191080.191110},
doi = {10.1145/191080.191110},
abstract = {Previous studies concerning multiple inheritance convinced us that a better analysis of conflict resolution mechanisms was necessary. In [DHHM92], we stated properties that a sound mechanism has to respect. Among them, a monotonicity principle plays a critical role, ensuring that the inheritance mechanism behaves “naturally” relative to the incremental design of the inheritance hierarchy. We focus here on linearizations and present an intrinsically monotonic linearization, whereas currently used linearizations are not. This paper describes the algorithm in detail, explains the design choices, and compares it to other linearizations, with LOOPS and CLOS taken as references. In particular, this new linearization extends CLOS and LOOPS linearizations, producing the same  results when these linearizations are sound.},
booktitle = {Proceedings of the Ninth Annual Conference on Object-Oriented Programming Systems, Language, and Applications},
pages = {164–175},
numpages = {12},
location = {Portland, Oregon, USA},
series = {OOPSLA '94}
}

% https://api.semanticscholar.org/CorpusID:16832709
% University of Illinois at Urbana-Champaign
% October 4, 1993
@InProceedings{Kamin1994TwoSM,
  title={Two semantic models of object-oriented languages},
  author={Samuel N. Kamin and Uday S. Reddy},
  year={1994},
  url={https://www.cs.bham.ac.uk/~udr/papers/oosem.pdf}
}

@Article{Cook1994,
  title={A Denotational Semantics of Inheritance and Its Correctness},
  author={W. Cook and J. Palsberg},
  journal={Information and Computation},
  year={1994},
  volume={114},
  pages={329--350},
  url = {https://www.cs.utexas.edu/~wcook/papers/ic94/ic94.pdf}
}

@book{GoF1994,
  title={Design patterns: elements of reusable object-oriented software},
  author={Erich Gamma and Richard Helm and Ralph Johnson and John Vlissides},
  year={1994},
  publisher={Addison-Wesley}
}

% Extend a simply typed LC (terminating) with simple objects and a typesystem
% (can add or override messages; difference meaningful because of type system)
% Prove the typesystem sound.
@article{LambdaCalculusObjects1994,
  title={A Lambda-Calculus of Objects and Method Specialization},
  author={Kathleen Fisher and Furio Honsell and John C. Mitchell},
  year={1994},
  journal={Nordic Journal of Computing},
  volume={1},
  pages={3-37}
}

% W7
% and Sussman, Gerald Jay ???
@PhDThesis{rees1995,
  author = {Rees, Jonathan Allen},
  title = {A Security Kernel Based on the Lambda Calculus},
  year = {1995},
  publisher = {Massachusetts Institute of Technology},
  school = {Massachusetts Institute of Technology},
  address = {USA},
  url = {http://mumble.net/~jar/pubs/secureos/},
  abstract = {Cooperation between independent agents depends upon establishing a degree of security. Each of the cooperating agents needs assurance that the cooperation will not endanger resources of value to that agent. In a computer system, a computational mechanism can assure safe cooperation among the system's users by mediating resource access according to desired security policy. Such a mechanism, which is called a security kernel, lies at the heart of many operating systems and programming environments. The dissertation describes Scheme 48, a programming environment whose design is guided by established principles of operating system security. Scheme 48's security kernel is small, consisting of the call-by-value $lambda$-calculus with a few simple extensions to support abstract data types, object mutation, and access to hardware resources. Each agent (user or subsystem) has a separate evaluation environment that holds objects representing privileges granted to that agent. Because environments ultimately determine availability of object references, protection and sharing can be controlled largely by the way in which environments are constructed.I will describe experience with Scheme 48 that shows how it serves as a robust and flexible experimental platform. Two successful applications of Scheme 48 are the programming environment for the Cornell mobile robots, where Scheme 48 runs with no (other) operating system support; and a secure multi-user environment that runs on workstations. (Copies available exclusively from MIT Libraries, Rm. 14-0551, Cambridge, MA 02139-4307. Ph. 617-253-5668; Fax 617-253-1690.)},
  note = {AAI0576129}
}

@Misc{eich1995javascript,
  title={JavaScript},
  author={Brendan Eich},
  journal={Mozilla Foundation},
  year={1995}
}

% The C3 superclass linearization algorithm
@InProceedings{Barrett96amonotonic,
  author = {Kim Barrett and Bob Cassels and Paul Haahr and David A. Moon and Keith Playford and P. Tucker Withington},
  title = {A Monotonic Superclass Linearization for Dylan},
  journal={OOPSLA},
  month = {oct},
  pages = {69–82},
  numpages = {14},
  year = {1996},
  booktitle = {OOPSLA},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/236337.236343},
  %url = {https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.3910},
}

@article{inheritance1996,
  author = {Taivalsaari, Antero},
  title = {On the Notion of Inheritance},
  year = {1996},
  issue_date = {Sept. 1996},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {28},
  number = {3},
  issn = {0360-0300},
  url = {https://doi.org/10.1145/243439.243441},
  doi = {10.1145/243439.243441},
  abstract = {One of the most intriguing—and at the same time most problematic—notions in object-oriented programing is inheritance. Inheritance is commonly regarded as the feature that distinguishes object-oriented programming from other modern programming paradigms, but researchers rarely agree on its meaning and usage. Yet inheritance of often hailed as a solution to many problems hampering software development, and many of the alleged benefits of object-oriented programming, such as improved conceptual modeling and reusability, are largely credited to it. This article aims at a comprehensive understanding of inheritance, examining its usage, surveying its varieties, and presenting a simple taxonomy of mechanisms that can be seen as underlying different inheritance models.},
  journal = {ACM Comput. Surv.},
  month = {sep},
  pages = {438--479},
  numpages = {42},
  keywords = {object-oriented programming, language constructs, delegation, inheritance, incremental modification, programming languages}
}

% Inheritance is discussed in section 11.5.1.
% SIMULA-style inheritance was deliberately left out of his work on FLEX and early Smalltalk.
% Kay credits Larry Tesler (slot inheritance), Henry Lieberman (delegation),
% and Bobrow and Winograd's KRL (Frames).
% InCollection ?
@Misc{kay1996early,
  title={The Early History of Smalltalk},
  author={Alan C. Kay},
  booktitle={History of programming languages---II},
  pages={511--598},
  year={1996},
  doi={10.1145/234286.1057828}
}

@Book{AbadiCardelli1997ToO,
  author = {Martín Abadi and Luca Cardelli},
  title = {A theory of objects},
  year = {1997},
  doi = {10.1007/978-1-4419-8598-9}
}

@InProceedings{aop97,
  author = {Kiczales, G. and Lamping, J. and Mendhekar, A. and Maeda, C. and Lopes, C. and Loingtier, J. M. and Irwin, J.},
  title = {Aspect-oriented programming},
  booktitle = {ECOOP},
  pages = {220--242},
  year = {1997}
}

% CBPV
@InProceedings{conf/tlca/Levy99,
  title = {Call-by-Push-Value: A Subsuming Paradigm},
  year = {1999},
  author = {Blain Levy, Paul},
  publisher = {Springer},
  booktitle = {Typed Lambda Calculi and Applications, 4th International Conference, TLCA'99, L'Aquila, Italy, April 7-9, 1999, Proceedings},
  doi = {10.5555/645894.671755},
}

% Defines a dialect of Java with mixins, MixedJava, to illustrate the approach taken in MzScheme
% and better described in their 2006 paper.
% https://www.semanticscholar.org/paper/Classes-and-mixins-Flatt-Krishnamurthi/c20e5f2a424b96209e6b400b23d319558932afa3
@Misc{Mixins1998,
  author = {Flatt, Matthew and Krishnamurthi, Shriram and Felleisen, Matthias},
  title = {Classes and mixins},
  year = {1998},
  isbn = {0897919793},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/268946.268961},
  doi = {10.1145/268946.268961},
  abstract = {While class-based object-oriented programming languages provide a flexible mechanism for re-using and managing related pieces of code, they typically lack linguistic facilities for specifying a uniform extension of many classes with one set of fields and methods. As a result, programmers are unable to express certain abstractions over classes.In this paper we develop a model of class-to-class functions that we refer to as mixins. A mixin function maps a class to an extended class by adding or overriding fields and methods. Programming with mixins is similar to programming with single inheritance classes, but mixins more directly encourage programming to interfaces.The paper develops these ideas within the context of Java. The results are 1. an intuitive model of an essential Java subset; 2. an extension that explains and models mixins; and 3. type soundness theorems for these languages.},
  booktitle = {Proceedings of the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages = {171–183},
  numpages = {13},
  location = {San Diego, California, USA},
  series = {POPL '98}
}

@Misc{ecmascript,
  title={ECMAScript Language Specification},
  author={ECMA, Final Draft},
  year={1999}
}

% Implements proper multiple inheritance on top of C++, but
% you have to manually linearize and pass the Super in a template.
% InProceedings
@Misc{smaragdakis2000mixin,
  title={Mixin-based programming in C++},
  author={Yannis Smaragdakis and Don Batory},
  booktitle={International Symposium on Generative and Component-Based Software Engineering},
  pages={164--178},
  year={2000},
  organization={Springer}
}

@InProceedings{SullivanGriswoldCaiHallen2001,
  author = {Sullivan, Kevin J. and Griswold, William G. and Cai, Yuanfang and Hallen, Ben},
  title = {The Structure and Value of Modularity in Software Design},
  year = {2001},
  isbn = {1581133901},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/503209.503224},
  doi = {10.1145/503209.503224},
  abstract = {The concept of information hiding modularity is a cornerstone of modern software design thought, but its formulation remains casual and its emphasis on changeability is imperfectly related to the goal of creating added value in a given context. We need better explanatory and prescriptive models of the nature and value of information hiding. We evaluate the potential of a new theory---developed to account for the influence of modularity on the evolution of the computer industry---to inform software design. The theory uses design structure matrices to model designs and real options techniques to value them. To test the potential utility of the theory for software we apply it to Parnas's KWIC designs. We contribute an extension to design structure matrices, and we show that the options results are consistent with Parnas's conclusions. Our results suggest that such a theory does have potential to help inform software design.},
  booktitle = {Proceedings of the 8th European Software Engineering Conference Held Jointly with 9th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  pages = {99–108},
  numpages = {10},
  keywords = {real options, design structure matrix, modularity, software},
  location = {Vienna, Austria},
  series = {ESEC/FSE-9}
}

% See notably chapter 32.
% downloaded from https://www.cs.sjtu.edu.cn/~kzhu/cs383/Pierce_Types_Programming_Languages.pdf
% This post claims that TAPL introduces the term "Open Recursion" https://journal.stuffwithstuff.com/2013/08/26/what-is-open-recursion/
@Book{Pierce2002TAPL,
  Author = {Pierce, Benjamin C.},
  Title = {Types and Programming Languages},
  Year = {2002},
  ISBN = {0262162091},
  Publisher = {MIT Press},
  Edition = {1st},
  url = {https://www.cis.upenn.edu/~bcpierce/tapl/}
}


@Misc{Kay2003,
  Author={Alan Kay},
  Title={Clarification of "object-oriented" (email)},
  URL={https://www.purl.org/stefan_ram/pub/doc_kay_oop_en},
  Year={2007},
  Month={07},
  Day={23}
}

% https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=693f61d2515ac9b032801dd7a603c34f1b725071
% Wrongly claims that multidispatch forgoes modular typechecking
% Has no definition of modularity, except maybe for typechecking
@phdthesis{millstein2003reconciling,
  title={Reconciling software extensibility with modular program reasoning},
  author={Millstein, Todd David},
  year={2003},
  school={University of Washington},
  doi={10.5555/997550},
  url={https://web.cs.ucla.edu/~todd/research/dissertation.pdf}
}

@InProceedings{Salzman05prototypeswith,
  author = {Lee Salzman and Jonathan Aldrich},
  title = {Prototypes with multiple dispatch: An expressive and dynamic object model},
  booktitle = {ECOOP},
  year = {2005}
}

@article{scalableComponentAbstractions2005,
  author = {Odersky, Martin and Zenger, Matthias},
  title = {Scalable component abstractions},
  year = {2005},
  issue_date = {October 2005},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {40},
  number = {10},
  issn = {0362-1340},
  %url = {https://doi.org/10.1145/1103845.1094815},
  url = {http://lampwww.epfl.ch/~odersky/papers/ScalableComponent.pdf},
  doi = {10.1145/1103845.1094815},
  abstract = {We identify three programming language abstractions for the construction of reusable components: abstract type members, explicit selftypes, and modular mixin composition. Together, these abstractions enable us to transform an arbitrary assembly of static program parts with hard references between them into a system of reusable components. The transformation maintains the structure of the original system. We demonstrate this approach in two case studies, a subject/observer framework and a compiler front-end.},
  journal = {SIGPLAN Not.},
  month = {oct},
  pages = {41--57},
  numpages = {17},
  keywords = {Scala, abstract types, classes, components, mixins},
  isbn = {1595930310},
  %booktitle = {Proceedings of the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
  %%booktitle = {OOPSLA '05},
  booktitle = {OOPSLA},
  location = {San Diego, CA, USA},
  series = {OOPSLA '05}
}

@InProceedings{Flatt2006Mixins,
  author = {Matthew Flatt and Robert Bruce Findler and Matthias Felleisen},
  title = {Scheme with classes, mixins, and traits},
  booktitle = {In Asian Symposium on Programming Languages and Systems (APLAS) 2006},
  year = {2006},
  pages = {270--289},
  url = {https://www2.ccs.neu.edu/racket/pubs/asplas06-fff.pdf}
}

@InProceedings{BruceCardelliPierce2006,
    author = {Kim B. Bruce and Luca Cardelli and Benjamin C. Pierce},
    title = {Comparing Object Encodings},
    booktitle = {Journal of Functional Programming},
    volume = {16},
    pages = {375-–414},
    year = {2006},
}
% http://citeseerx.ist.psu.edu/viewdoc/similar?doi=10.1.1.211.6777&type=cc

% NB: Extended version of the seminal 2005 TOPLAS paper.
% For a history of lenses, see Jules Hedges' https://julesh.com/2018/08/16/lenses-for-philosophers/
@Article{Foster2007CombinatorsFB,
  title={Combinators for bidirectional tree transformations: A linguistic approach to the view-update problem},
  author={Nate Foster and M. Greenwald and J. T. Moore and B. Pierce and A. Schmitt},
  journal={ACM Trans. Program. Lang. Syst.},
  year={2007},
  volume={29},
  url={https://www.cis.upenn.edu/~bcpierce/papers/lenses-full.pdf}
}

@article{bracha2008newspeak,
  title={The Newspeak Programming Platform},
  author={Bracha, Gilad and Ahe, Peter and Bykov, Vassili and Kashai, Yaron and Miranda, Eliot},
  journal={Cadence Design Systems},
  year={2008}
}

% Master Thesis. BCL
@TechReport{gclviewer2008,
  Author = "Ibrahim Bokharouss",
  Title = "GCL Viewer: a study in improving the understanding of GCL programs",
  Institution = {Eindhoven University of Technology},
  year = 2008,
  url = {https://research.tue.nl/en/studentTheses/gcl-viewer}
  }
% https://pure.tue.nl/ws/portalfiles/portal/46927079/638953-1.pdf

@InProceedings{dolstra2008nixos,
  title={NixOS: A purely functional Linux distribution},
  author={Dolstra, Eelco and L{\"o}h, Andres},
  booktitle={Proceedings of the 13th ACM SIGPLAN international conference on Functional programming},
  pages={367--378},
  year={2008},
  url={https://edolstra.github.io/pubs/nixos-jfp-final.pdf}
}

% April 2
@Misc{minsky08,
  author = {Yaron Minsky},
  title = {The {ML} sweet spot},
  year = 2008,
  url = {https://blog.janestreet.com/the-ml-sweet-spot/},
  urldate = {2021-03-14}
}

% From the Fortress team
@InProceedings{allen2011type,
  title={Type checking modular multiple dispatch with parametric polymorphism and multiple inheritance},
  author={Allen, Eric and Hilburn, Justin and Kilpatrick, Scott and Luchangco, Victor and Ryu, Sukyoung and Chase, David and Steele, Guy},
  booktitle={OOPSLA},
  pages={973--992},
  year={2011},
  url={https://people.mpi-sws.org/~skilpat/papers/multipoly.pdf}
}

% EOPL only has classes with single inheritance.
% barely touches multiple inheritance, "powerful, but … problematic", in exercise 9.26,
% and prototypes in exercise 9.27-9.29
@book{eopl3,
  author = {Friedman, Daniel P. and Haynes, Christopher T. and Wand, Mitchell},
  title = {Essentials of Programming Languages (3rd Ed.)},
  year = {2008},
  publisher = {Massachusetts Institute of Technology},
  address = {USA},
  url = {https://www.eopl3.com/}
}

% PLAI 1st ed has objects as closures and even prototypes in ch 10.
% 10.3.3 shits on multiple inheritance.
% 10.3.5 introduces mixins as a mechanism on top of first-class single-inheritance classes.
@book{plai,
  author = {Shriram Khrisnamurthi},
  title = {Programming Languages: Application and Interpretation (1st Ed.)},
  year = {2008},
  publisher = {Massachusetts Institute of Technology},
  address = {USA},
  url = {https://plai.org/},
}

@InProceedings{Brown_functioninheritance:,
  author = {Daniel Brown and William R. Cook},
  title = {Function Inheritance: Monadic Memoization Mixins},
  booktitle = {Brazilian Symposium on Programming Languages},
  year = {2009},
}

% TODO
% Claims that objects are about modularity of "classes" used only through "interfaces", not inheritance
@Misc{Cook2009,
  author = {William Cook},
  title = {On Understanding Data Abstraction, Revisited},
  year = 2009
}


% Unpublished
@Misc{MonadsMixins,
  title = "The Different Aspects of Monads and Mixins",
  author = "Oliveira, Bruno C. d. S.",
  year = {2009},
  url = {http://ropas.snu.ac.kr/%7Ebruno/papers/MixinAspects.pdf},
}

@InProceedings{Oliveira10effectiveadvice,
  author = {Oliveira, Bruno C. d. S. and Schrijvers, Tom and Cook, William R.},
  title = {EffectiveAdvice: disciplined advice with explicit effects},
  booktitle = {AOSD’10: 9th International Conference on Aspect-Oriented Software Development},
  pages = {109--120},
  year = {2010}
}

% Why won't InProceedings work in eoo* ?
@InProceedings{ASDF2,
  author = {François-René Rideau and Robert Goldman},
  title = {Evolving ASDF: More Cooperation, Less Coordination},
  year = {2010},
  booktitle = {International Lisp Conference},
  url = {http://common-lisp.net/project/asdf/doc/ilc2010draft.pdf}
}

@Misc{OOP2010,
  title={Ralph Johnson, Joe Armstrong on the State of OOP (Interview at QCon)},
  author={Ralph Johnson and Joe Armstrong},
  year={2010},
  url={https://www.infoq.com/interviews/johnson-armstrong-oop/}
}

% Incommensurability -- uses bracha1990mixin as its pivot!
@inproceedings{gabriel2012,
  title={The Structure of a Programming Language Revolution},
  author={Richard P. Gabriel},
  booktitle={Proceedings of the ACM international symposium on New ideas, new paradigms, and reflections on programming and software},
  pages={195--214},
  year={2012},
  url={https://www.dreamsongs.com/Files/Incommensurability.pdf}
}

@InProceedings{LIL2012,
  author = {François-René Rideau},
  title = {{LIL}: {CLOS} ~ Reaches Higher-Order, Sheds Identity and has a Transformative Experience},
  url = "http://github.com/fare/lil-ilc2012/",
  booktitle = {International Lisp Conference},
  year = 2012
}

% My replies: https://twitter.com/Ngnghm/status/1791988260266234028
% XXXX UPDATE ENTRY
@Misc{Cook2012,
  author = {William Cook},
  title = {A Proposal for Simplified, Modern Definitions of "Object" and "Object Oriented"},
  url = {https://wcook.blogspot.com/2012/07/proposal-for-simplified-modern.html},
  year = 2012
}

@Misc{jsonnet,
  author = {Dave Cunningham},
  title = {Jsonnet},
  year = 2014,
  url = {https://jsonnet.org},
  urldate = {2021-03-11}
}

@Book{EcmaScript:15,
  added-at = {2015-08-28T15:36:26.000+0200},
  address = {Geneva},
  author = {{Ecma International}},
  biburl = {https://www.bibsonomy.org/bibtex/28d67e2ebf933f3b6f684fcfb1f53b020/gron},
  edition = {6th},
  interhash = {8212a5bb4b7ac3137534f10d599cb526},
  intrahash = {8d67e2ebf933f3b6f684fcfb1f53b020},
  keywords = {JavaScript spec specification},
  month = {June},
  timestamp = {2015-08-28T15:37:30.000+0200},
  title = {{ECMAScript 2015 Language Specification}},
  url = {http://www.ecma-international.org/ecma-262/6.0/ECMA-262.pdf},
  year = 2015
}

@Misc{nix2015,
  title={Nixpkgs fixed-points library},
  author={Peter Simons},
  url={https://github.com/NixOS/nixpkgs/blob/master/lib/fixed-points.nix},
  year={2015},
  urldate={2023-11-29}
}

% This article is great in desugaring the prototype sublanguage of JS,
% but doesn't cover classes.
@Article{DBLP:journals/corr/GuhaSK15,
  author    = {Arjun Guha and
               Claudiu Saftoiu and
               Shriram Krishnamurthi},
  title     = {The Essence of JavaScript},
  journal   = {CoRR},
  volume    = {abs/1510.00925},
  year      = {2015},
  url       = {http://arxiv.org/abs/1510.00925},
  archivePrefix = {arXiv},
  eprint    = {1510.00925},
  timestamp = {Mon, 13 Aug 2018 16:46:22 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/GuhaSK15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@Misc{grigore2016javagenericsturingcomplete,
      title={Java Generics are Turing Complete}, 
      author={Radu Grigore},
      year={2016},
      eprint={1605.05274},
      archivePrefix={arXiv},
      primaryClass={cs.PL},
      url={https://arxiv.org/abs/1605.05274}, 
}

@Misc{ngnghm9,
  author = {François-René Rideau},
  title = {Build Systems and Modularity},
  year = 2016,
  url = {https://ngnghm.github.io/blog/2016/04/26/chapter-9-build-systems-and-modularity/},
  urldate = {2023-11-29}
}

@Article{Pickering_2017,
  title={Profunctor Optics: Modular Data Accessors},
  volume={1},
  ISSN={2473-7321},
  url={http://dx.doi.org/10.22152/programming-journal.org/2017/1/7},
  DOI={10.22152/programming-journal.org/2017/1/7},
  number={2},
  journal={The Art, Science, and Engineering of Programming},
  publisher={Aspect-Oriented Software Association (AOSA)},
  author={Pickering, Matthew and Gibbons, Jeremy and Wu, Nicolas},
  year={2017},
  month={Apr}
}

% Withhold citation until after deanomization
@Misc{GerbilPOOwithheld,
  author = {Author withheld},
  title = {Title withheld},
  url = {https://github.com/repository/withheld},
  year = 2020
}

@Misc{GerbilPOO,
  author = {François-René Rideau},
  title = {Gerbil-POO},
  year = 2020,
  url = {https://github.com/fare/gerbil-poo},
  urldate = {2021-04-06}
}

@Misc{Kay2020,
  title={What thought process would lead one to invent Object-Oriented Programming?},
  author={Alan Kay},
  year={2020},
  url={https://www.quora.com/What-thought-process-would-lead-one-to-invent-object-oriented-programming/answer/Alan-Kay-11}
}

% Maybe cite the last episode of this story instead, that explains the concept?
% https://en.wikipedia.org/wiki/Earthshock
% On citing TV series:
% https://www.easybib.com/guides/citation-guides/how-do-i-cite-a/how-to-cite-movie-tv-netflix/
@Misc{DrWhoFPIT,
  author = {Unknown},
  title = {Fixed Point in Time},
  year = 2021,
  url = {https://tardis.fandom.com/wiki/Fixed_point_in_time},
  urldate = {2021-03-14}
}

@Misc{WikiC3,
  title = "C3 linearization",
  author = "Wikipedia",
  year = 2021,
  url = {https://en.wikipedia.org/wiki/C3_linearization},
}

@Misc{WikiProto,
  title = "Prototype-based programming",
  author = "Wikipedia",
  year = 2025,
  url = {https://en.wikipedia.org/wiki/Prototype-based_programming},
}

@InProceedings{poof2021,
  title = {Prototypes: Object-Orientation, Functionally},
  author = {François-René Rideau and Alex Knauth and Nada Amin},
  year = {2021},
  booktitle = {Scheme and Functional Programming Workshop},
  url = {https://github.com/metareflection/poof},
}

@Misc{POP2021,
  author =       {François-René Rideau},
  title =        {Pure Object Prototypes},
  url =          {https://github.com/divnix/POP},
  year =         {2021}
}

@Misc{TopPL2022,
  author =       {GitHub},
  title =        {The top programming languages},
  url =          {https://octoverse.github.com/2022/top-programming-languages},
  year =         2022,
  note =         "[accessed 2024-01-04]"
}

%%% TODO: Add the following...

% Conway's Law
% Conway, Melvin (1968). "How do committees invent" (PDF). Datamation: 28–31.

% 1979 https://constraints.cs.washington.edu/ui/thinglab-tr.pdf

% Wegner Zdonik "Inheritance as an incremental modification mechanism or what Like is or isn't like" 1988

% [2] Object-Oriented Programming Versus Abstract Data Types In Proceedings of the REX School/Workshop on Foundations of Object-Oriented Languages, Springer-Verlag, pp. 151-178 (1990).
% http://www.cs.utexas.edu/~wcook/papers/OOPvsADT/CookOOPvsADT90.pdf
% PDA (Procedural Data Abstraction) organized around constructors (for classes, etc.) vs
% ADT (Abstract Data Types) organized around observations (pattern-matching for data types).
% Cook is baffled by CLOS and its multimethods wrt his PDA (like Smalltalk) vs ADT (like CLU)

% William R. Cook: On Understanding Data Abstraction, Revisited
% [1] On understanding data abstraction, revisited. Onward! Essay in Proceedings of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications (OOPSLA). pp. 557-572 (2009).
% https://cs.utexas.edu/~wcook/Drafts/2009/essay.pdf
% Good presentation of ADTs
% 3.1 notes the "OO" (re)presentation eschews the existential type, hiding it under HOF i/f,
% but that's false in general---the existential type is there for compatibility between values you can build and modify.
% 3.2 claims with ref to his thesis that inheritance is orthogonal to OO (!)
% misses that what makes method invocation "dynamic binding" isn't the HOF records,
% but the open recursion on self and the sharing of methods between multiple selves
% thanks to inheritance.
% Also identifies classes as their constructor...
% 3.3 "Autognosis" is the criterion what Bracha calls "Pure OO", i.e. all accesses through interface
% Wholly skips CLOS, unlike his 1990 paper.
% Wholly skips Prototypes.
% In the end, does not bring much lights to the topic, beyond the obvious.


% Bracha and Lindstrom 1992 Modularity meets inheritance

% 2000 Oleg Kiselyov USENET post on okmij.org on the possibility of a pure variant of YASOS ?


% Featherweight Jigsaw - Replacing inheritance by composition in Java-like languages
% https://dl.acm.org/doi/10.1016/j.ic.2012.02.004

% C++ template lambda calculus https://gist.github.com/glaebhoerl/8970f682958826ed36f9

% Kathleen Fisher’s thesis

% TODO: trace prototypes back to earlier Actor systems???
%
% Hewitt, Carl, Viewing Control Structures as Patterns of Passing Messages, MIT AI Lab Memo 410, Dec 1976.

% Adding POP to Nixpkgs:
% https://github.com/NixOS/rfcs/pull/91/
% https://github.com/NixOS/nixpkgs/pull/116275
% https://github.com/divnix/POP

% Gilad Bracha's Newspeak? It's class-based only, though.

% C2 wiki?
% https://wiki.c2.com/?PrototypeBasedProgramming
% https://wiki.c2.com/?ClassesPrototypesComparison
% https://wiki.c2.com/?PrototypeBasedLanguage
% "Popular" Prototype language: NewtonScript, LambdaMOO, Io, REBOL, Lua...

% ThingLab https://github.com/cdglabs/thinglab

% https://okmij.org/ftp/Computation/typeclass.html#Kaes

% Kaes ESOP 1988
% Stefan Kaes: Parametric overloading in polymorphic programming languages
%Proc. ESOP 1988, Springer's LNCS 300, pp. 131-144
% <http://link.springer.com/chapter/10.1007%2F3-540-19027-9_9>

% Stefan Kaes: Parametrischer Polymorphismus, Ueberladungen und Konversionen
% Dissertation: TU Darmstadt, Fachbereich Informatik, 2005
% <http://tuprints.ulb.tu-darmstadt.de/epda/000544/>

% A History of Haskell: being lazy with class
% Simon Peyton Jones
% The Third ACM SIGPLAN History of Programming Languages Conference (HOPL-III) | June 2007
% https://www.microsoft.com/en-us/research/publication/a-history-of-haskell-being-lazy-with-class/

% Haskell's overlooked object system
% Oleg Kiselyov, Ralf Laemmel
% https://arxiv.org/abs/cs/0509027
% 2005

% http://okmij.org/ftp/Computation/Subtyping/

% Barak Pearlmutter & Kevin Lang's Oaklisp https://github.com/barak/oaklisp

% Look at papers that cite Bracha 1990 on Semantic Scholar, including:
% https://www.semanticscholar.org/paper/Function-Inheritance-%3A-Monadic-Memoization-Mixins-Brown-Cook/d2bf5dc5c6c6bff91d10a0e2dceaaa13c2064765
% https://www.semanticscholar.org/paper/Object-Inheritance-Without-Classes-Jones-Homer/3dbc00e08dd1fa7c29faae9b2da544fb7e8d5579

% Modularity: ch4 and ch9 of taoup, e.g. http://www.catb.org/~esr/writings/taoup/html/ch04s02.html#orthogonality
% Semantics and Types for Objects with First-Class Member Names
% Joe Gibbs Politz, Arjun Guha, Shriram Krishnamurthi
% Foundations of Object-Oriented Languages, 2012
% https://cs.brown.edu/~sk/Publications/Papers/Published/pgk-sem-type-fc-member-name/

% Erik Ernst's work on gBeta:
% https://www.researchgate.net/publication/2806012_gbeta_-_a_Language_with_Virtual_Attributes_Block_Structure_and_Propagating_Dynamic_Inheritance

% Design Rules: The Power of Modularity,  by Baldwin & Clark

% Dart Book, by Gilad Bracha, Section 2.15 on mixins + examples all around, 5.9 on modularity

% StrongTalk.org still runs on Windows 10.

% CUE rejects inheritance, instead has value/pattern unification along a lattice: https://cuelang.org/docs/concepts/logic/

% https://www.piumarta.com/software/id-objmodel/objmodel2.pdf
% OOPSLA07

% Classes vs. Prototypes - Some Philosophical and Historical Observations
% Antero Taivalsaari • Journal of Object-Oriented Programming • Published 1996
% https://citeseerx.ist.psu.edu/doc_view/pid/30fcb7807ce73f16222761b97e36154f12349efb
% Indeed very philosophical with not enough computer science

% Jonathan Aldritch "The Power of Interoperability: Why Objects are Inevitable" Onward! 1993

% Zhang, Sun, Oliveira "Compositional Programming" TOPLAS 2021

% CECIL also had prototype inheritance / classless objects
% A cursory look at the manual does not mention mutable parents, however

@InProceedings{10.1145/28697.28702,
  author = {Snyder, Alan},
  title = {Encapsulation and inheritance in object-oriented programming languages},
  year = {1986},
  isbn = {0897912047},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/28697.28702},
  doi = {10.1145/28697.28702},
  abstract = {Object-oriented programming is a practical and useful programming methodology that encourages modular design and software reuse. Most object-oriented programming languages support data abstraction by preventing an object from being manipulated except via its defined external operations. In most languages, however, the introduction of inheritance severely compromises the benefits of this encapsulation. Furthermore, the use of inheritance itself is globally visible in most languages, so that changes to the inheritance hierarchy cannot be made safely. This paper examines the relationship between inheritance and encapsulation and develops requirements for full support of encapsulation with inheritance.},
  booktitle = {Conference Proceedings on Object-Oriented Programming Systems, Languages and Applications},
  pages = {38–45},
  numpages = {8},
  location = {Portland, Oregon, USA},
  series = {OOPSLA '86}
}

@article{10.1145/960112.28702,
  author = {Snyder, Alan},
  title = {Encapsulation and inheritance in object-oriented programming languages},
  year = {1986},
  issue_date = {Nov. 1986},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {21},
  number = {11},
  issn = {0362-1340},
  url = {https://doi.org/10.1145/960112.28702},
  doi = {10.1145/960112.28702},
  abstract = {Object-oriented programming is a practical and useful programming methodology that encourages modular design and software reuse. Most object-oriented programming languages support data abstraction by preventing an object from being manipulated except via its defined external operations. In most languages, however, the introduction of inheritance severely compromises the benefits of this encapsulation. Furthermore, the use of inheritance itself is globally visible in most languages, so that changes to the inheritance hierarchy cannot be made safely. This paper examines the relationship between inheritance and encapsulation and develops requirements for full support of encapsulation with inheritance.},
  journal = {SIGPLAN Not.},
  month = {jun},
  pages = {38–45},
  numpages = {8}
}

% ThingLab 1981 has multiple inheritance (already in 1977),
% and so have PIE (Goldstein&Bobrow 1980), Flavors 1980, LOOPS 1982.
% Traits from Mesa since 1979 [Curry 1982]
% Conflict resolution is by erroring if inheriting more than one method without an explicit override
@inproceedings{borning1982multiple,
  title={Multiple inheritance in Smalltalk-80},
  author={Borning, Alan H and Ingalls, Daniel HH},
  booktitle={Proceedings at the National Conference on AI},
  volume={82},
  pages={234--237},
  year={1982},
  url={http://www.laputan.org/pub/papers/MI-Borning-Ingalls.PDF}
}

% Introduces "traits", for multiple inheritance in the Mesa programming language
% used to implement WS, the workstation software of the Xerox Star 8010,
% since late 1979 (Mesa started early 1978 with Single-Inheritance).
% p.6 conflict resolution is manual.
@article{Traits,
  author = {Curry, Gael and Baer, Larry and Lipkie, Daniel and Lee, Bruce},
  title = {Traits: An approach to multiple-inheritance subclassing},
  year = {1982},
  issue_date = {June 21-23, 1982},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {3},
  number = {1–2},
  issn = {0737-819X},
  url = {https://doi.org/10.1145/966873.806468},
  doi = {10.1145/966873.806468},
  abstract = {This paper describes a new technique for organizing software which has been used successfully by the Xerox Star 8010 workstation. The workstation (WS) software is written in an “object-oriented” style: it can be viewed as a system of inter-communicating objects of different object types. Most of the WS software considers object types to be constructed by assembling more primitive abstractions called traits. A trait is a characteristic of an object, and is expressed as a set of operations which may be applied to objects carrying that trait. The traits model of subclassing generalizes the SIMULA-67 model by permitting multiple inheritance paths. This paper describes the relationship of WS software to the traits model and then describes the model itself.},
  journal = {ACM SIGOA Newsletter},
  month = {jun},
  pages = {1--9},
  numpages = {9}
}

% https://github.com/namin/dot
@InProceedings{Amin2016DependentOT,
  title={Dependent Object Types},
  author={Nada Amin},
  year={2016},
  url={https://api.semanticscholar.org/CorpusID:265751928}
}

@misc{kiselyov2005haskells,
      title={Haskell's overlooked object system},
      author={Oleg Kiselyov and Ralf Lämmel},
      year={2005},
      eprint={cs/0509027},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

% Guy Steele "Objects have not failed" 2002 https://www.dreamsongs.com/ObjectsHaveNotFailedNarr.html

% https://lmcs.episciences.org/4319
% This paper seems to be on the right track, but with much extra formalism and much missing insight.
% Classes add a layer of complexity, and I think there may be bugs. Sigh.
@article{DBLP:journals/corr/abs-1712-06906,
  author       = {Jan Bessai and
                  Tzu{-}Chun Chen and
                  Andrej Dudenhefner and
                  Boris D{\"{u}}dder and
                  Ugo de'Liguoro and
                  Jakob Rehof},
  title        = {Mixin Composition Synthesis based on Intersection Types},
  journal      = {CoRR},
  volume       = {abs/1712.06906},
  year         = {2017},
  url          = {http://arxiv.org/abs/1712.06906},
  eprinttype    = {arXiv},
  eprint       = {1712.06906},
  timestamp    = {Sat, 30 Sep 2023 10:08:07 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-1712-06906.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

% Open Data Types and Open Functions https://www.andres-loeh.de/OpenDatatypes.pdf
% Andres Löh and Ralf Hinze, PPDP 2006 -- not really OO, just use of typeclasses.
% cites O'Haskell (Norlander 2001) vs OOHaskell (Kiselyov & Lämmel 2005)

% TODO: Henry Lieberman papers about Actors, etc. -- when did he do inheritance / delegation?

% 2003  Tom Hirschowitz  Call-by-value mixin modules
% https://hirschowitz.pages.math.cnrs.fr/phd/these-tom.pdf
% https://hirschowitz.pages.math.cnrs.fr/

% https://www.quora.com/Why-is-functional-programming-seen-as-the-opposite-of-OOP-rather-than-an-addition-to-it/answer/Henry-Story
%

% https://people.mpi-sws.org/~rossberg/mixml/
% Andreas Rossberg, Derek Dreyer. Mixin' Up the ML Module System. TOPLAS 35(1), 2013. Revised and significantly extended version of the ICFP paper, including material from the appendices and a lot more.
% Derek Dreyer, Andreas Rossberg. Mixin' Up the ML Module System. ICFP, 2008.
% Derek Dreyer, Andreas Rossberg. Mixin' Up the ML Module System (Extended Mix). Expanded version including technical appendices, 2008.

% More digging on the origins of OO:
% https://x.com/Ngnghm/status/1898493837040849348

% B. Jacobs, "Objects and classes, co-algebraically" 1996 in "Object orientation with parallelism and persistence" pp. 83-103, cited by Cook2012

% B. Jacobs, Coalgebraic Reasoning about Classes in Object-Oriented Languages. Electr. Notes in Theor. Comp. Sci. 11, 1998. (Special issue on the workshop Coalgebraic Methods in Computer Science (CMCS 1998))

% Peter Wegner. Concepts and Paradigms of O..O..P.. 1990

% Goguen...

@book{cardelli1986understanding,
  title={On understanding types, data abstraction, and polymorphism},
  author={Cardelli, Luca and Wegner, Peter},
  year={1986},
  publisher={Brown University. Department of Computer Science},
  url={http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf}
}

% Successor to a 1980 experiment by Borning. No method combination. Unclear linearization. Low on details.
% Uses the Link class from SIMULA, and ReadWriteStream as motivations for multiple inheritance.
@inproceedings{borning1982multiple,
  title={Multiple inheritance in Smalltalk-80},
  author={Borning, Alan H and Ingalls, Daniel HH},
  booktitle={Proceedings at the National Conference on AI},
  volume={82},
  pages={234--237},
  year={1982}
}

% Parents are Shared Parts: Inheritance and Encapsulation in Self
% Craig Chambers, David Ungar, Bay-Wei Chang, and Urs Hölzle

@InProceedings{parentsSharedParts1991,
  title={Parents are Shared Parts of Objects: Inheritance and Encapsulation in SELF},
  author={Craig Chambers, David Ungar, Bay-Wei Chang, Urs Hölzle},
  booktitle={Lisp and Symbolic Computation},
  year={1991},
  url={https://bibliography.selflanguage.org/parents-shared-parts.html}
}
% What a mess. https://x.com/xadh/status/1945251704011665663
% https://github.com/shriram/plai-public/issues/62
%
% "prioritized inheritance": superclasses are assigned priorities,
% and between "ordered" superclasses at different priorities, it's like linearization,
% but between "unordered" superclasses at same priority, it's ambiguousMessage error.
% Also, when invoking a method, remember not just the self but the invoking super,
% according to a "sender path tiebreaking rule" unique to SELF.
% so that further slot accesses follow the path (what about nested access, though?
% Reset at SELF? stack of previous super?)
% Also, dynamic inheritance: can dynamically add/remove slots and superclasses (at various priorities)
% call-next-method is called "resend" and can change method (unlike CLOS, to follow same path)
% and arguments but not self, and also specify the sending parent (one level of parent,
% must be superclass of current sending parent).
% No method combinations: cites CLOS, but wants "simplicity" for SELF.
% Mention rename in Eiffel as an alternative, static way to deal with unordered inheritance
% Notes that C++ linearizes superclasses for constructors and destructors, just not for regular methods
%
% Issues: SELF mixins must be parentless to avoid their general parents
% overriding the mixed class's specific slots. "Backtracking", i.e. lack of a stack of senders as above.
% "considering altering SELF's lookup rule to always search children before their ancestors"
% and be more like CLOS in this way.
% NB: In their "complexities" they note how their lack a clear story for resend with dynamic inheritance
% --- but then I'm not sure if CLOS specifies it, especially in presence of concurrency, so there.
% They also support cycles but say it's too complex to explain how in the paper.
%

% change-class: https://github.com/shriram/plai-public/issues/60
